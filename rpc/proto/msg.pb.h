// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace rpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class PlayerBaseInfo;
class PlayerExtraInfo;
class BagItem;
class BagItemNofity;
class Signature;
class DailyTask;
class Score;
class BankruptInfo;
class ScoreNofify;
class Request;
class LoginCnsInfo;
class Login;
class LoginResult;
class PlayerInfo;
class ResourceNotify;
class OnlineBody;
class OnlineInfo;
class OnlinePlayerReq;
class OnlinePlayerMsg;
class NotifyMsg;
class HeartBeat;
class HeartBeatRst;
class PlayerInRoomNotify;
class RoleInfo;
class SysMail;
class PlayerMailInfo;
class ReqReadOneMail;
class RemoveMailNotify;
class AddMailNotify;
class ReqBroadCast;
class BroadCastNotify;
class FightChat;
class ReqFightRoomChat;
class FightRoomChatNotify;
class Notice;
class ReqInsurenceMoney;
class Player;
class FriendsList;
class RequestFriendsList;
class ReqString;
class ReqInt;
class SearchFriendNofify;
class ReqResponseAddFriend;
class AddFriendNofify;
class DelFriendNofity;
class FriendsIdList;
class SendFriendChat;
class OfflineMsgNofity;
class FriendStatusNofify;
class ErrorCodeNofify;
class TaskFinishNofity;
class ReqTaskShare;
class ReqRankList;
class RankInfo;
class RankList;
class FormatedMsg;
class Msg;
class NumberMsg;
class MsgArg;
class GuestBindOk;
class Ping;
class PingResult;
class KickPlayerMsg;
class C2SChatP2P;
class C2SChatAlliance;
class C2SChatWorld;
class S2CChatP2P;
class S2CChatWorld;
class Card;
class Pattern;
class UserInfo;
class EnterRoomREQ;
class QuickEnterRoomREQ;
class EnterRoomACK;
class LeaveRoomREQ;
class LeaveRoomACK;
class CountDown;
class FightPlayerInfo;
class FightCurrentStateInfo;
class GameStartACK;
class ActionREQ;
class ChiAtionArgs;
class ActionACK;
class ActionNotifyACK;
class CountdownNotifyACK;
class PassCardNotifyACK;
class PassedNotifyACK;
class MingTang;
class JieSuanCoin;
class DaerPlayerJieSuanPattern;
class JieSuanNotifyACK;
class JieSuanAdditionData;
class FinalJieSuanNotifyACK;
class MJCard;
class MJPattern;
class MJQuickEnterRoomREQ;
class MJEnterRoomACK;
class MJLeaveRoomREQ;
class MJLeaveRoomACK;
class MJCountDown;
class MJFightPlayerInfo;
class MJFightCurrentStateInfo;
class MJGameStartACK;
class MJActionACK;
class MJActionArgs;
class MJActionNotifyACK;
class MJCountdownNotifyACK;
class MJRemoveCardNotifyACK;
class MJTieGuiREQ;
class MJMingTang;
class MJPlayerJieSuanInfo;
class MJJieSuanNotifyACK;
class CreateRoomREQ;
class RoomInfo;
class CreateRoomACK;
class RoomListREQ;
class RoomListACK;
class JieSanRoomREQ;
class JieSanPlayerInfo;
class JieSanRoomNotify;
class JieSanRoomUpdateStatusNotify;
class EnterCustomRoomREQ;
class EnterCustomRoomACK;
class LeaveCustomRoomREQ;
class LeaveCustomRoomACK;
class FindRoomREQ;
class FindRoomACK;
class ForceLeaveRoomREQ;
class InviteFirendsJionCustomRoomREQ;
class InviteFirendsJionCustomRoomNotify;
class OtherPlayerInfo;
class OtherPlayerInfoREQ;
class MatchListREQ;
class MatchListACK;
class Match;
class EnrollREQ;
class EnrollACK;
class WithdrawREQ;
class WithdrawACK;
class AmountChangeNotifyACK;
class StartEntranceACK;
class OrderInfoNofity;
class PayResultNotify;
class PokerQuickEnterRoomREQ;
class CreatePockerRoomReq;
class CreatePockerRoomAck;
class C2SAction;
class S2CAction;
class ComparePokerPlayer;
class PockerBegin;
class S2CPockerManInfo;
class PockerManBase;
class Pocker;
class PockerRoomBase;
class PockerRoomInfo;
class LeavePockerRoom;

// ===================================================================

class PlayerBaseInfo : public ::google::protobuf::Message {
 public:
  PlayerBaseInfo();
  virtual ~PlayerBaseInfo();
  
  PlayerBaseInfo(const PlayerBaseInfo& from);
  
  inline PlayerBaseInfo& operator=(const PlayerBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerBaseInfo& default_instance();
  
  void Swap(PlayerBaseInfo* other);
  
  // implements Message ----------------------------------------------
  
  PlayerBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerBaseInfo& from);
  void MergeFrom(const PlayerBaseInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int32 sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // required int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // optional int32 exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);
  
  // optional int32 vipLeftDay = 6;
  inline bool has_vipleftday() const;
  inline void clear_vipleftday();
  static const int kVipLeftDayFieldNumber = 6;
  inline ::google::protobuf::int32 vipleftday() const;
  inline void set_vipleftday(::google::protobuf::int32 value);
  
  // optional int32 header = 7;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 7;
  inline ::google::protobuf::int32 header() const;
  inline void set_header(::google::protobuf::int32 value);
  
  // optional int32 coin = 8;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 8;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // optional int32 gem = 9;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 9;
  inline ::google::protobuf::int32 gem() const;
  inline void set_gem(::google::protobuf::int32 value);
  
  // optional int32 roleId = 10;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 10;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);
  
  // optional string gameType = 11;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 11;
  inline const ::std::string& gametype() const;
  inline void set_gametype(const ::std::string& value);
  inline void set_gametype(const char* value);
  inline void set_gametype(const char* value, size_t size);
  inline ::std::string* mutable_gametype();
  inline ::std::string* release_gametype();
  
  // optional int32 roomType = 12;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 12;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);
  
  // optional int32 insurCoin = 13;
  inline bool has_insurcoin() const;
  inline void clear_insurcoin();
  static const int kInsurCoinFieldNumber = 13;
  inline ::google::protobuf::int32 insurcoin() const;
  inline void set_insurcoin(::google::protobuf::int32 value);
  
  // optional int32 accountType = 14;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccountTypeFieldNumber = 14;
  inline ::google::protobuf::int32 accounttype() const;
  inline void set_accounttype(::google::protobuf::int32 value);
  
  // repeated string friendUids = 15;
  inline int frienduids_size() const;
  inline void clear_frienduids();
  static const int kFriendUidsFieldNumber = 15;
  inline const ::std::string& frienduids(int index) const;
  inline ::std::string* mutable_frienduids(int index);
  inline void set_frienduids(int index, const ::std::string& value);
  inline void set_frienduids(int index, const char* value);
  inline void set_frienduids(int index, const char* value, size_t size);
  inline ::std::string* add_frienduids();
  inline void add_frienduids(const ::std::string& value);
  inline void add_frienduids(const char* value);
  inline void add_frienduids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& frienduids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_frienduids();
  
  // optional string headerUrl = 16;
  inline bool has_headerurl() const;
  inline void clear_headerurl();
  static const int kHeaderUrlFieldNumber = 16;
  inline const ::std::string& headerurl() const;
  inline void set_headerurl(const ::std::string& value);
  inline void set_headerurl(const char* value);
  inline void set_headerurl(const char* value, size_t size);
  inline ::std::string* mutable_headerurl();
  inline ::std::string* release_headerurl();
  
  // optional string phone = 17;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 17;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  
  // optional bool bModifyName = 18;
  inline bool has_bmodifyname() const;
  inline void clear_bmodifyname();
  static const int kBModifyNameFieldNumber = 18;
  inline bool bmodifyname() const;
  inline void set_bmodifyname(bool value);
  
  // optional bool bModifySex = 19;
  inline bool has_bmodifysex() const;
  inline void clear_bmodifysex();
  static const int kBModifySexFieldNumber = 19;
  inline bool bmodifysex() const;
  inline void set_bmodifysex(bool value);
  
  // optional int32 lastLoginTime = 20;
  inline bool has_lastlogintime() const;
  inline void clear_lastlogintime();
  static const int kLastLoginTimeFieldNumber = 20;
  inline ::google::protobuf::int32 lastlogintime() const;
  inline void set_lastlogintime(::google::protobuf::int32 value);
  
  // optional int32 profits = 21;
  inline bool has_profits() const;
  inline void clear_profits();
  static const int kProfitsFieldNumber = 21;
  inline ::google::protobuf::int32 profits() const;
  inline void set_profits(::google::protobuf::int32 value);
  
  // optional int32 expTotal = 22;
  inline bool has_exptotal() const;
  inline void clear_exptotal();
  static const int kExpTotalFieldNumber = 22;
  inline ::google::protobuf::int32 exptotal() const;
  inline void set_exptotal(::google::protobuf::int32 value);
  
  // optional int32 vipOpenTime = 23;
  inline bool has_vipopentime() const;
  inline void clear_vipopentime();
  static const int kVipOpenTimeFieldNumber = 23;
  inline ::google::protobuf::int32 vipopentime() const;
  inline void set_vipopentime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.PlayerBaseInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_vipleftday();
  inline void clear_has_vipleftday();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_gem();
  inline void clear_has_gem();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_insurcoin();
  inline void clear_has_insurcoin();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_headerurl();
  inline void clear_has_headerurl();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_bmodifyname();
  inline void clear_has_bmodifyname();
  inline void set_has_bmodifysex();
  inline void clear_has_bmodifysex();
  inline void set_has_lastlogintime();
  inline void clear_has_lastlogintime();
  inline void set_has_profits();
  inline void clear_has_profits();
  inline void set_has_exptotal();
  inline void clear_has_exptotal();
  inline void set_has_vipopentime();
  inline void clear_has_vipopentime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::std::string* name_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 vipleftday_;
  ::google::protobuf::int32 header_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 gem_;
  ::google::protobuf::int32 roleid_;
  ::std::string* gametype_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 insurcoin_;
  ::google::protobuf::RepeatedPtrField< ::std::string> frienduids_;
  ::std::string* headerurl_;
  ::std::string* phone_;
  ::google::protobuf::int32 accounttype_;
  bool bmodifyname_;
  bool bmodifysex_;
  ::google::protobuf::int32 lastlogintime_;
  ::google::protobuf::int32 profits_;
  ::google::protobuf::int32 exptotal_;
  ::google::protobuf::int32 vipopentime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerExtraInfo : public ::google::protobuf::Message {
 public:
  PlayerExtraInfo();
  virtual ~PlayerExtraInfo();
  
  PlayerExtraInfo(const PlayerExtraInfo& from);
  
  inline PlayerExtraInfo& operator=(const PlayerExtraInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerExtraInfo& default_instance();
  
  void Swap(PlayerExtraInfo* other);
  
  // implements Message ----------------------------------------------
  
  PlayerExtraInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerExtraInfo& from);
  void MergeFrom(const PlayerExtraInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.BagItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::rpc::BagItem& items(int index) const;
  inline ::rpc::BagItem* mutable_items(int index);
  inline ::rpc::BagItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::BagItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::BagItem >*
      mutable_items();
  
  // optional .rpc.Signature sign = 2;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 2;
  inline const ::rpc::Signature& sign() const;
  inline ::rpc::Signature* mutable_sign();
  inline ::rpc::Signature* release_sign();
  
  // optional .rpc.DailyTask tasks = 3;
  inline bool has_tasks() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 3;
  inline const ::rpc::DailyTask& tasks() const;
  inline ::rpc::DailyTask* mutable_tasks();
  inline ::rpc::DailyTask* release_tasks();
  
  // repeated .rpc.Score scores = 4;
  inline int scores_size() const;
  inline void clear_scores();
  static const int kScoresFieldNumber = 4;
  inline const ::rpc::Score& scores(int index) const;
  inline ::rpc::Score* mutable_scores(int index);
  inline ::rpc::Score* add_scores();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Score >&
      scores() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Score >*
      mutable_scores();
  
  // optional .rpc.BankruptInfo bankrupt = 5;
  inline bool has_bankrupt() const;
  inline void clear_bankrupt();
  static const int kBankruptFieldNumber = 5;
  inline const ::rpc::BankruptInfo& bankrupt() const;
  inline ::rpc::BankruptInfo* mutable_bankrupt();
  inline ::rpc::BankruptInfo* release_bankrupt();
  
  // @@protoc_insertion_point(class_scope:rpc.PlayerExtraInfo)
 private:
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_tasks();
  inline void clear_has_tasks();
  inline void set_has_bankrupt();
  inline void clear_has_bankrupt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::BagItem > items_;
  ::rpc::Signature* sign_;
  ::rpc::DailyTask* tasks_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Score > scores_;
  ::rpc::BankruptInfo* bankrupt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerExtraInfo* default_instance_;
};
// -------------------------------------------------------------------

class BagItem : public ::google::protobuf::Message {
 public:
  BagItem();
  virtual ~BagItem();
  
  BagItem(const BagItem& from);
  
  inline BagItem& operator=(const BagItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BagItem& default_instance();
  
  void Swap(BagItem* other);
  
  // implements Message ----------------------------------------------
  
  BagItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagItem& from);
  void MergeFrom(const BagItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.BagItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::int32 num_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static BagItem* default_instance_;
};
// -------------------------------------------------------------------

class BagItemNofity : public ::google::protobuf::Message {
 public:
  BagItemNofity();
  virtual ~BagItemNofity();
  
  BagItemNofity(const BagItemNofity& from);
  
  inline BagItemNofity& operator=(const BagItemNofity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BagItemNofity& default_instance();
  
  void Swap(BagItemNofity* other);
  
  // implements Message ----------------------------------------------
  
  BagItemNofity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagItemNofity& from);
  void MergeFrom(const BagItemNofity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.BagItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::rpc::BagItem& items(int index) const;
  inline ::rpc::BagItem* mutable_items(int index);
  inline ::rpc::BagItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::BagItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::BagItem >*
      mutable_items();
  
  // @@protoc_insertion_point(class_scope:rpc.BagItemNofity)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::BagItem > items_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static BagItemNofity* default_instance_;
};
// -------------------------------------------------------------------

class Signature : public ::google::protobuf::Message {
 public:
  Signature();
  virtual ~Signature();
  
  Signature(const Signature& from);
  
  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signature& default_instance();
  
  void Swap(Signature* other);
  
  // implements Message ----------------------------------------------
  
  Signature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signature& from);
  void MergeFrom(const Signature& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 month = 1;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 1;
  inline ::google::protobuf::int32 month() const;
  inline void set_month(::google::protobuf::int32 value);
  
  // repeated int32 signs = 2;
  inline int signs_size() const;
  inline void clear_signs();
  static const int kSignsFieldNumber = 2;
  inline ::google::protobuf::int32 signs(int index) const;
  inline void set_signs(int index, ::google::protobuf::int32 value);
  inline void add_signs(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      signs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_signs();
  
  // optional int32 lastSign = 3;
  inline bool has_lastsign() const;
  inline void clear_lastsign();
  static const int kLastSignFieldNumber = 3;
  inline ::google::protobuf::int32 lastsign() const;
  inline void set_lastsign(::google::protobuf::int32 value);
  
  // optional int32 contiDay = 4;
  inline bool has_contiday() const;
  inline void clear_contiday();
  static const int kContiDayFieldNumber = 4;
  inline ::google::protobuf::int32 contiday() const;
  inline void set_contiday(::google::protobuf::int32 value);
  
  // optional int32 contiRewardTms = 5;
  inline bool has_contirewardtms() const;
  inline void clear_contirewardtms();
  static const int kContiRewardTmsFieldNumber = 5;
  inline ::google::protobuf::int32 contirewardtms() const;
  inline void set_contirewardtms(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.Signature)
 private:
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_lastsign();
  inline void clear_has_lastsign();
  inline void set_has_contiday();
  inline void clear_has_contiday();
  inline void set_has_contirewardtms();
  inline void clear_has_contirewardtms();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > signs_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 lastsign_;
  ::google::protobuf::int32 contiday_;
  ::google::protobuf::int32 contirewardtms_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Signature* default_instance_;
};
// -------------------------------------------------------------------

class DailyTask : public ::google::protobuf::Message {
 public:
  DailyTask();
  virtual ~DailyTask();
  
  DailyTask(const DailyTask& from);
  
  inline DailyTask& operator=(const DailyTask& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyTask& default_instance();
  
  void Swap(DailyTask* other);
  
  // implements Message ----------------------------------------------
  
  DailyTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DailyTask& from);
  void MergeFrom(const DailyTask& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 resetTime = 1;
  inline bool has_resettime() const;
  inline void clear_resettime();
  static const int kResetTimeFieldNumber = 1;
  inline ::google::protobuf::int32 resettime() const;
  inline void set_resettime(::google::protobuf::int32 value);
  
  // repeated int32 doneIds = 2;
  inline int doneids_size() const;
  inline void clear_doneids();
  static const int kDoneIdsFieldNumber = 2;
  inline ::google::protobuf::int32 doneids(int index) const;
  inline void set_doneids(int index, ::google::protobuf::int32 value);
  inline void add_doneids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      doneids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_doneids();
  
  // repeated int32 getIds = 3;
  inline int getids_size() const;
  inline void clear_getids();
  static const int kGetIdsFieldNumber = 3;
  inline ::google::protobuf::int32 getids(int index) const;
  inline void set_getids(int index, ::google::protobuf::int32 value);
  inline void add_getids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      getids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_getids();
  
  // optional int32 shares = 4;
  inline bool has_shares() const;
  inline void clear_shares();
  static const int kSharesFieldNumber = 4;
  inline ::google::protobuf::int32 shares() const;
  inline void set_shares(::google::protobuf::int32 value);
  
  // optional int32 shareFris = 5;
  inline bool has_sharefris() const;
  inline void clear_sharefris();
  static const int kShareFrisFieldNumber = 5;
  inline ::google::protobuf::int32 sharefris() const;
  inline void set_sharefris(::google::protobuf::int32 value);
  
  // optional int32 daerTms = 6;
  inline bool has_daertms() const;
  inline void clear_daertms();
  static const int kDaerTmsFieldNumber = 6;
  inline ::google::protobuf::int32 daertms() const;
  inline void set_daertms(::google::protobuf::int32 value);
  
  // optional int32 mjTms = 7;
  inline bool has_mjtms() const;
  inline void clear_mjtms();
  static const int kMjTmsFieldNumber = 7;
  inline ::google::protobuf::int32 mjtms() const;
  inline void set_mjtms(::google::protobuf::int32 value);
  
  // optional int32 pokerTms = 8;
  inline bool has_pokertms() const;
  inline void clear_pokertms();
  static const int kPokerTmsFieldNumber = 8;
  inline ::google::protobuf::int32 pokertms() const;
  inline void set_pokertms(::google::protobuf::int32 value);
  
  // optional int32 winDaerTms = 9;
  inline bool has_windaertms() const;
  inline void clear_windaertms();
  static const int kWinDaerTmsFieldNumber = 9;
  inline ::google::protobuf::int32 windaertms() const;
  inline void set_windaertms(::google::protobuf::int32 value);
  
  // optional int32 winMjTms = 10;
  inline bool has_winmjtms() const;
  inline void clear_winmjtms();
  static const int kWinMjTmsFieldNumber = 10;
  inline ::google::protobuf::int32 winmjtms() const;
  inline void set_winmjtms(::google::protobuf::int32 value);
  
  // optional int32 winPokerTms = 11;
  inline bool has_winpokertms() const;
  inline void clear_winpokertms();
  static const int kWinPokerTmsFieldNumber = 11;
  inline ::google::protobuf::int32 winpokertms() const;
  inline void set_winpokertms(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.DailyTask)
 private:
  inline void set_has_resettime();
  inline void clear_has_resettime();
  inline void set_has_shares();
  inline void clear_has_shares();
  inline void set_has_sharefris();
  inline void clear_has_sharefris();
  inline void set_has_daertms();
  inline void clear_has_daertms();
  inline void set_has_mjtms();
  inline void clear_has_mjtms();
  inline void set_has_pokertms();
  inline void clear_has_pokertms();
  inline void set_has_windaertms();
  inline void clear_has_windaertms();
  inline void set_has_winmjtms();
  inline void clear_has_winmjtms();
  inline void set_has_winpokertms();
  inline void clear_has_winpokertms();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > doneids_;
  ::google::protobuf::int32 resettime_;
  ::google::protobuf::int32 shares_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > getids_;
  ::google::protobuf::int32 sharefris_;
  ::google::protobuf::int32 daertms_;
  ::google::protobuf::int32 mjtms_;
  ::google::protobuf::int32 pokertms_;
  ::google::protobuf::int32 windaertms_;
  ::google::protobuf::int32 winmjtms_;
  ::google::protobuf::int32 winpokertms_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static DailyTask* default_instance_;
};
// -------------------------------------------------------------------

class Score : public ::google::protobuf::Message {
 public:
  Score();
  virtual ~Score();
  
  Score(const Score& from);
  
  inline Score& operator=(const Score& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Score& default_instance();
  
  void Swap(Score* other);
  
  // implements Message ----------------------------------------------
  
  Score* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Score& from);
  void MergeFrom(const Score& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 win = 2;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 2;
  inline ::google::protobuf::int32 win() const;
  inline void set_win(::google::protobuf::int32 value);
  
  // required int32 loss = 3;
  inline bool has_loss() const;
  inline void clear_loss();
  static const int kLossFieldNumber = 3;
  inline ::google::protobuf::int32 loss() const;
  inline void set_loss(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.Score)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_loss();
  inline void clear_has_loss();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 win_;
  ::google::protobuf::int32 loss_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Score* default_instance_;
};
// -------------------------------------------------------------------

class BankruptInfo : public ::google::protobuf::Message {
 public:
  BankruptInfo();
  virtual ~BankruptInfo();
  
  BankruptInfo(const BankruptInfo& from);
  
  inline BankruptInfo& operator=(const BankruptInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BankruptInfo& default_instance();
  
  void Swap(BankruptInfo* other);
  
  // implements Message ----------------------------------------------
  
  BankruptInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BankruptInfo& from);
  void MergeFrom(const BankruptInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // optional int32 rewardTimes = 2;
  inline bool has_rewardtimes() const;
  inline void clear_rewardtimes();
  static const int kRewardTimesFieldNumber = 2;
  inline ::google::protobuf::int32 rewardtimes() const;
  inline void set_rewardtimes(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.BankruptInfo)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_rewardtimes();
  inline void clear_has_rewardtimes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 rewardtimes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static BankruptInfo* default_instance_;
};
// -------------------------------------------------------------------

class ScoreNofify : public ::google::protobuf::Message {
 public:
  ScoreNofify();
  virtual ~ScoreNofify();
  
  ScoreNofify(const ScoreNofify& from);
  
  inline ScoreNofify& operator=(const ScoreNofify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreNofify& default_instance();
  
  void Swap(ScoreNofify* other);
  
  // implements Message ----------------------------------------------
  
  ScoreNofify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreNofify& from);
  void MergeFrom(const ScoreNofify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.Score scores = 1;
  inline int scores_size() const;
  inline void clear_scores();
  static const int kScoresFieldNumber = 1;
  inline const ::rpc::Score& scores(int index) const;
  inline ::rpc::Score* mutable_scores(int index);
  inline ::rpc::Score* add_scores();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Score >&
      scores() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Score >*
      mutable_scores();
  
  // @@protoc_insertion_point(class_scope:rpc.ScoreNofify)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::Score > scores_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ScoreNofify* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();
  
  Request(const Request& from);
  
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();
  
  void Swap(Request* other);
  
  // implements Message ----------------------------------------------
  
  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string method = 1;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 1;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  
  // optional bytes serialized_request = 2;
  inline bool has_serialized_request() const;
  inline void clear_serialized_request();
  static const int kSerializedRequestFieldNumber = 2;
  inline const ::std::string& serialized_request() const;
  inline void set_serialized_request(const ::std::string& value);
  inline void set_serialized_request(const char* value);
  inline void set_serialized_request(const void* value, size_t size);
  inline ::std::string* mutable_serialized_request();
  inline ::std::string* release_serialized_request();
  
  // @@protoc_insertion_point(class_scope:rpc.Request)
 private:
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_serialized_request();
  inline void clear_has_serialized_request();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* method_;
  ::std::string* serialized_request_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class LoginCnsInfo : public ::google::protobuf::Message {
 public:
  LoginCnsInfo();
  virtual ~LoginCnsInfo();
  
  LoginCnsInfo(const LoginCnsInfo& from);
  
  inline LoginCnsInfo& operator=(const LoginCnsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginCnsInfo& default_instance();
  
  void Swap(LoginCnsInfo* other);
  
  // implements Message ----------------------------------------------
  
  LoginCnsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginCnsInfo& from);
  void MergeFrom(const LoginCnsInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cnsIp = 1;
  inline bool has_cnsip() const;
  inline void clear_cnsip();
  static const int kCnsIpFieldNumber = 1;
  inline const ::std::string& cnsip() const;
  inline void set_cnsip(const ::std::string& value);
  inline void set_cnsip(const char* value);
  inline void set_cnsip(const char* value, size_t size);
  inline ::std::string* mutable_cnsip();
  inline ::std::string* release_cnsip();
  
  // required string gsInfo = 2;
  inline bool has_gsinfo() const;
  inline void clear_gsinfo();
  static const int kGsInfoFieldNumber = 2;
  inline const ::std::string& gsinfo() const;
  inline void set_gsinfo(const ::std::string& value);
  inline void set_gsinfo(const char* value);
  inline void set_gsinfo(const char* value, size_t size);
  inline ::std::string* mutable_gsinfo();
  inline ::std::string* release_gsinfo();
  
  // optional int32 versionOld = 3;
  inline bool has_versionold() const;
  inline void clear_versionold();
  static const int kVersionOldFieldNumber = 3;
  inline ::google::protobuf::int32 versionold() const;
  inline void set_versionold(::google::protobuf::int32 value);
  
  // optional int32 versionNew = 4;
  inline bool has_versionnew() const;
  inline void clear_versionnew();
  static const int kVersionNewFieldNumber = 4;
  inline ::google::protobuf::int32 versionnew() const;
  inline void set_versionnew(::google::protobuf::int32 value);
  
  // optional string downloadUrl = 5;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownloadUrlFieldNumber = 5;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  
  // optional int32 versionMid = 6;
  inline bool has_versionmid() const;
  inline void clear_versionmid();
  static const int kVersionMidFieldNumber = 6;
  inline ::google::protobuf::int32 versionmid() const;
  inline void set_versionmid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.LoginCnsInfo)
 private:
  inline void set_has_cnsip();
  inline void clear_has_cnsip();
  inline void set_has_gsinfo();
  inline void clear_has_gsinfo();
  inline void set_has_versionold();
  inline void clear_has_versionold();
  inline void set_has_versionnew();
  inline void clear_has_versionnew();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_versionmid();
  inline void clear_has_versionmid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cnsip_;
  ::std::string* gsinfo_;
  ::google::protobuf::int32 versionold_;
  ::google::protobuf::int32 versionnew_;
  ::std::string* downloadurl_;
  ::google::protobuf::int32 versionmid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static LoginCnsInfo* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();
  
  Login(const Login& from);
  
  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();
  
  void Swap(Login* other);
  
  // implements Message ----------------------------------------------
  
  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional string openid = 2;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 2;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  
  // optional int32 roleId = 3;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 3;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);
  
  // optional string headerUrl = 4;
  inline bool has_headerurl() const;
  inline void clear_headerurl();
  static const int kHeaderUrlFieldNumber = 4;
  inline const ::std::string& headerurl() const;
  inline void set_headerurl(const ::std::string& value);
  inline void set_headerurl(const char* value);
  inline void set_headerurl(const char* value, size_t size);
  inline ::std::string* mutable_headerurl();
  inline ::std::string* release_headerurl();
  
  // optional string nickName = 5;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 5;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // optional int32 sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // optional string clientVersion = 7;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 7;
  inline const ::std::string& clientversion() const;
  inline void set_clientversion(const ::std::string& value);
  inline void set_clientversion(const char* value);
  inline void set_clientversion(const char* value, size_t size);
  inline ::std::string* mutable_clientversion();
  inline ::std::string* release_clientversion();
  
  // @@protoc_insertion_point(class_scope:rpc.Login)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_headerurl();
  inline void clear_has_headerurl();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::std::string* openid_;
  ::std::string* headerurl_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 sex_;
  ::std::string* nickname_;
  ::std::string* clientversion_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class LoginResult : public ::google::protobuf::Message {
 public:
  LoginResult();
  virtual ~LoginResult();
  
  LoginResult(const LoginResult& from);
  
  inline LoginResult& operator=(const LoginResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResult& default_instance();
  
  void Swap(LoginResult* other);
  
  // implements Message ----------------------------------------------
  
  LoginResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResult& from);
  void MergeFrom(const LoginResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const char* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  
  // required int64 server_time = 2;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 2;
  inline ::google::protobuf::int64 server_time() const;
  inline void set_server_time(::google::protobuf::int64 value);
  
  // optional string errmsg = 3;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 3;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  
  // optional string openid = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  
  // optional string uid = 5;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 5;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional int32 roleId = 6;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 6;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.LoginResult)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_server_time();
  inline void clear_has_server_time();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* result_;
  ::google::protobuf::int64 server_time_;
  ::std::string* errmsg_;
  ::std::string* openid_;
  ::std::string* uid_;
  ::google::protobuf::int32 roleid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResult* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();
  
  PlayerInfo(const PlayerInfo& from);
  
  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();
  
  void Swap(PlayerInfo* other);
  
  // implements Message ----------------------------------------------
  
  PlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .rpc.PlayerBaseInfo base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::rpc::PlayerBaseInfo& base() const;
  inline ::rpc::PlayerBaseInfo* mutable_base();
  inline ::rpc::PlayerBaseInfo* release_base();
  
  // optional .rpc.PlayerExtraInfo extra = 2;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 2;
  inline const ::rpc::PlayerExtraInfo& extra() const;
  inline ::rpc::PlayerExtraInfo* mutable_extra();
  inline ::rpc::PlayerExtraInfo* release_extra();
  
  // @@protoc_insertion_point(class_scope:rpc.PlayerInfo)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_extra();
  inline void clear_has_extra();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::PlayerBaseInfo* base_;
  ::rpc::PlayerExtraInfo* extra_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResourceNotify : public ::google::protobuf::Message {
 public:
  ResourceNotify();
  virtual ~ResourceNotify();
  
  ResourceNotify(const ResourceNotify& from);
  
  inline ResourceNotify& operator=(const ResourceNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceNotify& default_instance();
  
  void Swap(ResourceNotify* other);
  
  // implements Message ----------------------------------------------
  
  ResourceNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceNotify& from);
  void MergeFrom(const ResourceNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 coin = 1;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 1;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // optional int32 gem = 2;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 2;
  inline ::google::protobuf::int32 gem() const;
  inline void set_gem(::google::protobuf::int32 value);
  
  // optional int32 insurCoin = 3;
  inline bool has_insurcoin() const;
  inline void clear_insurcoin();
  static const int kInsurCoinFieldNumber = 3;
  inline ::google::protobuf::int32 insurcoin() const;
  inline void set_insurcoin(::google::protobuf::int32 value);
  
  // optional int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // optional int32 exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.ResourceNotify)
 private:
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_gem();
  inline void clear_has_gem();
  inline void set_has_insurcoin();
  inline void clear_has_insurcoin();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 gem_;
  ::google::protobuf::int32 insurcoin_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 exp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceNotify* default_instance_;
};
// -------------------------------------------------------------------

class OnlineBody : public ::google::protobuf::Message {
 public:
  OnlineBody();
  virtual ~OnlineBody();
  
  OnlineBody(const OnlineBody& from);
  
  inline OnlineBody& operator=(const OnlineBody& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineBody& default_instance();
  
  void Swap(OnlineBody* other);
  
  // implements Message ----------------------------------------------
  
  OnlineBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineBody& from);
  void MergeFrom(const OnlineBody& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // required int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.OnlineBody)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_num();
  inline void clear_has_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 num_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static OnlineBody* default_instance_;
};
// -------------------------------------------------------------------

class OnlineInfo : public ::google::protobuf::Message {
 public:
  OnlineInfo();
  virtual ~OnlineInfo();
  
  OnlineInfo(const OnlineInfo& from);
  
  inline OnlineInfo& operator=(const OnlineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineInfo& default_instance();
  
  void Swap(OnlineInfo* other);
  
  // implements Message ----------------------------------------------
  
  OnlineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineInfo& from);
  void MergeFrom(const OnlineInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.OnlineBody info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::rpc::OnlineBody& info(int index) const;
  inline ::rpc::OnlineBody* mutable_info(int index);
  inline ::rpc::OnlineBody* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::OnlineBody >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::OnlineBody >*
      mutable_info();
  
  // @@protoc_insertion_point(class_scope:rpc.OnlineInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::OnlineBody > info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static OnlineInfo* default_instance_;
};
// -------------------------------------------------------------------

class OnlinePlayerReq : public ::google::protobuf::Message {
 public:
  OnlinePlayerReq();
  virtual ~OnlinePlayerReq();
  
  OnlinePlayerReq(const OnlinePlayerReq& from);
  
  inline OnlinePlayerReq& operator=(const OnlinePlayerReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlinePlayerReq& default_instance();
  
  void Swap(OnlinePlayerReq* other);
  
  // implements Message ----------------------------------------------
  
  OnlinePlayerReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlinePlayerReq& from);
  void MergeFrom(const OnlinePlayerReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 partIds = 1;
  inline int partids_size() const;
  inline void clear_partids();
  static const int kPartIdsFieldNumber = 1;
  inline ::google::protobuf::int32 partids(int index) const;
  inline void set_partids(int index, ::google::protobuf::int32 value);
  inline void add_partids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      partids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_partids();
  
  // @@protoc_insertion_point(class_scope:rpc.OnlinePlayerReq)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > partids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static OnlinePlayerReq* default_instance_;
};
// -------------------------------------------------------------------

class OnlinePlayerMsg : public ::google::protobuf::Message {
 public:
  OnlinePlayerMsg();
  virtual ~OnlinePlayerMsg();
  
  OnlinePlayerMsg(const OnlinePlayerMsg& from);
  
  inline OnlinePlayerMsg& operator=(const OnlinePlayerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlinePlayerMsg& default_instance();
  
  void Swap(OnlinePlayerMsg* other);
  
  // implements Message ----------------------------------------------
  
  OnlinePlayerMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlinePlayerMsg& from);
  void MergeFrom(const OnlinePlayerMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .rpc.OnlineInfo daerInfo = 1;
  inline bool has_daerinfo() const;
  inline void clear_daerinfo();
  static const int kDaerInfoFieldNumber = 1;
  inline const ::rpc::OnlineInfo& daerinfo() const;
  inline ::rpc::OnlineInfo* mutable_daerinfo();
  inline ::rpc::OnlineInfo* release_daerinfo();
  
  // optional .rpc.OnlineInfo mjInfo = 2;
  inline bool has_mjinfo() const;
  inline void clear_mjinfo();
  static const int kMjInfoFieldNumber = 2;
  inline const ::rpc::OnlineInfo& mjinfo() const;
  inline ::rpc::OnlineInfo* mutable_mjinfo();
  inline ::rpc::OnlineInfo* release_mjinfo();
  
  // optional .rpc.OnlineInfo pokerInfo = 3;
  inline bool has_pokerinfo() const;
  inline void clear_pokerinfo();
  static const int kPokerInfoFieldNumber = 3;
  inline const ::rpc::OnlineInfo& pokerinfo() const;
  inline ::rpc::OnlineInfo* mutable_pokerinfo();
  inline ::rpc::OnlineInfo* release_pokerinfo();
  
  // @@protoc_insertion_point(class_scope:rpc.OnlinePlayerMsg)
 private:
  inline void set_has_daerinfo();
  inline void clear_has_daerinfo();
  inline void set_has_mjinfo();
  inline void clear_has_mjinfo();
  inline void set_has_pokerinfo();
  inline void clear_has_pokerinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::OnlineInfo* daerinfo_;
  ::rpc::OnlineInfo* mjinfo_;
  ::rpc::OnlineInfo* pokerinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static OnlinePlayerMsg* default_instance_;
};
// -------------------------------------------------------------------

class NotifyMsg : public ::google::protobuf::Message {
 public:
  NotifyMsg();
  virtual ~NotifyMsg();
  
  NotifyMsg(const NotifyMsg& from);
  
  inline NotifyMsg& operator=(const NotifyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyMsg& default_instance();
  
  void Swap(NotifyMsg* other);
  
  // implements Message ----------------------------------------------
  
  NotifyMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyMsg& from);
  void MergeFrom(const NotifyMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string txtId = 1;
  inline bool has_txtid() const;
  inline void clear_txtid();
  static const int kTxtIdFieldNumber = 1;
  inline const ::std::string& txtid() const;
  inline void set_txtid(const ::std::string& value);
  inline void set_txtid(const char* value);
  inline void set_txtid(const char* value, size_t size);
  inline ::std::string* mutable_txtid();
  inline ::std::string* release_txtid();
  
  // @@protoc_insertion_point(class_scope:rpc.NotifyMsg)
 private:
  inline void set_has_txtid();
  inline void clear_has_txtid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* txtid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static NotifyMsg* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeat : public ::google::protobuf::Message {
 public:
  HeartBeat();
  virtual ~HeartBeat();
  
  HeartBeat(const HeartBeat& from);
  
  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();
  
  void Swap(HeartBeat* other);
  
  // implements Message ----------------------------------------------
  
  HeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:rpc.HeartBeat)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static HeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatRst : public ::google::protobuf::Message {
 public:
  HeartBeatRst();
  virtual ~HeartBeatRst();
  
  HeartBeatRst(const HeartBeatRst& from);
  
  inline HeartBeatRst& operator=(const HeartBeatRst& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatRst& default_instance();
  
  void Swap(HeartBeatRst* other);
  
  // implements Message ----------------------------------------------
  
  HeartBeatRst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeatRst& from);
  void MergeFrom(const HeartBeatRst& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:rpc.HeartBeatRst)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static HeartBeatRst* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInRoomNotify : public ::google::protobuf::Message {
 public:
  PlayerInRoomNotify();
  virtual ~PlayerInRoomNotify();
  
  PlayerInRoomNotify(const PlayerInRoomNotify& from);
  
  inline PlayerInRoomNotify& operator=(const PlayerInRoomNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInRoomNotify& default_instance();
  
  void Swap(PlayerInRoomNotify* other);
  
  // implements Message ----------------------------------------------
  
  PlayerInRoomNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInRoomNotify& from);
  void MergeFrom(const PlayerInRoomNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string gameType = 1;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 1;
  inline const ::std::string& gametype() const;
  inline void set_gametype(const ::std::string& value);
  inline void set_gametype(const char* value);
  inline void set_gametype(const char* value, size_t size);
  inline ::std::string* mutable_gametype();
  inline ::std::string* release_gametype();
  
  // required int32 roomType = 2;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 2;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.PlayerInRoomNotify)
 private:
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* gametype_;
  ::google::protobuf::int32 roomtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerInRoomNotify* default_instance_;
};
// -------------------------------------------------------------------

class RoleInfo : public ::google::protobuf::Message {
 public:
  RoleInfo();
  virtual ~RoleInfo();
  
  RoleInfo(const RoleInfo& from);
  
  inline RoleInfo& operator=(const RoleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleInfo& default_instance();
  
  void Swap(RoleInfo* other);
  
  // implements Message ----------------------------------------------
  
  RoleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleInfo& from);
  void MergeFrom(const RoleInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int32 sex = 2;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 2;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // optional string phone = 3;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 3;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  
  // @@protoc_insertion_point(class_scope:rpc.RoleInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_phone();
  inline void clear_has_phone();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* phone_;
  ::google::protobuf::int32 sex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static RoleInfo* default_instance_;
};
// -------------------------------------------------------------------

class SysMail : public ::google::protobuf::Message {
 public:
  SysMail();
  virtual ~SysMail();
  
  SysMail(const SysMail& from);
  
  inline SysMail& operator=(const SysMail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SysMail& default_instance();
  
  void Swap(SysMail* other);
  
  // implements Message ----------------------------------------------
  
  SysMail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysMail& from);
  void MergeFrom(const SysMail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string mailId = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIdFieldNumber = 1;
  inline const ::std::string& mailid() const;
  inline void set_mailid(const ::std::string& value);
  inline void set_mailid(const char* value);
  inline void set_mailid(const char* value, size_t size);
  inline ::std::string* mutable_mailid();
  inline ::std::string* release_mailid();
  
  // required int32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // required string content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // required int32 sendtime = 5;
  inline bool has_sendtime() const;
  inline void clear_sendtime();
  static const int kSendtimeFieldNumber = 5;
  inline ::google::protobuf::int32 sendtime() const;
  inline void set_sendtime(::google::protobuf::int32 value);
  
  // optional string attach = 6;
  inline bool has_attach() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 6;
  inline const ::std::string& attach() const;
  inline void set_attach(const ::std::string& value);
  inline void set_attach(const char* value);
  inline void set_attach(const char* value, size_t size);
  inline ::std::string* mutable_attach();
  inline ::std::string* release_attach();
  
  // optional int32 overduetime = 7;
  inline bool has_overduetime() const;
  inline void clear_overduetime();
  static const int kOverduetimeFieldNumber = 7;
  inline ::google::protobuf::int32 overduetime() const;
  inline void set_overduetime(::google::protobuf::int32 value);
  
  // optional bool bRead = 8;
  inline bool has_bread() const;
  inline void clear_bread();
  static const int kBReadFieldNumber = 8;
  inline bool bread() const;
  inline void set_bread(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.SysMail)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_sendtime();
  inline void clear_has_sendtime();
  inline void set_has_attach();
  inline void clear_has_attach();
  inline void set_has_overduetime();
  inline void clear_has_overduetime();
  inline void set_has_bread();
  inline void clear_has_bread();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* mailid_;
  ::std::string* title_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 sendtime_;
  ::std::string* content_;
  ::std::string* attach_;
  ::google::protobuf::int32 overduetime_;
  bool bread_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static SysMail* default_instance_;
};
// -------------------------------------------------------------------

class PlayerMailInfo : public ::google::protobuf::Message {
 public:
  PlayerMailInfo();
  virtual ~PlayerMailInfo();
  
  PlayerMailInfo(const PlayerMailInfo& from);
  
  inline PlayerMailInfo& operator=(const PlayerMailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerMailInfo& default_instance();
  
  void Swap(PlayerMailInfo* other);
  
  // implements Message ----------------------------------------------
  
  PlayerMailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerMailInfo& from);
  void MergeFrom(const PlayerMailInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 sysmail_version = 1;
  inline bool has_sysmail_version() const;
  inline void clear_sysmail_version();
  static const int kSysmailVersionFieldNumber = 1;
  inline ::google::protobuf::int32 sysmail_version() const;
  inline void set_sysmail_version(::google::protobuf::int32 value);
  
  // repeated .rpc.SysMail maillist = 2;
  inline int maillist_size() const;
  inline void clear_maillist();
  static const int kMaillistFieldNumber = 2;
  inline const ::rpc::SysMail& maillist(int index) const;
  inline ::rpc::SysMail* mutable_maillist(int index);
  inline ::rpc::SysMail* add_maillist();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::SysMail >&
      maillist() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::SysMail >*
      mutable_maillist();
  
  // @@protoc_insertion_point(class_scope:rpc.PlayerMailInfo)
 private:
  inline void set_has_sysmail_version();
  inline void clear_has_sysmail_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::SysMail > maillist_;
  ::google::protobuf::int32 sysmail_version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerMailInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqReadOneMail : public ::google::protobuf::Message {
 public:
  ReqReadOneMail();
  virtual ~ReqReadOneMail();
  
  ReqReadOneMail(const ReqReadOneMail& from);
  
  inline ReqReadOneMail& operator=(const ReqReadOneMail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqReadOneMail& default_instance();
  
  void Swap(ReqReadOneMail* other);
  
  // implements Message ----------------------------------------------
  
  ReqReadOneMail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqReadOneMail& from);
  void MergeFrom(const ReqReadOneMail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string mailId = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIdFieldNumber = 1;
  inline const ::std::string& mailid() const;
  inline void set_mailid(const ::std::string& value);
  inline void set_mailid(const char* value);
  inline void set_mailid(const char* value, size_t size);
  inline ::std::string* mutable_mailid();
  inline ::std::string* release_mailid();
  
  // @@protoc_insertion_point(class_scope:rpc.ReqReadOneMail)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* mailid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ReqReadOneMail* default_instance_;
};
// -------------------------------------------------------------------

class RemoveMailNotify : public ::google::protobuf::Message {
 public:
  RemoveMailNotify();
  virtual ~RemoveMailNotify();
  
  RemoveMailNotify(const RemoveMailNotify& from);
  
  inline RemoveMailNotify& operator=(const RemoveMailNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveMailNotify& default_instance();
  
  void Swap(RemoveMailNotify* other);
  
  // implements Message ----------------------------------------------
  
  RemoveMailNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveMailNotify& from);
  void MergeFrom(const RemoveMailNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 mailIds = 1;
  inline int mailids_size() const;
  inline void clear_mailids();
  static const int kMailIdsFieldNumber = 1;
  inline ::google::protobuf::int32 mailids(int index) const;
  inline void set_mailids(int index, ::google::protobuf::int32 value);
  inline void add_mailids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      mailids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_mailids();
  
  // @@protoc_insertion_point(class_scope:rpc.RemoveMailNotify)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > mailids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static RemoveMailNotify* default_instance_;
};
// -------------------------------------------------------------------

class AddMailNotify : public ::google::protobuf::Message {
 public:
  AddMailNotify();
  virtual ~AddMailNotify();
  
  AddMailNotify(const AddMailNotify& from);
  
  inline AddMailNotify& operator=(const AddMailNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddMailNotify& default_instance();
  
  void Swap(AddMailNotify* other);
  
  // implements Message ----------------------------------------------
  
  AddMailNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddMailNotify& from);
  void MergeFrom(const AddMailNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.SysMail maillist = 1;
  inline int maillist_size() const;
  inline void clear_maillist();
  static const int kMaillistFieldNumber = 1;
  inline const ::rpc::SysMail& maillist(int index) const;
  inline ::rpc::SysMail* mutable_maillist(int index);
  inline ::rpc::SysMail* add_maillist();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::SysMail >&
      maillist() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::SysMail >*
      mutable_maillist();
  
  // @@protoc_insertion_point(class_scope:rpc.AddMailNotify)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::SysMail > maillist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static AddMailNotify* default_instance_;
};
// -------------------------------------------------------------------

class ReqBroadCast : public ::google::protobuf::Message {
 public:
  ReqBroadCast();
  virtual ~ReqBroadCast();
  
  ReqBroadCast(const ReqBroadCast& from);
  
  inline ReqBroadCast& operator=(const ReqBroadCast& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBroadCast& default_instance();
  
  void Swap(ReqBroadCast* other);
  
  // implements Message ----------------------------------------------
  
  ReqBroadCast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqBroadCast& from);
  void MergeFrom(const ReqBroadCast& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // optional bool bVip = 3;
  inline bool has_bvip() const;
  inline void clear_bvip();
  static const int kBVipFieldNumber = 3;
  inline bool bvip() const;
  inline void set_bvip(bool value);
  
  // optional string playerName = 4;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayerNameFieldNumber = 4;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  
  // @@protoc_insertion_point(class_scope:rpc.ReqBroadCast)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_bvip();
  inline void clear_has_bvip();
  inline void set_has_playername();
  inline void clear_has_playername();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::std::string* content_;
  ::std::string* playername_;
  bool bvip_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ReqBroadCast* default_instance_;
};
// -------------------------------------------------------------------

class BroadCastNotify : public ::google::protobuf::Message {
 public:
  BroadCastNotify();
  virtual ~BroadCastNotify();
  
  BroadCastNotify(const BroadCastNotify& from);
  
  inline BroadCastNotify& operator=(const BroadCastNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadCastNotify& default_instance();
  
  void Swap(BroadCastNotify* other);
  
  // implements Message ----------------------------------------------
  
  BroadCastNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadCastNotify& from);
  void MergeFrom(const BroadCastNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 broadCastID = 1;
  inline bool has_broadcastid() const;
  inline void clear_broadcastid();
  static const int kBroadCastIDFieldNumber = 1;
  inline ::google::protobuf::int32 broadcastid() const;
  inline void set_broadcastid(::google::protobuf::int32 value);
  
  // required bool sysBroad = 2;
  inline bool has_sysbroad() const;
  inline void clear_sysbroad();
  static const int kSysBroadFieldNumber = 2;
  inline bool sysbroad() const;
  inline void set_sysbroad(bool value);
  
  // required string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // optional string playerName = 4;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayerNameFieldNumber = 4;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  
  // optional string playerID = 5;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 5;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional bool vip = 6;
  inline bool has_vip() const;
  inline void clear_vip();
  static const int kVipFieldNumber = 6;
  inline bool vip() const;
  inline void set_vip(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.BroadCastNotify)
 private:
  inline void set_has_broadcastid();
  inline void clear_has_broadcastid();
  inline void set_has_sysbroad();
  inline void clear_has_sysbroad();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_playername();
  inline void clear_has_playername();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_vip();
  inline void clear_has_vip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* content_;
  ::google::protobuf::int32 broadcastid_;
  bool sysbroad_;
  bool vip_;
  ::std::string* playername_;
  ::std::string* playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static BroadCastNotify* default_instance_;
};
// -------------------------------------------------------------------

class FightChat : public ::google::protobuf::Message {
 public:
  FightChat();
  virtual ~FightChat();
  
  FightChat(const FightChat& from);
  
  inline FightChat& operator=(const FightChat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FightChat& default_instance();
  
  void Swap(FightChat* other);
  
  // implements Message ----------------------------------------------
  
  FightChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FightChat& from);
  void MergeFrom(const FightChat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 chatType = 1;
  inline bool has_chattype() const;
  inline void clear_chattype();
  static const int kChatTypeFieldNumber = 1;
  inline ::google::protobuf::int32 chattype() const;
  inline void set_chattype(::google::protobuf::int32 value);
  
  // optional int32 faceID = 2;
  inline bool has_faceid() const;
  inline void clear_faceid();
  static const int kFaceIDFieldNumber = 2;
  inline ::google::protobuf::int32 faceid() const;
  inline void set_faceid(::google::protobuf::int32 value);
  
  // optional int32 fixWordID = 3;
  inline bool has_fixwordid() const;
  inline void clear_fixwordid();
  static const int kFixWordIDFieldNumber = 3;
  inline ::google::protobuf::int32 fixwordid() const;
  inline void set_fixwordid(::google::protobuf::int32 value);
  
  // optional string gameType = 4;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 4;
  inline const ::std::string& gametype() const;
  inline void set_gametype(const ::std::string& value);
  inline void set_gametype(const char* value);
  inline void set_gametype(const char* value, size_t size);
  inline ::std::string* mutable_gametype();
  inline ::std::string* release_gametype();
  
  // optional string customContent = 5;
  inline bool has_customcontent() const;
  inline void clear_customcontent();
  static const int kCustomContentFieldNumber = 5;
  inline const ::std::string& customcontent() const;
  inline void set_customcontent(const ::std::string& value);
  inline void set_customcontent(const char* value);
  inline void set_customcontent(const char* value, size_t size);
  inline ::std::string* mutable_customcontent();
  inline ::std::string* release_customcontent();
  
  // optional string itemId = 6;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 6;
  inline const ::std::string& itemid() const;
  inline void set_itemid(const ::std::string& value);
  inline void set_itemid(const char* value);
  inline void set_itemid(const char* value, size_t size);
  inline ::std::string* mutable_itemid();
  inline ::std::string* release_itemid();
  
  // optional string receiverPlayerID = 7;
  inline bool has_receiverplayerid() const;
  inline void clear_receiverplayerid();
  static const int kReceiverPlayerIDFieldNumber = 7;
  inline const ::std::string& receiverplayerid() const;
  inline void set_receiverplayerid(const ::std::string& value);
  inline void set_receiverplayerid(const char* value);
  inline void set_receiverplayerid(const char* value, size_t size);
  inline ::std::string* mutable_receiverplayerid();
  inline ::std::string* release_receiverplayerid();
  
  // @@protoc_insertion_point(class_scope:rpc.FightChat)
 private:
  inline void set_has_chattype();
  inline void clear_has_chattype();
  inline void set_has_faceid();
  inline void clear_has_faceid();
  inline void set_has_fixwordid();
  inline void clear_has_fixwordid();
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_customcontent();
  inline void clear_has_customcontent();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_receiverplayerid();
  inline void clear_has_receiverplayerid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 chattype_;
  ::google::protobuf::int32 faceid_;
  ::std::string* gametype_;
  ::std::string* customcontent_;
  ::std::string* itemid_;
  ::std::string* receiverplayerid_;
  ::google::protobuf::int32 fixwordid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FightChat* default_instance_;
};
// -------------------------------------------------------------------

class ReqFightRoomChat : public ::google::protobuf::Message {
 public:
  ReqFightRoomChat();
  virtual ~ReqFightRoomChat();
  
  ReqFightRoomChat(const ReqFightRoomChat& from);
  
  inline ReqFightRoomChat& operator=(const ReqFightRoomChat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqFightRoomChat& default_instance();
  
  void Swap(ReqFightRoomChat* other);
  
  // implements Message ----------------------------------------------
  
  ReqFightRoomChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqFightRoomChat& from);
  void MergeFrom(const ReqFightRoomChat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // required .rpc.FightChat fighChatinfo = 2;
  inline bool has_fighchatinfo() const;
  inline void clear_fighchatinfo();
  static const int kFighChatinfoFieldNumber = 2;
  inline const ::rpc::FightChat& fighchatinfo() const;
  inline ::rpc::FightChat* mutable_fighchatinfo();
  inline ::rpc::FightChat* release_fighchatinfo();
  
  // @@protoc_insertion_point(class_scope:rpc.ReqFightRoomChat)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_fighchatinfo();
  inline void clear_has_fighchatinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::rpc::FightChat* fighchatinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ReqFightRoomChat* default_instance_;
};
// -------------------------------------------------------------------

class FightRoomChatNotify : public ::google::protobuf::Message {
 public:
  FightRoomChatNotify();
  virtual ~FightRoomChatNotify();
  
  FightRoomChatNotify(const FightRoomChatNotify& from);
  
  inline FightRoomChatNotify& operator=(const FightRoomChatNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FightRoomChatNotify& default_instance();
  
  void Swap(FightRoomChatNotify* other);
  
  // implements Message ----------------------------------------------
  
  FightRoomChatNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FightRoomChatNotify& from);
  void MergeFrom(const FightRoomChatNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional .rpc.FightChat fighChatinfo = 2;
  inline bool has_fighchatinfo() const;
  inline void clear_fighchatinfo();
  static const int kFighChatinfoFieldNumber = 2;
  inline const ::rpc::FightChat& fighchatinfo() const;
  inline ::rpc::FightChat* mutable_fighchatinfo();
  inline ::rpc::FightChat* release_fighchatinfo();
  
  // optional bool offline = 3;
  inline bool has_offline() const;
  inline void clear_offline();
  static const int kOfflineFieldNumber = 3;
  inline bool offline() const;
  inline void set_offline(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.FightRoomChatNotify)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_fighchatinfo();
  inline void clear_has_fighchatinfo();
  inline void set_has_offline();
  inline void clear_has_offline();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::rpc::FightChat* fighchatinfo_;
  bool offline_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FightRoomChatNotify* default_instance_;
};
// -------------------------------------------------------------------

class Notice : public ::google::protobuf::Message {
 public:
  Notice();
  virtual ~Notice();
  
  Notice(const Notice& from);
  
  inline Notice& operator=(const Notice& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Notice& default_instance();
  
  void Swap(Notice* other);
  
  // implements Message ----------------------------------------------
  
  Notice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Notice& from);
  void MergeFrom(const Notice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // @@protoc_insertion_point(class_scope:rpc.Notice)
 private:
  inline void set_has_content();
  inline void clear_has_content();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* content_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Notice* default_instance_;
};
// -------------------------------------------------------------------

class ReqInsurenceMoney : public ::google::protobuf::Message {
 public:
  ReqInsurenceMoney();
  virtual ~ReqInsurenceMoney();
  
  ReqInsurenceMoney(const ReqInsurenceMoney& from);
  
  inline ReqInsurenceMoney& operator=(const ReqInsurenceMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqInsurenceMoney& default_instance();
  
  void Swap(ReqInsurenceMoney* other);
  
  // implements Message ----------------------------------------------
  
  ReqInsurenceMoney* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqInsurenceMoney& from);
  void MergeFrom(const ReqInsurenceMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool bWithdraw = 1;
  inline bool has_bwithdraw() const;
  inline void clear_bwithdraw();
  static const int kBWithdrawFieldNumber = 1;
  inline bool bwithdraw() const;
  inline void set_bwithdraw(bool value);
  
  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.ReqInsurenceMoney)
 private:
  inline void set_has_bwithdraw();
  inline void clear_has_bwithdraw();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool bwithdraw_;
  ::google::protobuf::int32 value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ReqInsurenceMoney* default_instance_;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message {
 public:
  Player();
  virtual ~Player();
  
  Player(const Player& from);
  
  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();
  
  void Swap(Player* other);
  
  // implements Message ----------------------------------------------
  
  Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int32 sex = 2;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 2;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // optional int32 header = 4;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 4;
  inline ::google::protobuf::int32 header() const;
  inline void set_header(::google::protobuf::int32 value);
  
  // optional int32 roleId = 5;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 5;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);
  
  // optional string headerUrl = 6;
  inline bool has_headerurl() const;
  inline void clear_headerurl();
  static const int kHeaderUrlFieldNumber = 6;
  inline const ::std::string& headerurl() const;
  inline void set_headerurl(const ::std::string& value);
  inline void set_headerurl(const char* value);
  inline void set_headerurl(const char* value, size_t size);
  inline ::std::string* mutable_headerurl();
  inline ::std::string* release_headerurl();
  
  // optional string uid = 7;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 7;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional bool bOnline = 8;
  inline bool has_bonline() const;
  inline void clear_bonline();
  static const int kBOnlineFieldNumber = 8;
  inline bool bonline() const;
  inline void set_bonline(bool value);
  
  // optional int32 exp = 9;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 9;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);
  
  // optional int32 coin = 10;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 10;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // repeated .rpc.Score scores = 11;
  inline int scores_size() const;
  inline void clear_scores();
  static const int kScoresFieldNumber = 11;
  inline const ::rpc::Score& scores(int index) const;
  inline ::rpc::Score* mutable_scores(int index);
  inline ::rpc::Score* add_scores();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Score >&
      scores() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Score >*
      mutable_scores();
  
  // optional int32 diamond = 12;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 12;
  inline ::google::protobuf::int32 diamond() const;
  inline void set_diamond(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.Player)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_headerurl();
  inline void clear_has_headerurl();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_bonline();
  inline void clear_has_bonline();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_diamond();
  inline void clear_has_diamond();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 header_;
  ::google::protobuf::int32 roleid_;
  ::std::string* headerurl_;
  ::std::string* uid_;
  bool bonline_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Score > scores_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 diamond_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Player* default_instance_;
};
// -------------------------------------------------------------------

class FriendsList : public ::google::protobuf::Message {
 public:
  FriendsList();
  virtual ~FriendsList();
  
  FriendsList(const FriendsList& from);
  
  inline FriendsList& operator=(const FriendsList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendsList& default_instance();
  
  void Swap(FriendsList* other);
  
  // implements Message ----------------------------------------------
  
  FriendsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FriendsList& from);
  void MergeFrom(const FriendsList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.Player friends = 1;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 1;
  inline const ::rpc::Player& friends(int index) const;
  inline ::rpc::Player* mutable_friends(int index);
  inline ::rpc::Player* add_friends();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Player >&
      friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Player >*
      mutable_friends();
  
  // @@protoc_insertion_point(class_scope:rpc.FriendsList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::Player > friends_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FriendsList* default_instance_;
};
// -------------------------------------------------------------------

class RequestFriendsList : public ::google::protobuf::Message {
 public:
  RequestFriendsList();
  virtual ~RequestFriendsList();
  
  RequestFriendsList(const RequestFriendsList& from);
  
  inline RequestFriendsList& operator=(const RequestFriendsList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFriendsList& default_instance();
  
  void Swap(RequestFriendsList* other);
  
  // implements Message ----------------------------------------------
  
  RequestFriendsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFriendsList& from);
  void MergeFrom(const RequestFriendsList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.Player friends = 1;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 1;
  inline const ::rpc::Player& friends(int index) const;
  inline ::rpc::Player* mutable_friends(int index);
  inline ::rpc::Player* add_friends();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Player >&
      friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Player >*
      mutable_friends();
  
  // @@protoc_insertion_point(class_scope:rpc.RequestFriendsList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::Player > friends_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static RequestFriendsList* default_instance_;
};
// -------------------------------------------------------------------

class ReqString : public ::google::protobuf::Message {
 public:
  ReqString();
  virtual ~ReqString();
  
  ReqString(const ReqString& from);
  
  inline ReqString& operator=(const ReqString& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqString& default_instance();
  
  void Swap(ReqString* other);
  
  // implements Message ----------------------------------------------
  
  ReqString* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqString& from);
  void MergeFrom(const ReqString& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // @@protoc_insertion_point(class_scope:rpc.ReqString)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ReqString* default_instance_;
};
// -------------------------------------------------------------------

class ReqInt : public ::google::protobuf::Message {
 public:
  ReqInt();
  virtual ~ReqInt();
  
  ReqInt(const ReqInt& from);
  
  inline ReqInt& operator=(const ReqInt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqInt& default_instance();
  
  void Swap(ReqInt* other);
  
  // implements Message ----------------------------------------------
  
  ReqInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqInt& from);
  void MergeFrom(const ReqInt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.ReqInt)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ReqInt* default_instance_;
};
// -------------------------------------------------------------------

class SearchFriendNofify : public ::google::protobuf::Message {
 public:
  SearchFriendNofify();
  virtual ~SearchFriendNofify();
  
  SearchFriendNofify(const SearchFriendNofify& from);
  
  inline SearchFriendNofify& operator=(const SearchFriendNofify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchFriendNofify& default_instance();
  
  void Swap(SearchFriendNofify* other);
  
  // implements Message ----------------------------------------------
  
  SearchFriendNofify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchFriendNofify& from);
  void MergeFrom(const SearchFriendNofify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .rpc.Player player = 1;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 1;
  inline const ::rpc::Player& player() const;
  inline ::rpc::Player* mutable_player();
  inline ::rpc::Player* release_player();
  
  // @@protoc_insertion_point(class_scope:rpc.SearchFriendNofify)
 private:
  inline void set_has_player();
  inline void clear_has_player();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::Player* player_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static SearchFriendNofify* default_instance_;
};
// -------------------------------------------------------------------

class ReqResponseAddFriend : public ::google::protobuf::Message {
 public:
  ReqResponseAddFriend();
  virtual ~ReqResponseAddFriend();
  
  ReqResponseAddFriend(const ReqResponseAddFriend& from);
  
  inline ReqResponseAddFriend& operator=(const ReqResponseAddFriend& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqResponseAddFriend& default_instance();
  
  void Swap(ReqResponseAddFriend* other);
  
  // implements Message ----------------------------------------------
  
  ReqResponseAddFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqResponseAddFriend& from);
  void MergeFrom(const ReqResponseAddFriend& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional bool bAccept = 2;
  inline bool has_baccept() const;
  inline void clear_baccept();
  static const int kBAcceptFieldNumber = 2;
  inline bool baccept() const;
  inline void set_baccept(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.ReqResponseAddFriend)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_baccept();
  inline void clear_has_baccept();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  bool baccept_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ReqResponseAddFriend* default_instance_;
};
// -------------------------------------------------------------------

class AddFriendNofify : public ::google::protobuf::Message {
 public:
  AddFriendNofify();
  virtual ~AddFriendNofify();
  
  AddFriendNofify(const AddFriendNofify& from);
  
  inline AddFriendNofify& operator=(const AddFriendNofify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddFriendNofify& default_instance();
  
  void Swap(AddFriendNofify* other);
  
  // implements Message ----------------------------------------------
  
  AddFriendNofify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddFriendNofify& from);
  void MergeFrom(const AddFriendNofify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rst = 1;
  inline bool has_rst() const;
  inline void clear_rst();
  static const int kRstFieldNumber = 1;
  inline ::google::protobuf::int32 rst() const;
  inline void set_rst(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.AddFriendNofify)
 private:
  inline void set_has_rst();
  inline void clear_has_rst();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 rst_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static AddFriendNofify* default_instance_;
};
// -------------------------------------------------------------------

class DelFriendNofity : public ::google::protobuf::Message {
 public:
  DelFriendNofity();
  virtual ~DelFriendNofity();
  
  DelFriendNofity(const DelFriendNofity& from);
  
  inline DelFriendNofity& operator=(const DelFriendNofity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DelFriendNofity& default_instance();
  
  void Swap(DelFriendNofity* other);
  
  // implements Message ----------------------------------------------
  
  DelFriendNofity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelFriendNofity& from);
  void MergeFrom(const DelFriendNofity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rst = 1;
  inline bool has_rst() const;
  inline void clear_rst();
  static const int kRstFieldNumber = 1;
  inline ::google::protobuf::int32 rst() const;
  inline void set_rst(::google::protobuf::int32 value);
  
  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // @@protoc_insertion_point(class_scope:rpc.DelFriendNofity)
 private:
  inline void set_has_rst();
  inline void clear_has_rst();
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::int32 rst_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static DelFriendNofity* default_instance_;
};
// -------------------------------------------------------------------

class FriendsIdList : public ::google::protobuf::Message {
 public:
  FriendsIdList();
  virtual ~FriendsIdList();
  
  FriendsIdList(const FriendsIdList& from);
  
  inline FriendsIdList& operator=(const FriendsIdList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendsIdList& default_instance();
  
  void Swap(FriendsIdList* other);
  
  // implements Message ----------------------------------------------
  
  FriendsIdList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FriendsIdList& from);
  void MergeFrom(const FriendsIdList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string friends = 1;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 1;
  inline const ::std::string& friends(int index) const;
  inline ::std::string* mutable_friends(int index);
  inline void set_friends(int index, const ::std::string& value);
  inline void set_friends(int index, const char* value);
  inline void set_friends(int index, const char* value, size_t size);
  inline ::std::string* add_friends();
  inline void add_friends(const ::std::string& value);
  inline void add_friends(const char* value);
  inline void add_friends(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_friends();
  
  // @@protoc_insertion_point(class_scope:rpc.FriendsIdList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> friends_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FriendsIdList* default_instance_;
};
// -------------------------------------------------------------------

class SendFriendChat : public ::google::protobuf::Message {
 public:
  SendFriendChat();
  virtual ~SendFriendChat();
  
  SendFriendChat(const SendFriendChat& from);
  
  inline SendFriendChat& operator=(const SendFriendChat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendFriendChat& default_instance();
  
  void Swap(SendFriendChat* other);
  
  // implements Message ----------------------------------------------
  
  SendFriendChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendFriendChat& from);
  void MergeFrom(const SendFriendChat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string senderUid = 1;
  inline bool has_senderuid() const;
  inline void clear_senderuid();
  static const int kSenderUidFieldNumber = 1;
  inline const ::std::string& senderuid() const;
  inline void set_senderuid(const ::std::string& value);
  inline void set_senderuid(const char* value);
  inline void set_senderuid(const char* value, size_t size);
  inline ::std::string* mutable_senderuid();
  inline ::std::string* release_senderuid();
  
  // required string receiverUid = 2;
  inline bool has_receiveruid() const;
  inline void clear_receiveruid();
  static const int kReceiverUidFieldNumber = 2;
  inline const ::std::string& receiveruid() const;
  inline void set_receiveruid(const ::std::string& value);
  inline void set_receiveruid(const char* value);
  inline void set_receiveruid(const char* value, size_t size);
  inline ::std::string* mutable_receiveruid();
  inline ::std::string* release_receiveruid();
  
  // required string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // optional int32 sendtime = 4;
  inline bool has_sendtime() const;
  inline void clear_sendtime();
  static const int kSendtimeFieldNumber = 4;
  inline ::google::protobuf::int32 sendtime() const;
  inline void set_sendtime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.SendFriendChat)
 private:
  inline void set_has_senderuid();
  inline void clear_has_senderuid();
  inline void set_has_receiveruid();
  inline void clear_has_receiveruid();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_sendtime();
  inline void clear_has_sendtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* senderuid_;
  ::std::string* receiveruid_;
  ::std::string* text_;
  ::google::protobuf::int32 sendtime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static SendFriendChat* default_instance_;
};
// -------------------------------------------------------------------

class OfflineMsgNofity : public ::google::protobuf::Message {
 public:
  OfflineMsgNofity();
  virtual ~OfflineMsgNofity();
  
  OfflineMsgNofity(const OfflineMsgNofity& from);
  
  inline OfflineMsgNofity& operator=(const OfflineMsgNofity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineMsgNofity& default_instance();
  
  void Swap(OfflineMsgNofity* other);
  
  // implements Message ----------------------------------------------
  
  OfflineMsgNofity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfflineMsgNofity& from);
  void MergeFrom(const OfflineMsgNofity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.SendFriendChat chatInfo = 1;
  inline int chatinfo_size() const;
  inline void clear_chatinfo();
  static const int kChatInfoFieldNumber = 1;
  inline const ::rpc::SendFriendChat& chatinfo(int index) const;
  inline ::rpc::SendFriendChat* mutable_chatinfo(int index);
  inline ::rpc::SendFriendChat* add_chatinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::SendFriendChat >&
      chatinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::SendFriendChat >*
      mutable_chatinfo();
  
  // @@protoc_insertion_point(class_scope:rpc.OfflineMsgNofity)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::SendFriendChat > chatinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static OfflineMsgNofity* default_instance_;
};
// -------------------------------------------------------------------

class FriendStatusNofify : public ::google::protobuf::Message {
 public:
  FriendStatusNofify();
  virtual ~FriendStatusNofify();
  
  FriendStatusNofify(const FriendStatusNofify& from);
  
  inline FriendStatusNofify& operator=(const FriendStatusNofify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendStatusNofify& default_instance();
  
  void Swap(FriendStatusNofify* other);
  
  // implements Message ----------------------------------------------
  
  FriendStatusNofify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FriendStatusNofify& from);
  void MergeFrom(const FriendStatusNofify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // required bool bOnline = 2;
  inline bool has_bonline() const;
  inline void clear_bonline();
  static const int kBOnlineFieldNumber = 2;
  inline bool bonline() const;
  inline void set_bonline(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.FriendStatusNofify)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_bonline();
  inline void clear_has_bonline();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  bool bonline_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FriendStatusNofify* default_instance_;
};
// -------------------------------------------------------------------

class ErrorCodeNofify : public ::google::protobuf::Message {
 public:
  ErrorCodeNofify();
  virtual ~ErrorCodeNofify();
  
  ErrorCodeNofify(const ErrorCodeNofify& from);
  
  inline ErrorCodeNofify& operator=(const ErrorCodeNofify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorCodeNofify& default_instance();
  
  void Swap(ErrorCodeNofify* other);
  
  // implements Message ----------------------------------------------
  
  ErrorCodeNofify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrorCodeNofify& from);
  void MergeFrom(const ErrorCodeNofify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.ErrorCodeNofify)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ErrorCodeNofify* default_instance_;
};
// -------------------------------------------------------------------

class TaskFinishNofity : public ::google::protobuf::Message {
 public:
  TaskFinishNofity();
  virtual ~TaskFinishNofity();
  
  TaskFinishNofity(const TaskFinishNofity& from);
  
  inline TaskFinishNofity& operator=(const TaskFinishNofity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskFinishNofity& default_instance();
  
  void Swap(TaskFinishNofity* other);
  
  // implements Message ----------------------------------------------
  
  TaskFinishNofity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskFinishNofity& from);
  void MergeFrom(const TaskFinishNofity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string taskId = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskIdFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  
  // @@protoc_insertion_point(class_scope:rpc.TaskFinishNofity)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* taskid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static TaskFinishNofity* default_instance_;
};
// -------------------------------------------------------------------

class ReqTaskShare : public ::google::protobuf::Message {
 public:
  ReqTaskShare();
  virtual ~ReqTaskShare();
  
  ReqTaskShare(const ReqTaskShare& from);
  
  inline ReqTaskShare& operator=(const ReqTaskShare& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqTaskShare& default_instance();
  
  void Swap(ReqTaskShare* other);
  
  // implements Message ----------------------------------------------
  
  ReqTaskShare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqTaskShare& from);
  void MergeFrom(const ReqTaskShare& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool bShare2Friend = 1;
  inline bool has_bshare2friend() const;
  inline void clear_bshare2friend();
  static const int kBShare2FriendFieldNumber = 1;
  inline bool bshare2friend() const;
  inline void set_bshare2friend(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.ReqTaskShare)
 private:
  inline void set_has_bshare2friend();
  inline void clear_has_bshare2friend();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool bshare2friend_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ReqTaskShare* default_instance_;
};
// -------------------------------------------------------------------

class ReqRankList : public ::google::protobuf::Message {
 public:
  ReqRankList();
  virtual ~ReqRankList();
  
  ReqRankList(const ReqRankList& from);
  
  inline ReqRankList& operator=(const ReqRankList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqRankList& default_instance();
  
  void Swap(ReqRankList* other);
  
  // implements Message ----------------------------------------------
  
  ReqRankList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqRankList& from);
  void MergeFrom(const ReqRankList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rankType = 1;
  inline bool has_ranktype() const;
  inline void clear_ranktype();
  static const int kRankTypeFieldNumber = 1;
  inline ::google::protobuf::int32 ranktype() const;
  inline void set_ranktype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.ReqRankList)
 private:
  inline void set_has_ranktype();
  inline void clear_has_ranktype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 ranktype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ReqRankList* default_instance_;
};
// -------------------------------------------------------------------

class RankInfo : public ::google::protobuf::Message {
 public:
  RankInfo();
  virtual ~RankInfo();
  
  RankInfo(const RankInfo& from);
  
  inline RankInfo& operator=(const RankInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RankInfo& default_instance();
  
  void Swap(RankInfo* other);
  
  // implements Message ----------------------------------------------
  
  RankInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RankInfo& from);
  void MergeFrom(const RankInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // required int32 roleId = 2;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 2;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);
  
  // required int32 sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required int32 exp = 6;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 6;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);
  
  // required bool bVip = 7;
  inline bool has_bvip() const;
  inline void clear_bvip();
  static const int kBVipFieldNumber = 7;
  inline bool bvip() const;
  inline void set_bvip(bool value);
  
  // required int32 coin = 8;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 8;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // required int32 gem = 9;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 9;
  inline ::google::protobuf::int32 gem() const;
  inline void set_gem(::google::protobuf::int32 value);
  
  // required string headerUrl = 10;
  inline bool has_headerurl() const;
  inline void clear_headerurl();
  static const int kHeaderUrlFieldNumber = 10;
  inline const ::std::string& headerurl() const;
  inline void set_headerurl(const ::std::string& value);
  inline void set_headerurl(const char* value);
  inline void set_headerurl(const char* value, size_t size);
  inline ::std::string* mutable_headerurl();
  inline ::std::string* release_headerurl();
  
  // required int64 rankValue = 11;
  inline bool has_rankvalue() const;
  inline void clear_rankvalue();
  static const int kRankValueFieldNumber = 11;
  inline ::google::protobuf::int64 rankvalue() const;
  inline void set_rankvalue(::google::protobuf::int64 value);
  
  // optional int32 rankNum = 12;
  inline bool has_ranknum() const;
  inline void clear_ranknum();
  static const int kRankNumFieldNumber = 12;
  inline ::google::protobuf::int32 ranknum() const;
  inline void set_ranknum(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.RankInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_bvip();
  inline void clear_has_bvip();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_gem();
  inline void clear_has_gem();
  inline void set_has_headerurl();
  inline void clear_has_headerurl();
  inline void set_has_rankvalue();
  inline void clear_has_rankvalue();
  inline void set_has_ranknum();
  inline void clear_has_ranknum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 sex_;
  ::std::string* name_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 exp_;
  bool bvip_;
  ::google::protobuf::int32 coin_;
  ::std::string* headerurl_;
  ::google::protobuf::int32 gem_;
  ::google::protobuf::int32 ranknum_;
  ::google::protobuf::int64 rankvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static RankInfo* default_instance_;
};
// -------------------------------------------------------------------

class RankList : public ::google::protobuf::Message {
 public:
  RankList();
  virtual ~RankList();
  
  RankList(const RankList& from);
  
  inline RankList& operator=(const RankList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RankList& default_instance();
  
  void Swap(RankList* other);
  
  // implements Message ----------------------------------------------
  
  RankList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RankList& from);
  void MergeFrom(const RankList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.RankInfo rankList = 1;
  inline int ranklist_size() const;
  inline void clear_ranklist();
  static const int kRankListFieldNumber = 1;
  inline const ::rpc::RankInfo& ranklist(int index) const;
  inline ::rpc::RankInfo* mutable_ranklist(int index);
  inline ::rpc::RankInfo* add_ranklist();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::RankInfo >&
      ranklist() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::RankInfo >*
      mutable_ranklist();
  
  // required int32 rankType = 2;
  inline bool has_ranktype() const;
  inline void clear_ranktype();
  static const int kRankTypeFieldNumber = 2;
  inline ::google::protobuf::int32 ranktype() const;
  inline void set_ranktype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.RankList)
 private:
  inline void set_has_ranktype();
  inline void clear_has_ranktype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::RankInfo > ranklist_;
  ::google::protobuf::int32 ranktype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static RankList* default_instance_;
};
// -------------------------------------------------------------------

class FormatedMsg : public ::google::protobuf::Message {
 public:
  FormatedMsg();
  virtual ~FormatedMsg();
  
  FormatedMsg(const FormatedMsg& from);
  
  inline FormatedMsg& operator=(const FormatedMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FormatedMsg& default_instance();
  
  void Swap(FormatedMsg* other);
  
  // implements Message ----------------------------------------------
  
  FormatedMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormatedMsg& from);
  void MergeFrom(const FormatedMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  
  // repeated .rpc.MsgArg args = 2;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::rpc::MsgArg& args(int index) const;
  inline ::rpc::MsgArg* mutable_args(int index);
  inline ::rpc::MsgArg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MsgArg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MsgArg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:rpc.FormatedMsg)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* code_;
  ::google::protobuf::RepeatedPtrField< ::rpc::MsgArg > args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FormatedMsg* default_instance_;
};
// -------------------------------------------------------------------

class Msg : public ::google::protobuf::Message {
 public:
  Msg();
  virtual ~Msg();
  
  Msg(const Msg& from);
  
  inline Msg& operator=(const Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg& default_instance();
  
  void Swap(Msg* other);
  
  // implements Message ----------------------------------------------
  
  Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg& from);
  void MergeFrom(const Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  
  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // @@protoc_insertion_point(class_scope:rpc.Msg)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_text();
  inline void clear_has_text();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* code_;
  ::std::string* text_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Msg* default_instance_;
};
// -------------------------------------------------------------------

class NumberMsg : public ::google::protobuf::Message {
 public:
  NumberMsg();
  virtual ~NumberMsg();
  
  NumberMsg(const NumberMsg& from);
  
  inline NumberMsg& operator=(const NumberMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NumberMsg& default_instance();
  
  void Swap(NumberMsg* other);
  
  // implements Message ----------------------------------------------
  
  NumberMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NumberMsg& from);
  void MergeFrom(const NumberMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.NumberMsg)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static NumberMsg* default_instance_;
};
// -------------------------------------------------------------------

class MsgArg : public ::google::protobuf::Message {
 public:
  MsgArg();
  virtual ~MsgArg();
  
  MsgArg(const MsgArg& from);
  
  inline MsgArg& operator=(const MsgArg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgArg& default_instance();
  
  void Swap(MsgArg* other);
  
  // implements Message ----------------------------------------------
  
  MsgArg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgArg& from);
  void MergeFrom(const MsgArg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string s = 1;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 1;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  
  // optional int32 i = 2;
  inline bool has_i() const;
  inline void clear_i();
  static const int kIFieldNumber = 2;
  inline ::google::protobuf::int32 i() const;
  inline void set_i(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MsgArg)
 private:
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_i();
  inline void clear_has_i();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* s_;
  ::google::protobuf::int32 i_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MsgArg* default_instance_;
};
// -------------------------------------------------------------------

class GuestBindOk : public ::google::protobuf::Message {
 public:
  GuestBindOk();
  virtual ~GuestBindOk();
  
  GuestBindOk(const GuestBindOk& from);
  
  inline GuestBindOk& operator=(const GuestBindOk& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuestBindOk& default_instance();
  
  void Swap(GuestBindOk* other);
  
  // implements Message ----------------------------------------------
  
  GuestBindOk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuestBindOk& from);
  void MergeFrom(const GuestBindOk& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.GuestBindOk)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static GuestBindOk* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();
  
  Ping(const Ping& from);
  
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();
  
  void Swap(Ping* other);
  
  // implements Message ----------------------------------------------
  
  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 ClientTime = 1;
  inline bool has_clienttime() const;
  inline void clear_clienttime();
  static const int kClientTimeFieldNumber = 1;
  inline ::google::protobuf::int64 clienttime() const;
  inline void set_clienttime(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:rpc.Ping)
 private:
  inline void set_has_clienttime();
  inline void clear_has_clienttime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 clienttime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class PingResult : public ::google::protobuf::Message {
 public:
  PingResult();
  virtual ~PingResult();
  
  PingResult(const PingResult& from);
  
  inline PingResult& operator=(const PingResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PingResult& default_instance();
  
  void Swap(PingResult* other);
  
  // implements Message ----------------------------------------------
  
  PingResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingResult& from);
  void MergeFrom(const PingResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 server_time = 1;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 1;
  inline ::google::protobuf::int32 server_time() const;
  inline void set_server_time(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.PingResult)
 private:
  inline void set_has_server_time();
  inline void clear_has_server_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 server_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PingResult* default_instance_;
};
// -------------------------------------------------------------------

class KickPlayerMsg : public ::google::protobuf::Message {
 public:
  KickPlayerMsg();
  virtual ~KickPlayerMsg();
  
  KickPlayerMsg(const KickPlayerMsg& from);
  
  inline KickPlayerMsg& operator=(const KickPlayerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KickPlayerMsg& default_instance();
  
  void Swap(KickPlayerMsg* other);
  
  // implements Message ----------------------------------------------
  
  KickPlayerMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KickPlayerMsg& from);
  void MergeFrom(const KickPlayerMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.KickPlayerMsg)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static KickPlayerMsg* default_instance_;
};
// -------------------------------------------------------------------

class C2SChatP2P : public ::google::protobuf::Message {
 public:
  C2SChatP2P();
  virtual ~C2SChatP2P();
  
  C2SChatP2P(const C2SChatP2P& from);
  
  inline C2SChatP2P& operator=(const C2SChatP2P& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2SChatP2P& default_instance();
  
  void Swap(C2SChatP2P* other);
  
  // implements Message ----------------------------------------------
  
  C2SChatP2P* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2SChatP2P& from);
  void MergeFrom(const C2SChatP2P& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ToPlayerId = 1;
  inline bool has_toplayerid() const;
  inline void clear_toplayerid();
  static const int kToPlayerIdFieldNumber = 1;
  inline const ::std::string& toplayerid() const;
  inline void set_toplayerid(const ::std::string& value);
  inline void set_toplayerid(const char* value);
  inline void set_toplayerid(const char* value, size_t size);
  inline ::std::string* mutable_toplayerid();
  inline ::std::string* release_toplayerid();
  
  // required string ChatContent = 2;
  inline bool has_chatcontent() const;
  inline void clear_chatcontent();
  static const int kChatContentFieldNumber = 2;
  inline const ::std::string& chatcontent() const;
  inline void set_chatcontent(const ::std::string& value);
  inline void set_chatcontent(const char* value);
  inline void set_chatcontent(const char* value, size_t size);
  inline ::std::string* mutable_chatcontent();
  inline ::std::string* release_chatcontent();
  
  // @@protoc_insertion_point(class_scope:rpc.C2SChatP2P)
 private:
  inline void set_has_toplayerid();
  inline void clear_has_toplayerid();
  inline void set_has_chatcontent();
  inline void clear_has_chatcontent();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* toplayerid_;
  ::std::string* chatcontent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static C2SChatP2P* default_instance_;
};
// -------------------------------------------------------------------

class C2SChatAlliance : public ::google::protobuf::Message {
 public:
  C2SChatAlliance();
  virtual ~C2SChatAlliance();
  
  C2SChatAlliance(const C2SChatAlliance& from);
  
  inline C2SChatAlliance& operator=(const C2SChatAlliance& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2SChatAlliance& default_instance();
  
  void Swap(C2SChatAlliance* other);
  
  // implements Message ----------------------------------------------
  
  C2SChatAlliance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2SChatAlliance& from);
  void MergeFrom(const C2SChatAlliance& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ChatContent = 1;
  inline bool has_chatcontent() const;
  inline void clear_chatcontent();
  static const int kChatContentFieldNumber = 1;
  inline const ::std::string& chatcontent() const;
  inline void set_chatcontent(const ::std::string& value);
  inline void set_chatcontent(const char* value);
  inline void set_chatcontent(const char* value, size_t size);
  inline ::std::string* mutable_chatcontent();
  inline ::std::string* release_chatcontent();
  
  // optional bool useIM = 2;
  inline bool has_useim() const;
  inline void clear_useim();
  static const int kUseIMFieldNumber = 2;
  inline bool useim() const;
  inline void set_useim(bool value);
  
  // optional string voiceTime = 3;
  inline bool has_voicetime() const;
  inline void clear_voicetime();
  static const int kVoiceTimeFieldNumber = 3;
  inline const ::std::string& voicetime() const;
  inline void set_voicetime(const ::std::string& value);
  inline void set_voicetime(const char* value);
  inline void set_voicetime(const char* value, size_t size);
  inline ::std::string* mutable_voicetime();
  inline ::std::string* release_voicetime();
  
  // @@protoc_insertion_point(class_scope:rpc.C2SChatAlliance)
 private:
  inline void set_has_chatcontent();
  inline void clear_has_chatcontent();
  inline void set_has_useim();
  inline void clear_has_useim();
  inline void set_has_voicetime();
  inline void clear_has_voicetime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* chatcontent_;
  ::std::string* voicetime_;
  bool useim_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static C2SChatAlliance* default_instance_;
};
// -------------------------------------------------------------------

class C2SChatWorld : public ::google::protobuf::Message {
 public:
  C2SChatWorld();
  virtual ~C2SChatWorld();
  
  C2SChatWorld(const C2SChatWorld& from);
  
  inline C2SChatWorld& operator=(const C2SChatWorld& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2SChatWorld& default_instance();
  
  void Swap(C2SChatWorld* other);
  
  // implements Message ----------------------------------------------
  
  C2SChatWorld* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2SChatWorld& from);
  void MergeFrom(const C2SChatWorld& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ChatContent = 1;
  inline bool has_chatcontent() const;
  inline void clear_chatcontent();
  static const int kChatContentFieldNumber = 1;
  inline const ::std::string& chatcontent() const;
  inline void set_chatcontent(const ::std::string& value);
  inline void set_chatcontent(const char* value);
  inline void set_chatcontent(const char* value, size_t size);
  inline ::std::string* mutable_chatcontent();
  inline ::std::string* release_chatcontent();
  
  // optional bool useIM = 2;
  inline bool has_useim() const;
  inline void clear_useim();
  static const int kUseIMFieldNumber = 2;
  inline bool useim() const;
  inline void set_useim(bool value);
  
  // optional string voiceTime = 3;
  inline bool has_voicetime() const;
  inline void clear_voicetime();
  static const int kVoiceTimeFieldNumber = 3;
  inline const ::std::string& voicetime() const;
  inline void set_voicetime(const ::std::string& value);
  inline void set_voicetime(const char* value);
  inline void set_voicetime(const char* value, size_t size);
  inline ::std::string* mutable_voicetime();
  inline ::std::string* release_voicetime();
  
  // @@protoc_insertion_point(class_scope:rpc.C2SChatWorld)
 private:
  inline void set_has_chatcontent();
  inline void clear_has_chatcontent();
  inline void set_has_useim();
  inline void clear_has_useim();
  inline void set_has_voicetime();
  inline void clear_has_voicetime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* chatcontent_;
  ::std::string* voicetime_;
  bool useim_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static C2SChatWorld* default_instance_;
};
// -------------------------------------------------------------------

class S2CChatP2P : public ::google::protobuf::Message {
 public:
  S2CChatP2P();
  virtual ~S2CChatP2P();
  
  S2CChatP2P(const S2CChatP2P& from);
  
  inline S2CChatP2P& operator=(const S2CChatP2P& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2CChatP2P& default_instance();
  
  void Swap(S2CChatP2P* other);
  
  // implements Message ----------------------------------------------
  
  S2CChatP2P* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2CChatP2P& from);
  void MergeFrom(const S2CChatP2P& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string FromPlayerId = 1;
  inline bool has_fromplayerid() const;
  inline void clear_fromplayerid();
  static const int kFromPlayerIdFieldNumber = 1;
  inline const ::std::string& fromplayerid() const;
  inline void set_fromplayerid(const ::std::string& value);
  inline void set_fromplayerid(const char* value);
  inline void set_fromplayerid(const char* value, size_t size);
  inline ::std::string* mutable_fromplayerid();
  inline ::std::string* release_fromplayerid();
  
  // required string FromPlayerName = 2;
  inline bool has_fromplayername() const;
  inline void clear_fromplayername();
  static const int kFromPlayerNameFieldNumber = 2;
  inline const ::std::string& fromplayername() const;
  inline void set_fromplayername(const ::std::string& value);
  inline void set_fromplayername(const char* value);
  inline void set_fromplayername(const char* value, size_t size);
  inline ::std::string* mutable_fromplayername();
  inline ::std::string* release_fromplayername();
  
  // required int32 FromPlayerLevel = 3;
  inline bool has_fromplayerlevel() const;
  inline void clear_fromplayerlevel();
  static const int kFromPlayerLevelFieldNumber = 3;
  inline ::google::protobuf::int32 fromplayerlevel() const;
  inline void set_fromplayerlevel(::google::protobuf::int32 value);
  
  // required string ChatContent = 4;
  inline bool has_chatcontent() const;
  inline void clear_chatcontent();
  static const int kChatContentFieldNumber = 4;
  inline const ::std::string& chatcontent() const;
  inline void set_chatcontent(const ::std::string& value);
  inline void set_chatcontent(const char* value);
  inline void set_chatcontent(const char* value, size_t size);
  inline ::std::string* mutable_chatcontent();
  inline ::std::string* release_chatcontent();
  
  // @@protoc_insertion_point(class_scope:rpc.S2CChatP2P)
 private:
  inline void set_has_fromplayerid();
  inline void clear_has_fromplayerid();
  inline void set_has_fromplayername();
  inline void clear_has_fromplayername();
  inline void set_has_fromplayerlevel();
  inline void clear_has_fromplayerlevel();
  inline void set_has_chatcontent();
  inline void clear_has_chatcontent();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* fromplayerid_;
  ::std::string* fromplayername_;
  ::std::string* chatcontent_;
  ::google::protobuf::int32 fromplayerlevel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static S2CChatP2P* default_instance_;
};
// -------------------------------------------------------------------

class S2CChatWorld : public ::google::protobuf::Message {
 public:
  S2CChatWorld();
  virtual ~S2CChatWorld();
  
  S2CChatWorld(const S2CChatWorld& from);
  
  inline S2CChatWorld& operator=(const S2CChatWorld& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2CChatWorld& default_instance();
  
  void Swap(S2CChatWorld* other);
  
  // implements Message ----------------------------------------------
  
  S2CChatWorld* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2CChatWorld& from);
  void MergeFrom(const S2CChatWorld& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string FromPlayerId = 1;
  inline bool has_fromplayerid() const;
  inline void clear_fromplayerid();
  static const int kFromPlayerIdFieldNumber = 1;
  inline const ::std::string& fromplayerid() const;
  inline void set_fromplayerid(const ::std::string& value);
  inline void set_fromplayerid(const char* value);
  inline void set_fromplayerid(const char* value, size_t size);
  inline ::std::string* mutable_fromplayerid();
  inline ::std::string* release_fromplayerid();
  
  // required string FromPlayerName = 2;
  inline bool has_fromplayername() const;
  inline void clear_fromplayername();
  static const int kFromPlayerNameFieldNumber = 2;
  inline const ::std::string& fromplayername() const;
  inline void set_fromplayername(const ::std::string& value);
  inline void set_fromplayername(const char* value);
  inline void set_fromplayername(const char* value, size_t size);
  inline ::std::string* mutable_fromplayername();
  inline ::std::string* release_fromplayername();
  
  // required int32 FromPlayerLevel = 3;
  inline bool has_fromplayerlevel() const;
  inline void clear_fromplayerlevel();
  static const int kFromPlayerLevelFieldNumber = 3;
  inline ::google::protobuf::int32 fromplayerlevel() const;
  inline void set_fromplayerlevel(::google::protobuf::int32 value);
  
  // required int64 ChatTime = 6;
  inline bool has_chattime() const;
  inline void clear_chattime();
  static const int kChatTimeFieldNumber = 6;
  inline ::google::protobuf::int64 chattime() const;
  inline void set_chattime(::google::protobuf::int64 value);
  
  // required string ChatContent = 7;
  inline bool has_chatcontent() const;
  inline void clear_chatcontent();
  static const int kChatContentFieldNumber = 7;
  inline const ::std::string& chatcontent() const;
  inline void set_chatcontent(const ::std::string& value);
  inline void set_chatcontent(const char* value);
  inline void set_chatcontent(const char* value, size_t size);
  inline ::std::string* mutable_chatcontent();
  inline ::std::string* release_chatcontent();
  
  // optional bool useIM = 10;
  inline bool has_useim() const;
  inline void clear_useim();
  static const int kUseIMFieldNumber = 10;
  inline bool useim() const;
  inline void set_useim(bool value);
  
  // optional string voiceTime = 11;
  inline bool has_voicetime() const;
  inline void clear_voicetime();
  static const int kVoiceTimeFieldNumber = 11;
  inline const ::std::string& voicetime() const;
  inline void set_voicetime(const ::std::string& value);
  inline void set_voicetime(const char* value);
  inline void set_voicetime(const char* value, size_t size);
  inline ::std::string* mutable_voicetime();
  inline ::std::string* release_voicetime();
  
  // optional int32 messageId = 12;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 12;
  inline ::google::protobuf::int32 messageid() const;
  inline void set_messageid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.S2CChatWorld)
 private:
  inline void set_has_fromplayerid();
  inline void clear_has_fromplayerid();
  inline void set_has_fromplayername();
  inline void clear_has_fromplayername();
  inline void set_has_fromplayerlevel();
  inline void clear_has_fromplayerlevel();
  inline void set_has_chattime();
  inline void clear_has_chattime();
  inline void set_has_chatcontent();
  inline void clear_has_chatcontent();
  inline void set_has_useim();
  inline void clear_has_useim();
  inline void set_has_voicetime();
  inline void clear_has_voicetime();
  inline void set_has_messageid();
  inline void clear_has_messageid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* fromplayerid_;
  ::std::string* fromplayername_;
  ::google::protobuf::int64 chattime_;
  ::google::protobuf::int32 fromplayerlevel_;
  bool useim_;
  ::std::string* chatcontent_;
  ::std::string* voicetime_;
  ::google::protobuf::int32 messageid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static S2CChatWorld* default_instance_;
};
// -------------------------------------------------------------------

class Card : public ::google::protobuf::Message {
 public:
  Card();
  virtual ~Card();
  
  Card(const Card& from);
  
  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Card& default_instance();
  
  void Swap(Card* other);
  
  // implements Message ----------------------------------------------
  
  Card* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Card& from);
  void MergeFrom(const Card& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // required bool bBig = 2;
  inline bool has_bbig() const;
  inline void clear_bbig();
  static const int kBBigFieldNumber = 2;
  inline bool bbig() const;
  inline void set_bbig(bool value);
  
  // required bool bLock = 3;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBLockFieldNumber = 3;
  inline bool block() const;
  inline void set_block(bool value);
  
  // optional bool bChi = 4;
  inline bool has_bchi() const;
  inline void clear_bchi();
  static const int kBChiFieldNumber = 4;
  inline bool bchi() const;
  inline void set_bchi(bool value);
  
  // optional bool bHu = 5;
  inline bool has_bhu() const;
  inline void clear_bhu();
  static const int kBHuFieldNumber = 5;
  inline bool bhu() const;
  inline void set_bhu(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.Card)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_bbig();
  inline void clear_has_bbig();
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_bchi();
  inline void clear_has_bchi();
  inline void set_has_bhu();
  inline void clear_has_bhu();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 value_;
  bool bbig_;
  bool block_;
  bool bchi_;
  bool bhu_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Card* default_instance_;
};
// -------------------------------------------------------------------

class Pattern : public ::google::protobuf::Message {
 public:
  Pattern();
  virtual ~Pattern();
  
  Pattern(const Pattern& from);
  
  inline Pattern& operator=(const Pattern& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pattern& default_instance();
  
  void Swap(Pattern* other);
  
  // implements Message ----------------------------------------------
  
  Pattern* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pattern& from);
  void MergeFrom(const Pattern& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 ptype = 1;
  inline bool has_ptype() const;
  inline void clear_ptype();
  static const int kPtypeFieldNumber = 1;
  inline ::google::protobuf::int32 ptype() const;
  inline void set_ptype(::google::protobuf::int32 value);
  
  // repeated .rpc.Card cards = 2;
  inline int cards_size() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 2;
  inline const ::rpc::Card& cards(int index) const;
  inline ::rpc::Card* mutable_cards(int index);
  inline ::rpc::Card* add_cards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
      cards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
      mutable_cards();
  
  // optional int32 hu = 3;
  inline bool has_hu() const;
  inline void clear_hu();
  static const int kHuFieldNumber = 3;
  inline ::google::protobuf::int32 hu() const;
  inline void set_hu(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.Pattern)
 private:
  inline void set_has_ptype();
  inline void clear_has_ptype();
  inline void set_has_hu();
  inline void clear_has_hu();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::Card > cards_;
  ::google::protobuf::int32 ptype_;
  ::google::protobuf::int32 hu_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Pattern* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();
  
  UserInfo(const UserInfo& from);
  
  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();
  
  void Swap(UserInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playeID = 1;
  inline bool has_playeid() const;
  inline void clear_playeid();
  static const int kPlayeIDFieldNumber = 1;
  inline const ::std::string& playeid() const;
  inline void set_playeid(const ::std::string& value);
  inline void set_playeid(const char* value);
  inline void set_playeid(const char* value, size_t size);
  inline ::std::string* mutable_playeid();
  inline ::std::string* release_playeid();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 coins = 3;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 3;
  inline ::google::protobuf::int32 coins() const;
  inline void set_coins(::google::protobuf::int32 value);
  
  // optional bool bVip = 4;
  inline bool has_bvip() const;
  inline void clear_bvip();
  static const int kBVipFieldNumber = 4;
  inline bool bvip() const;
  inline void set_bvip(bool value);
  
  // required string head = 5;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 5;
  inline const ::std::string& head() const;
  inline void set_head(const ::std::string& value);
  inline void set_head(const char* value);
  inline void set_head(const char* value, size_t size);
  inline ::std::string* mutable_head();
  inline ::std::string* release_head();
  
  // required int32 sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.UserInfo)
 private:
  inline void set_has_playeid();
  inline void clear_has_playeid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_bvip();
  inline void clear_has_bvip();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_sex();
  inline void clear_has_sex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playeid_;
  ::std::string* name_;
  ::google::protobuf::int32 coins_;
  bool bvip_;
  ::std::string* head_;
  ::google::protobuf::int32 sex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomREQ : public ::google::protobuf::Message {
 public:
  EnterRoomREQ();
  virtual ~EnterRoomREQ();
  
  EnterRoomREQ(const EnterRoomREQ& from);
  
  inline EnterRoomREQ& operator=(const EnterRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomREQ& default_instance();
  
  void Swap(EnterRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  EnterRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomREQ& from);
  void MergeFrom(const EnterRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string gameType = 1;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 1;
  inline const ::std::string& gametype() const;
  inline void set_gametype(const ::std::string& value);
  inline void set_gametype(const char* value);
  inline void set_gametype(const char* value, size_t size);
  inline ::std::string* mutable_gametype();
  inline ::std::string* release_gametype();
  
  // required int32 roomType = 2;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 2;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.EnterRoomREQ)
 private:
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* gametype_;
  ::google::protobuf::int32 roomtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static EnterRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class QuickEnterRoomREQ : public ::google::protobuf::Message {
 public:
  QuickEnterRoomREQ();
  virtual ~QuickEnterRoomREQ();
  
  QuickEnterRoomREQ(const QuickEnterRoomREQ& from);
  
  inline QuickEnterRoomREQ& operator=(const QuickEnterRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuickEnterRoomREQ& default_instance();
  
  void Swap(QuickEnterRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  QuickEnterRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuickEnterRoomREQ& from);
  void MergeFrom(const QuickEnterRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:rpc.QuickEnterRoomREQ)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static QuickEnterRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomACK : public ::google::protobuf::Message {
 public:
  EnterRoomACK();
  virtual ~EnterRoomACK();
  
  EnterRoomACK(const EnterRoomACK& from);
  
  inline EnterRoomACK& operator=(const EnterRoomACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomACK& default_instance();
  
  void Swap(EnterRoomACK* other);
  
  // implements Message ----------------------------------------------
  
  EnterRoomACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomACK& from);
  void MergeFrom(const EnterRoomACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .rpc.PlayerBaseInfo playerInfo = 1;
  inline bool has_playerinfo() const;
  inline void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 1;
  inline const ::rpc::PlayerBaseInfo& playerinfo() const;
  inline ::rpc::PlayerBaseInfo* mutable_playerinfo();
  inline ::rpc::PlayerBaseInfo* release_playerinfo();
  
  // optional int32 shangjiaType = 2;
  inline bool has_shangjiatype() const;
  inline void clear_shangjiatype();
  static const int kShangjiaTypeFieldNumber = 2;
  inline ::google::protobuf::int32 shangjiatype() const;
  inline void set_shangjiatype(::google::protobuf::int32 value);
  
  // optional bool bReady = 3;
  inline bool has_bready() const;
  inline void clear_bready();
  static const int kBReadyFieldNumber = 3;
  inline bool bready() const;
  inline void set_bready(bool value);
  
  // optional int32 code = 4;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 4;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // optional int32 roomId = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 5;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // optional bool isNormalReqEnterRoom = 6;
  inline bool has_isnormalreqenterroom() const;
  inline void clear_isnormalreqenterroom();
  static const int kIsNormalReqEnterRoomFieldNumber = 6;
  inline bool isnormalreqenterroom() const;
  inline void set_isnormalreqenterroom(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.EnterRoomACK)
 private:
  inline void set_has_playerinfo();
  inline void clear_has_playerinfo();
  inline void set_has_shangjiatype();
  inline void clear_has_shangjiatype();
  inline void set_has_bready();
  inline void clear_has_bready();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_isnormalreqenterroom();
  inline void clear_has_isnormalreqenterroom();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::PlayerBaseInfo* playerinfo_;
  ::google::protobuf::int32 shangjiatype_;
  ::google::protobuf::int32 code_;
  bool bready_;
  bool isnormalreqenterroom_;
  ::google::protobuf::int32 roomid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static EnterRoomACK* default_instance_;
};
// -------------------------------------------------------------------

class LeaveRoomREQ : public ::google::protobuf::Message {
 public:
  LeaveRoomREQ();
  virtual ~LeaveRoomREQ();
  
  LeaveRoomREQ(const LeaveRoomREQ& from);
  
  inline LeaveRoomREQ& operator=(const LeaveRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveRoomREQ& default_instance();
  
  void Swap(LeaveRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  LeaveRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveRoomREQ& from);
  void MergeFrom(const LeaveRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // required bool isChangeDesk = 2;
  inline bool has_ischangedesk() const;
  inline void clear_ischangedesk();
  static const int kIsChangeDeskFieldNumber = 2;
  inline bool ischangedesk() const;
  inline void set_ischangedesk(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.LeaveRoomREQ)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_ischangedesk();
  inline void clear_has_ischangedesk();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  bool ischangedesk_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static LeaveRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class LeaveRoomACK : public ::google::protobuf::Message {
 public:
  LeaveRoomACK();
  virtual ~LeaveRoomACK();
  
  LeaveRoomACK(const LeaveRoomACK& from);
  
  inline LeaveRoomACK& operator=(const LeaveRoomACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveRoomACK& default_instance();
  
  void Swap(LeaveRoomACK* other);
  
  // implements Message ----------------------------------------------
  
  LeaveRoomACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveRoomACK& from);
  void MergeFrom(const LeaveRoomACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // required bool isChangeDesk = 2;
  inline bool has_ischangedesk() const;
  inline void clear_ischangedesk();
  static const int kIsChangeDeskFieldNumber = 2;
  inline bool ischangedesk() const;
  inline void set_ischangedesk(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.LeaveRoomACK)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_ischangedesk();
  inline void clear_has_ischangedesk();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  bool ischangedesk_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static LeaveRoomACK* default_instance_;
};
// -------------------------------------------------------------------

class CountDown : public ::google::protobuf::Message {
 public:
  CountDown();
  virtual ~CountDown();
  
  CountDown(const CountDown& from);
  
  inline CountDown& operator=(const CountDown& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CountDown& default_instance();
  
  void Swap(CountDown* other);
  
  // implements Message ----------------------------------------------
  
  CountDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CountDown& from);
  void MergeFrom(const CountDown& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional int32 currentCountDown = 2;
  inline bool has_currentcountdown() const;
  inline void clear_currentcountdown();
  static const int kCurrentCountDownFieldNumber = 2;
  inline ::google::protobuf::int32 currentcountdown() const;
  inline void set_currentcountdown(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.CountDown)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_currentcountdown();
  inline void clear_has_currentcountdown();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::google::protobuf::int32 currentcountdown_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static CountDown* default_instance_;
};
// -------------------------------------------------------------------

class FightPlayerInfo : public ::google::protobuf::Message {
 public:
  FightPlayerInfo();
  virtual ~FightPlayerInfo();
  
  FightPlayerInfo(const FightPlayerInfo& from);
  
  inline FightPlayerInfo& operator=(const FightPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FightPlayerInfo& default_instance();
  
  void Swap(FightPlayerInfo* other);
  
  // implements Message ----------------------------------------------
  
  FightPlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FightPlayerInfo& from);
  void MergeFrom(const FightPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // repeated .rpc.Card handCards = 2;
  inline int handcards_size() const;
  inline void clear_handcards();
  static const int kHandCardsFieldNumber = 2;
  inline const ::rpc::Card& handcards(int index) const;
  inline ::rpc::Card* mutable_handcards(int index);
  inline ::rpc::Card* add_handcards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
      handcards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
      mutable_handcards();
  
  // repeated .rpc.Pattern longPattern = 3;
  inline int longpattern_size() const;
  inline void clear_longpattern();
  static const int kLongPatternFieldNumber = 3;
  inline const ::rpc::Pattern& longpattern(int index) const;
  inline ::rpc::Pattern* mutable_longpattern(int index);
  inline ::rpc::Pattern* add_longpattern();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
      longpattern() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
      mutable_longpattern();
  
  // repeated .rpc.Pattern kanPattern = 4;
  inline int kanpattern_size() const;
  inline void clear_kanpattern();
  static const int kKanPatternFieldNumber = 4;
  inline const ::rpc::Pattern& kanpattern(int index) const;
  inline ::rpc::Pattern* mutable_kanpattern(int index);
  inline ::rpc::Pattern* add_kanpattern();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
      kanpattern() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
      mutable_kanpattern();
  
  // repeated .rpc.Card erLongTouYi = 5;
  inline int erlongtouyi_size() const;
  inline void clear_erlongtouyi();
  static const int kErLongTouYiFieldNumber = 5;
  inline const ::rpc::Card& erlongtouyi(int index) const;
  inline ::rpc::Card* mutable_erlongtouyi(int index);
  inline ::rpc::Card* add_erlongtouyi();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
      erlongtouyi() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
      mutable_erlongtouyi();
  
  // repeated .rpc.Card chuGuoCards = 6;
  inline int chuguocards_size() const;
  inline void clear_chuguocards();
  static const int kChuGuoCardsFieldNumber = 6;
  inline const ::rpc::Card& chuguocards(int index) const;
  inline ::rpc::Card* mutable_chuguocards(int index);
  inline ::rpc::Card* add_chuguocards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
      chuguocards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
      mutable_chuguocards();
  
  // repeated .rpc.Pattern chiPengZhaoLongCards = 7;
  inline int chipengzhaolongcards_size() const;
  inline void clear_chipengzhaolongcards();
  static const int kChiPengZhaoLongCardsFieldNumber = 7;
  inline const ::rpc::Pattern& chipengzhaolongcards(int index) const;
  inline ::rpc::Pattern* mutable_chipengzhaolongcards(int index);
  inline ::rpc::Pattern* add_chipengzhaolongcards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
      chipengzhaolongcards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
      mutable_chipengzhaolongcards();
  
  // optional int32 currentHu = 8;
  inline bool has_currenthu() const;
  inline void clear_currenthu();
  static const int kCurrentHuFieldNumber = 8;
  inline ::google::protobuf::int32 currenthu() const;
  inline void set_currenthu(::google::protobuf::int32 value);
  
  // optional bool bZhuang = 9;
  inline bool has_bzhuang() const;
  inline void clear_bzhuang();
  static const int kBZhuangFieldNumber = 9;
  inline bool bzhuang() const;
  inline void set_bzhuang(bool value);
  
  // optional bool bBao = 10;
  inline bool has_bbao() const;
  inline void clear_bbao();
  static const int kBBaoFieldNumber = 10;
  inline bool bbao() const;
  inline void set_bbao(bool value);
  
  // optional bool bTuoGuan = 11;
  inline bool has_btuoguan() const;
  inline void clear_btuoguan();
  static const int kBTuoGuanFieldNumber = 11;
  inline bool btuoguan() const;
  inline void set_btuoguan(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.FightPlayerInfo)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_currenthu();
  inline void clear_has_currenthu();
  inline void set_has_bzhuang();
  inline void clear_has_bzhuang();
  inline void set_has_bbao();
  inline void clear_has_bbao();
  inline void set_has_btuoguan();
  inline void clear_has_btuoguan();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Card > handcards_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pattern > longpattern_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pattern > kanpattern_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Card > erlongtouyi_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Card > chuguocards_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pattern > chipengzhaolongcards_;
  ::google::protobuf::int32 currenthu_;
  bool bzhuang_;
  bool bbao_;
  bool btuoguan_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FightPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class FightCurrentStateInfo : public ::google::protobuf::Message {
 public:
  FightCurrentStateInfo();
  virtual ~FightCurrentStateInfo();
  
  FightCurrentStateInfo(const FightCurrentStateInfo& from);
  
  inline FightCurrentStateInfo& operator=(const FightCurrentStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FightCurrentStateInfo& default_instance();
  
  void Swap(FightCurrentStateInfo* other);
  
  // implements Message ----------------------------------------------
  
  FightCurrentStateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FightCurrentStateInfo& from);
  void MergeFrom(const FightCurrentStateInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .rpc.Card currentDeskCard = 1;
  inline bool has_currentdeskcard() const;
  inline void clear_currentdeskcard();
  static const int kCurrentDeskCardFieldNumber = 1;
  inline const ::rpc::Card& currentdeskcard() const;
  inline ::rpc::Card* mutable_currentdeskcard();
  inline ::rpc::Card* release_currentdeskcard();
  
  // repeated .rpc.CountDown currentCountDownInfo = 2;
  inline int currentcountdowninfo_size() const;
  inline void clear_currentcountdowninfo();
  static const int kCurrentCountDownInfoFieldNumber = 2;
  inline const ::rpc::CountDown& currentcountdowninfo(int index) const;
  inline ::rpc::CountDown* mutable_currentcountdowninfo(int index);
  inline ::rpc::CountDown* add_currentcountdowninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::CountDown >&
      currentcountdowninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::CountDown >*
      mutable_currentcountdowninfo();
  
  // optional string currentDeskCardPlayerID = 4;
  inline bool has_currentdeskcardplayerid() const;
  inline void clear_currentdeskcardplayerid();
  static const int kCurrentDeskCardPlayerIDFieldNumber = 4;
  inline const ::std::string& currentdeskcardplayerid() const;
  inline void set_currentdeskcardplayerid(const ::std::string& value);
  inline void set_currentdeskcardplayerid(const char* value);
  inline void set_currentdeskcardplayerid(const char* value, size_t size);
  inline ::std::string* mutable_currentdeskcardplayerid();
  inline ::std::string* release_currentdeskcardplayerid();
  
  // required int32 currentDeskRemainCard = 5;
  inline bool has_currentdeskremaincard() const;
  inline void clear_currentdeskremaincard();
  static const int kCurrentDeskRemainCardFieldNumber = 5;
  inline ::google::protobuf::int32 currentdeskremaincard() const;
  inline void set_currentdeskremaincard(::google::protobuf::int32 value);
  
  // optional bool bCurrentDeskCardMo = 6;
  inline bool has_bcurrentdeskcardmo() const;
  inline void clear_bcurrentdeskcardmo();
  static const int kBCurrentDeskCardMoFieldNumber = 6;
  inline bool bcurrentdeskcardmo() const;
  inline void set_bcurrentdeskcardmo(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.FightCurrentStateInfo)
 private:
  inline void set_has_currentdeskcard();
  inline void clear_has_currentdeskcard();
  inline void set_has_currentdeskcardplayerid();
  inline void clear_has_currentdeskcardplayerid();
  inline void set_has_currentdeskremaincard();
  inline void clear_has_currentdeskremaincard();
  inline void set_has_bcurrentdeskcardmo();
  inline void clear_has_bcurrentdeskcardmo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::Card* currentdeskcard_;
  ::google::protobuf::RepeatedPtrField< ::rpc::CountDown > currentcountdowninfo_;
  ::std::string* currentdeskcardplayerid_;
  ::google::protobuf::int32 currentdeskremaincard_;
  bool bcurrentdeskcardmo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FightCurrentStateInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameStartACK : public ::google::protobuf::Message {
 public:
  GameStartACK();
  virtual ~GameStartACK();
  
  GameStartACK(const GameStartACK& from);
  
  inline GameStartACK& operator=(const GameStartACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameStartACK& default_instance();
  
  void Swap(GameStartACK* other);
  
  // implements Message ----------------------------------------------
  
  GameStartACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameStartACK& from);
  void MergeFrom(const GameStartACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.FightPlayerInfo fightPlayersInfo = 1;
  inline int fightplayersinfo_size() const;
  inline void clear_fightplayersinfo();
  static const int kFightPlayersInfoFieldNumber = 1;
  inline const ::rpc::FightPlayerInfo& fightplayersinfo(int index) const;
  inline ::rpc::FightPlayerInfo* mutable_fightplayersinfo(int index);
  inline ::rpc::FightPlayerInfo* add_fightplayersinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::FightPlayerInfo >&
      fightplayersinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::FightPlayerInfo >*
      mutable_fightplayersinfo();
  
  // optional .rpc.FightCurrentStateInfo currentFightState = 2;
  inline bool has_currentfightstate() const;
  inline void clear_currentfightstate();
  static const int kCurrentFightStateFieldNumber = 2;
  inline const ::rpc::FightCurrentStateInfo& currentfightstate() const;
  inline ::rpc::FightCurrentStateInfo* mutable_currentfightstate();
  inline ::rpc::FightCurrentStateInfo* release_currentfightstate();
  
  // optional int32 fightState = 5;
  inline bool has_fightstate() const;
  inline void clear_fightstate();
  static const int kFightStateFieldNumber = 5;
  inline ::google::protobuf::int32 fightstate() const;
  inline void set_fightstate(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.GameStartACK)
 private:
  inline void set_has_currentfightstate();
  inline void clear_has_currentfightstate();
  inline void set_has_fightstate();
  inline void clear_has_fightstate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::FightPlayerInfo > fightplayersinfo_;
  ::rpc::FightCurrentStateInfo* currentfightstate_;
  ::google::protobuf::int32 fightstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static GameStartACK* default_instance_;
};
// -------------------------------------------------------------------

class ActionREQ : public ::google::protobuf::Message {
 public:
  ActionREQ();
  virtual ~ActionREQ();
  
  ActionREQ(const ActionREQ& from);
  
  inline ActionREQ& operator=(const ActionREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionREQ& default_instance();
  
  void Swap(ActionREQ* other);
  
  // implements Message ----------------------------------------------
  
  ActionREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionREQ& from);
  void MergeFrom(const ActionREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);
  
  // required string playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional .rpc.Pattern chiCards = 3;
  inline bool has_chicards() const;
  inline void clear_chicards();
  static const int kChiCardsFieldNumber = 3;
  inline const ::rpc::Pattern& chicards() const;
  inline ::rpc::Pattern* mutable_chicards();
  inline ::rpc::Pattern* release_chicards();
  
  // optional .rpc.Pattern biCards = 4;
  inline bool has_bicards() const;
  inline void clear_bicards();
  static const int kBiCardsFieldNumber = 4;
  inline const ::rpc::Pattern& bicards() const;
  inline ::rpc::Pattern* mutable_bicards();
  inline ::rpc::Pattern* release_bicards();
  
  // optional .rpc.Card chuPai = 5;
  inline bool has_chupai() const;
  inline void clear_chupai();
  static const int kChuPaiFieldNumber = 5;
  inline const ::rpc::Card& chupai() const;
  inline ::rpc::Card* mutable_chupai();
  inline ::rpc::Card* release_chupai();
  
  // optional .rpc.MJCard cardArgs = 10;
  inline bool has_cardargs() const;
  inline void clear_cardargs();
  static const int kCardArgsFieldNumber = 10;
  inline const ::rpc::MJCard& cardargs() const;
  inline ::rpc::MJCard* mutable_cardargs();
  inline ::rpc::MJCard* release_cardargs();
  
  // required int32 sysType = 6;
  inline bool has_systype() const;
  inline void clear_systype();
  static const int kSysTypeFieldNumber = 6;
  inline ::google::protobuf::int32 systype() const;
  inline void set_systype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.ActionREQ)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_chicards();
  inline void clear_has_chicards();
  inline void set_has_bicards();
  inline void clear_has_bicards();
  inline void set_has_chupai();
  inline void clear_has_chupai();
  inline void set_has_cardargs();
  inline void clear_has_cardargs();
  inline void set_has_systype();
  inline void clear_has_systype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::rpc::Pattern* chicards_;
  ::rpc::Pattern* bicards_;
  ::google::protobuf::int32 action_;
  ::google::protobuf::int32 systype_;
  ::rpc::Card* chupai_;
  ::rpc::MJCard* cardargs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ActionREQ* default_instance_;
};
// -------------------------------------------------------------------

class ChiAtionArgs : public ::google::protobuf::Message {
 public:
  ChiAtionArgs();
  virtual ~ChiAtionArgs();
  
  ChiAtionArgs(const ChiAtionArgs& from);
  
  inline ChiAtionArgs& operator=(const ChiAtionArgs& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChiAtionArgs& default_instance();
  
  void Swap(ChiAtionArgs* other);
  
  // implements Message ----------------------------------------------
  
  ChiAtionArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChiAtionArgs& from);
  void MergeFrom(const ChiAtionArgs& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .rpc.Pattern canChiCards = 1;
  inline bool has_canchicards() const;
  inline void clear_canchicards();
  static const int kCanChiCardsFieldNumber = 1;
  inline const ::rpc::Pattern& canchicards() const;
  inline ::rpc::Pattern* mutable_canchicards();
  inline ::rpc::Pattern* release_canchicards();
  
  // repeated .rpc.Pattern needBiCards = 2;
  inline int needbicards_size() const;
  inline void clear_needbicards();
  static const int kNeedBiCardsFieldNumber = 2;
  inline const ::rpc::Pattern& needbicards(int index) const;
  inline ::rpc::Pattern* mutable_needbicards(int index);
  inline ::rpc::Pattern* add_needbicards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
      needbicards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
      mutable_needbicards();
  
  // optional .rpc.Card cardArgs = 3;
  inline bool has_cardargs() const;
  inline void clear_cardargs();
  static const int kCardArgsFieldNumber = 3;
  inline const ::rpc::Card& cardargs() const;
  inline ::rpc::Card* mutable_cardargs();
  inline ::rpc::Card* release_cardargs();
  
  // @@protoc_insertion_point(class_scope:rpc.ChiAtionArgs)
 private:
  inline void set_has_canchicards();
  inline void clear_has_canchicards();
  inline void set_has_cardargs();
  inline void clear_has_cardargs();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::Pattern* canchicards_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pattern > needbicards_;
  ::rpc::Card* cardargs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ChiAtionArgs* default_instance_;
};
// -------------------------------------------------------------------

class ActionACK : public ::google::protobuf::Message {
 public:
  ActionACK();
  virtual ~ActionACK();
  
  ActionACK(const ActionACK& from);
  
  inline ActionACK& operator=(const ActionACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionACK& default_instance();
  
  void Swap(ActionACK* other);
  
  // implements Message ----------------------------------------------
  
  ActionACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionACK& from);
  void MergeFrom(const ActionACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);
  
  // optional string playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional .rpc.Card cardArgs = 4;
  inline bool has_cardargs() const;
  inline void clear_cardargs();
  static const int kCardArgsFieldNumber = 4;
  inline const ::rpc::Card& cardargs() const;
  inline ::rpc::Card* mutable_cardargs();
  inline ::rpc::Card* release_cardargs();
  
  // repeated .rpc.Pattern chiPengZhaoLongCards = 6;
  inline int chipengzhaolongcards_size() const;
  inline void clear_chipengzhaolongcards();
  static const int kChiPengZhaoLongCardsFieldNumber = 6;
  inline const ::rpc::Pattern& chipengzhaolongcards(int index) const;
  inline ::rpc::Pattern* mutable_chipengzhaolongcards(int index);
  inline ::rpc::Pattern* add_chipengzhaolongcards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
      chipengzhaolongcards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
      mutable_chipengzhaolongcards();
  
  // optional int32 updateHu = 7;
  inline bool has_updatehu() const;
  inline void clear_updatehu();
  static const int kUpdateHuFieldNumber = 7;
  inline ::google::protobuf::int32 updatehu() const;
  inline void set_updatehu(::google::protobuf::int32 value);
  
  // optional int32 currenDeskRemianCard = 8;
  inline bool has_currendeskremiancard() const;
  inline void clear_currendeskremiancard();
  static const int kCurrenDeskRemianCardFieldNumber = 8;
  inline ::google::protobuf::int32 currendeskremiancard() const;
  inline void set_currendeskremiancard(::google::protobuf::int32 value);
  
  // required int32 result = 9;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 9;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.ActionACK)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_cardargs();
  inline void clear_has_cardargs();
  inline void set_has_updatehu();
  inline void clear_has_updatehu();
  inline void set_has_currendeskremiancard();
  inline void clear_has_currendeskremiancard();
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::rpc::Card* cardargs_;
  ::google::protobuf::int32 action_;
  ::google::protobuf::int32 updatehu_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pattern > chipengzhaolongcards_;
  ::google::protobuf::int32 currendeskremiancard_;
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ActionACK* default_instance_;
};
// -------------------------------------------------------------------

class ActionNotifyACK : public ::google::protobuf::Message {
 public:
  ActionNotifyACK();
  virtual ~ActionNotifyACK();
  
  ActionNotifyACK(const ActionNotifyACK& from);
  
  inline ActionNotifyACK& operator=(const ActionNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionNotifyACK& default_instance();
  
  void Swap(ActionNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  ActionNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionNotifyACK& from);
  void MergeFrom(const ActionNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);
  
  // repeated .rpc.ChiAtionArgs chiAtionArgs = 3;
  inline int chiationargs_size() const;
  inline void clear_chiationargs();
  static const int kChiAtionArgsFieldNumber = 3;
  inline const ::rpc::ChiAtionArgs& chiationargs(int index) const;
  inline ::rpc::ChiAtionArgs* mutable_chiationargs(int index);
  inline ::rpc::ChiAtionArgs* add_chiationargs();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::ChiAtionArgs >&
      chiationargs() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::ChiAtionArgs >*
      mutable_chiationargs();
  
  // @@protoc_insertion_point(class_scope:rpc.ActionNotifyACK)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::ChiAtionArgs > chiationargs_;
  ::google::protobuf::int32 action_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ActionNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class CountdownNotifyACK : public ::google::protobuf::Message {
 public:
  CountdownNotifyACK();
  virtual ~CountdownNotifyACK();
  
  CountdownNotifyACK(const CountdownNotifyACK& from);
  
  inline CountdownNotifyACK& operator=(const CountdownNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CountdownNotifyACK& default_instance();
  
  void Swap(CountdownNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  CountdownNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CountdownNotifyACK& from);
  void MergeFrom(const CountdownNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .rpc.CountDown countDown = 1;
  inline bool has_countdown() const;
  inline void clear_countdown();
  static const int kCountDownFieldNumber = 1;
  inline const ::rpc::CountDown& countdown() const;
  inline ::rpc::CountDown* mutable_countdown();
  inline ::rpc::CountDown* release_countdown();
  
  // @@protoc_insertion_point(class_scope:rpc.CountdownNotifyACK)
 private:
  inline void set_has_countdown();
  inline void clear_has_countdown();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::CountDown* countdown_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static CountdownNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class PassCardNotifyACK : public ::google::protobuf::Message {
 public:
  PassCardNotifyACK();
  virtual ~PassCardNotifyACK();
  
  PassCardNotifyACK(const PassCardNotifyACK& from);
  
  inline PassCardNotifyACK& operator=(const PassCardNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PassCardNotifyACK& default_instance();
  
  void Swap(PassCardNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  PassCardNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PassCardNotifyACK& from);
  void MergeFrom(const PassCardNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // required .rpc.Card card = 2;
  inline bool has_card() const;
  inline void clear_card();
  static const int kCardFieldNumber = 2;
  inline const ::rpc::Card& card() const;
  inline ::rpc::Card* mutable_card();
  inline ::rpc::Card* release_card();
  
  // @@protoc_insertion_point(class_scope:rpc.PassCardNotifyACK)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_card();
  inline void clear_has_card();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::rpc::Card* card_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PassCardNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class PassedNotifyACK : public ::google::protobuf::Message {
 public:
  PassedNotifyACK();
  virtual ~PassedNotifyACK();
  
  PassedNotifyACK(const PassedNotifyACK& from);
  
  inline PassedNotifyACK& operator=(const PassedNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PassedNotifyACK& default_instance();
  
  void Swap(PassedNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  PassedNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PassedNotifyACK& from);
  void MergeFrom(const PassedNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .rpc.Card card = 1;
  inline bool has_card() const;
  inline void clear_card();
  static const int kCardFieldNumber = 1;
  inline const ::rpc::Card& card() const;
  inline ::rpc::Card* mutable_card();
  inline ::rpc::Card* release_card();
  
  // @@protoc_insertion_point(class_scope:rpc.PassedNotifyACK)
 private:
  inline void set_has_card();
  inline void clear_has_card();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::Card* card_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PassedNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class MingTang : public ::google::protobuf::Message {
 public:
  MingTang();
  virtual ~MingTang();
  
  MingTang(const MingTang& from);
  
  inline MingTang& operator=(const MingTang& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MingTang& default_instance();
  
  void Swap(MingTang* other);
  
  // implements Message ----------------------------------------------
  
  MingTang* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MingTang& from);
  void MergeFrom(const MingTang& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 mingTang = 1;
  inline bool has_mingtang() const;
  inline void clear_mingtang();
  static const int kMingTangFieldNumber = 1;
  inline ::google::protobuf::int32 mingtang() const;
  inline void set_mingtang(::google::protobuf::int32 value);
  
  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MingTang)
 private:
  inline void set_has_mingtang();
  inline void clear_has_mingtang();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 mingtang_;
  ::google::protobuf::int32 value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MingTang* default_instance_;
};
// -------------------------------------------------------------------

class JieSuanCoin : public ::google::protobuf::Message {
 public:
  JieSuanCoin();
  virtual ~JieSuanCoin();
  
  JieSuanCoin(const JieSuanCoin& from);
  
  inline JieSuanCoin& operator=(const JieSuanCoin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JieSuanCoin& default_instance();
  
  void Swap(JieSuanCoin* other);
  
  // implements Message ----------------------------------------------
  
  JieSuanCoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JieSuanCoin& from);
  void MergeFrom(const JieSuanCoin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional int32 coin = 2;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 2;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // optional int32 tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.JieSuanCoin)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_tag();
  inline void clear_has_tag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static JieSuanCoin* default_instance_;
};
// -------------------------------------------------------------------

class DaerPlayerJieSuanPattern : public ::google::protobuf::Message {
 public:
  DaerPlayerJieSuanPattern();
  virtual ~DaerPlayerJieSuanPattern();
  
  DaerPlayerJieSuanPattern(const DaerPlayerJieSuanPattern& from);
  
  inline DaerPlayerJieSuanPattern& operator=(const DaerPlayerJieSuanPattern& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DaerPlayerJieSuanPattern& default_instance();
  
  void Swap(DaerPlayerJieSuanPattern* other);
  
  // implements Message ----------------------------------------------
  
  DaerPlayerJieSuanPattern* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DaerPlayerJieSuanPattern& from);
  void MergeFrom(const DaerPlayerJieSuanPattern& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional int32 hu = 3;
  inline bool has_hu() const;
  inline void clear_hu();
  static const int kHuFieldNumber = 3;
  inline ::google::protobuf::int32 hu() const;
  inline void set_hu(::google::protobuf::int32 value);
  
  // optional int32 score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // repeated .rpc.Pattern patterns = 7;
  inline int patterns_size() const;
  inline void clear_patterns();
  static const int kPatternsFieldNumber = 7;
  inline const ::rpc::Pattern& patterns(int index) const;
  inline ::rpc::Pattern* mutable_patterns(int index);
  inline ::rpc::Pattern* add_patterns();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
      patterns() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
      mutable_patterns();
  
  // repeated .rpc.MingTang mingTang = 9;
  inline int mingtang_size() const;
  inline void clear_mingtang();
  static const int kMingTangFieldNumber = 9;
  inline const ::rpc::MingTang& mingtang(int index) const;
  inline ::rpc::MingTang* mutable_mingtang(int index);
  inline ::rpc::MingTang* add_mingtang();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MingTang >&
      mingtang() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MingTang >*
      mutable_mingtang();
  
  // required int32 coin = 11;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 11;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // required int32 tag = 13;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 13;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.DaerPlayerJieSuanPattern)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_hu();
  inline void clear_has_hu();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_tag();
  inline void clear_has_tag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::google::protobuf::int32 hu_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pattern > patterns_;
  ::google::protobuf::RepeatedPtrField< ::rpc::MingTang > mingtang_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static DaerPlayerJieSuanPattern* default_instance_;
};
// -------------------------------------------------------------------

class JieSuanNotifyACK : public ::google::protobuf::Message {
 public:
  JieSuanNotifyACK();
  virtual ~JieSuanNotifyACK();
  
  JieSuanNotifyACK(const JieSuanNotifyACK& from);
  
  inline JieSuanNotifyACK& operator=(const JieSuanNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JieSuanNotifyACK& default_instance();
  
  void Swap(JieSuanNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  JieSuanNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JieSuanNotifyACK& from);
  void MergeFrom(const JieSuanNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.DaerPlayerJieSuanPattern daerPlayerJieSuanPattern = 1;
  inline int daerplayerjiesuanpattern_size() const;
  inline void clear_daerplayerjiesuanpattern();
  static const int kDaerPlayerJieSuanPatternFieldNumber = 1;
  inline const ::rpc::DaerPlayerJieSuanPattern& daerplayerjiesuanpattern(int index) const;
  inline ::rpc::DaerPlayerJieSuanPattern* mutable_daerplayerjiesuanpattern(int index);
  inline ::rpc::DaerPlayerJieSuanPattern* add_daerplayerjiesuanpattern();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::DaerPlayerJieSuanPattern >&
      daerplayerjiesuanpattern() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::DaerPlayerJieSuanPattern >*
      mutable_daerplayerjiesuanpattern();
  
  // repeated .rpc.Card diCards = 7;
  inline int dicards_size() const;
  inline void clear_dicards();
  static const int kDiCardsFieldNumber = 7;
  inline const ::rpc::Card& dicards(int index) const;
  inline ::rpc::Card* mutable_dicards(int index);
  inline ::rpc::Card* add_dicards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
      dicards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
      mutable_dicards();
  
  // optional bool huangZhuang = 9;
  inline bool has_huangzhuang() const;
  inline void clear_huangzhuang();
  static const int kHuangZhuangFieldNumber = 9;
  inline bool huangzhuang() const;
  inline void set_huangzhuang(bool value);
  
  // optional .rpc.JieSuanAdditionData addi = 11;
  inline bool has_addi() const;
  inline void clear_addi();
  static const int kAddiFieldNumber = 11;
  inline const ::rpc::JieSuanAdditionData& addi() const;
  inline ::rpc::JieSuanAdditionData* mutable_addi();
  inline ::rpc::JieSuanAdditionData* release_addi();
  
  // @@protoc_insertion_point(class_scope:rpc.JieSuanNotifyACK)
 private:
  inline void set_has_huangzhuang();
  inline void clear_has_huangzhuang();
  inline void set_has_addi();
  inline void clear_has_addi();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::DaerPlayerJieSuanPattern > daerplayerjiesuanpattern_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Card > dicards_;
  ::rpc::JieSuanAdditionData* addi_;
  bool huangzhuang_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static JieSuanNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class JieSuanAdditionData : public ::google::protobuf::Message {
 public:
  JieSuanAdditionData();
  virtual ~JieSuanAdditionData();
  
  JieSuanAdditionData(const JieSuanAdditionData& from);
  
  inline JieSuanAdditionData& operator=(const JieSuanAdditionData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JieSuanAdditionData& default_instance();
  
  void Swap(JieSuanAdditionData* other);
  
  // implements Message ----------------------------------------------
  
  JieSuanAdditionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JieSuanAdditionData& from);
  void MergeFrom(const JieSuanAdditionData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 sysType = 1;
  inline bool has_systype() const;
  inline void clear_systype();
  static const int kSysTypeFieldNumber = 1;
  inline ::google::protobuf::int32 systype() const;
  inline void set_systype(::google::protobuf::int32 value);
  
  // optional bool stageEnd = 2;
  inline bool has_stageend() const;
  inline void clear_stageend();
  static const int kStageEndFieldNumber = 2;
  inline bool stageend() const;
  inline void set_stageend(bool value);
  
  // optional bool success = 3;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 3;
  inline bool success() const;
  inline void set_success(bool value);
  
  // repeated .rpc.JieSuanCoin coin = 4;
  inline int coin_size() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 4;
  inline const ::rpc::JieSuanCoin& coin(int index) const;
  inline ::rpc::JieSuanCoin* mutable_coin(int index);
  inline ::rpc::JieSuanCoin* add_coin();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::JieSuanCoin >&
      coin() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::JieSuanCoin >*
      mutable_coin();
  
  // optional int64 jieSuanTime = 5;
  inline bool has_jiesuantime() const;
  inline void clear_jiesuantime();
  static const int kJieSuanTimeFieldNumber = 5;
  inline ::google::protobuf::int64 jiesuantime() const;
  inline void set_jiesuantime(::google::protobuf::int64 value);
  
  // optional int32 curTimes = 6;
  inline bool has_curtimes() const;
  inline void clear_curtimes();
  static const int kCurTimesFieldNumber = 6;
  inline ::google::protobuf::int32 curtimes() const;
  inline void set_curtimes(::google::protobuf::int32 value);
  
  // optional int32 continueTime = 7;
  inline bool has_continuetime() const;
  inline void clear_continuetime();
  static const int kContinueTimeFieldNumber = 7;
  inline ::google::protobuf::int32 continuetime() const;
  inline void set_continuetime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.JieSuanAdditionData)
 private:
  inline void set_has_systype();
  inline void clear_has_systype();
  inline void set_has_stageend();
  inline void clear_has_stageend();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_jiesuantime();
  inline void clear_has_jiesuantime();
  inline void set_has_curtimes();
  inline void clear_has_curtimes();
  inline void set_has_continuetime();
  inline void clear_has_continuetime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 systype_;
  bool stageend_;
  bool success_;
  ::google::protobuf::RepeatedPtrField< ::rpc::JieSuanCoin > coin_;
  ::google::protobuf::int64 jiesuantime_;
  ::google::protobuf::int32 curtimes_;
  ::google::protobuf::int32 continuetime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static JieSuanAdditionData* default_instance_;
};
// -------------------------------------------------------------------

class FinalJieSuanNotifyACK : public ::google::protobuf::Message {
 public:
  FinalJieSuanNotifyACK();
  virtual ~FinalJieSuanNotifyACK();
  
  FinalJieSuanNotifyACK(const FinalJieSuanNotifyACK& from);
  
  inline FinalJieSuanNotifyACK& operator=(const FinalJieSuanNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FinalJieSuanNotifyACK& default_instance();
  
  void Swap(FinalJieSuanNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  FinalJieSuanNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FinalJieSuanNotifyACK& from);
  void MergeFrom(const FinalJieSuanNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .rpc.JieSuanAdditionData jieSuanInfo = 1;
  inline bool has_jiesuaninfo() const;
  inline void clear_jiesuaninfo();
  static const int kJieSuanInfoFieldNumber = 1;
  inline const ::rpc::JieSuanAdditionData& jiesuaninfo() const;
  inline ::rpc::JieSuanAdditionData* mutable_jiesuaninfo();
  inline ::rpc::JieSuanAdditionData* release_jiesuaninfo();
  
  // @@protoc_insertion_point(class_scope:rpc.FinalJieSuanNotifyACK)
 private:
  inline void set_has_jiesuaninfo();
  inline void clear_has_jiesuaninfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::JieSuanAdditionData* jiesuaninfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FinalJieSuanNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class MJCard : public ::google::protobuf::Message {
 public:
  MJCard();
  virtual ~MJCard();
  
  MJCard(const MJCard& from);
  
  inline MJCard& operator=(const MJCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJCard& default_instance();
  
  void Swap(MJCard* other);
  
  // implements Message ----------------------------------------------
  
  MJCard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJCard& from);
  void MergeFrom(const MJCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // required int32 cType = 2;
  inline bool has_ctype() const;
  inline void clear_ctype();
  static const int kCTypeFieldNumber = 2;
  inline ::google::protobuf::int32 ctype() const;
  inline void set_ctype(::google::protobuf::int32 value);
  
  // required int32 rcType = 3;
  inline bool has_rctype() const;
  inline void clear_rctype();
  static const int kRcTypeFieldNumber = 3;
  inline ::google::protobuf::int32 rctype() const;
  inline void set_rctype(::google::protobuf::int32 value);
  
  // optional int32 flag = 4;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 4;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJCard)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_ctype();
  inline void clear_has_ctype();
  inline void set_has_rctype();
  inline void clear_has_rctype();
  inline void set_has_flag();
  inline void clear_has_flag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 value_;
  ::google::protobuf::int32 ctype_;
  ::google::protobuf::int32 rctype_;
  ::google::protobuf::int32 flag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJCard* default_instance_;
};
// -------------------------------------------------------------------

class MJPattern : public ::google::protobuf::Message {
 public:
  MJPattern();
  virtual ~MJPattern();
  
  MJPattern(const MJPattern& from);
  
  inline MJPattern& operator=(const MJPattern& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJPattern& default_instance();
  
  void Swap(MJPattern* other);
  
  // implements Message ----------------------------------------------
  
  MJPattern* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJPattern& from);
  void MergeFrom(const MJPattern& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 ptype = 1;
  inline bool has_ptype() const;
  inline void clear_ptype();
  static const int kPtypeFieldNumber = 1;
  inline ::google::protobuf::int32 ptype() const;
  inline void set_ptype(::google::protobuf::int32 value);
  
  // required int32 cType = 2;
  inline bool has_ctype() const;
  inline void clear_ctype();
  static const int kCTypeFieldNumber = 2;
  inline ::google::protobuf::int32 ctype() const;
  inline void set_ctype(::google::protobuf::int32 value);
  
  // repeated .rpc.MJCard cards = 3;
  inline int cards_size() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 3;
  inline const ::rpc::MJCard& cards(int index) const;
  inline ::rpc::MJCard* mutable_cards(int index);
  inline ::rpc::MJCard* add_cards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >&
      cards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >*
      mutable_cards();
  
  // optional bool isShow = 4;
  inline bool has_isshow() const;
  inline void clear_isshow();
  static const int kIsShowFieldNumber = 4;
  inline bool isshow() const;
  inline void set_isshow(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJPattern)
 private:
  inline void set_has_ptype();
  inline void clear_has_ptype();
  inline void set_has_ctype();
  inline void clear_has_ctype();
  inline void set_has_isshow();
  inline void clear_has_isshow();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 ptype_;
  ::google::protobuf::int32 ctype_;
  ::google::protobuf::RepeatedPtrField< ::rpc::MJCard > cards_;
  bool isshow_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJPattern* default_instance_;
};
// -------------------------------------------------------------------

class MJQuickEnterRoomREQ : public ::google::protobuf::Message {
 public:
  MJQuickEnterRoomREQ();
  virtual ~MJQuickEnterRoomREQ();
  
  MJQuickEnterRoomREQ(const MJQuickEnterRoomREQ& from);
  
  inline MJQuickEnterRoomREQ& operator=(const MJQuickEnterRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJQuickEnterRoomREQ& default_instance();
  
  void Swap(MJQuickEnterRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  MJQuickEnterRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJQuickEnterRoomREQ& from);
  void MergeFrom(const MJQuickEnterRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:rpc.MJQuickEnterRoomREQ)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJQuickEnterRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class MJEnterRoomACK : public ::google::protobuf::Message {
 public:
  MJEnterRoomACK();
  virtual ~MJEnterRoomACK();
  
  MJEnterRoomACK(const MJEnterRoomACK& from);
  
  inline MJEnterRoomACK& operator=(const MJEnterRoomACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJEnterRoomACK& default_instance();
  
  void Swap(MJEnterRoomACK* other);
  
  // implements Message ----------------------------------------------
  
  MJEnterRoomACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJEnterRoomACK& from);
  void MergeFrom(const MJEnterRoomACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .rpc.PlayerBaseInfo playerInfo = 1;
  inline bool has_playerinfo() const;
  inline void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 1;
  inline const ::rpc::PlayerBaseInfo& playerinfo() const;
  inline ::rpc::PlayerBaseInfo* mutable_playerinfo();
  inline ::rpc::PlayerBaseInfo* release_playerinfo();
  
  // optional int32 location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline ::google::protobuf::int32 location() const;
  inline void set_location(::google::protobuf::int32 value);
  
  // optional bool bReady = 3;
  inline bool has_bready() const;
  inline void clear_bready();
  static const int kBReadyFieldNumber = 3;
  inline bool bready() const;
  inline void set_bready(bool value);
  
  // optional int32 code = 4;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 4;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // optional int32 roomId = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 5;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // optional bool isNormalReqEnterRoom = 6;
  inline bool has_isnormalreqenterroom() const;
  inline void clear_isnormalreqenterroom();
  static const int kIsNormalReqEnterRoomFieldNumber = 6;
  inline bool isnormalreqenterroom() const;
  inline void set_isnormalreqenterroom(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJEnterRoomACK)
 private:
  inline void set_has_playerinfo();
  inline void clear_has_playerinfo();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_bready();
  inline void clear_has_bready();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_isnormalreqenterroom();
  inline void clear_has_isnormalreqenterroom();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::PlayerBaseInfo* playerinfo_;
  ::google::protobuf::int32 location_;
  ::google::protobuf::int32 code_;
  bool bready_;
  bool isnormalreqenterroom_;
  ::google::protobuf::int32 roomid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJEnterRoomACK* default_instance_;
};
// -------------------------------------------------------------------

class MJLeaveRoomREQ : public ::google::protobuf::Message {
 public:
  MJLeaveRoomREQ();
  virtual ~MJLeaveRoomREQ();
  
  MJLeaveRoomREQ(const MJLeaveRoomREQ& from);
  
  inline MJLeaveRoomREQ& operator=(const MJLeaveRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJLeaveRoomREQ& default_instance();
  
  void Swap(MJLeaveRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  MJLeaveRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJLeaveRoomREQ& from);
  void MergeFrom(const MJLeaveRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // required bool isChangeDesk = 2;
  inline bool has_ischangedesk() const;
  inline void clear_ischangedesk();
  static const int kIsChangeDeskFieldNumber = 2;
  inline bool ischangedesk() const;
  inline void set_ischangedesk(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJLeaveRoomREQ)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_ischangedesk();
  inline void clear_has_ischangedesk();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  bool ischangedesk_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJLeaveRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class MJLeaveRoomACK : public ::google::protobuf::Message {
 public:
  MJLeaveRoomACK();
  virtual ~MJLeaveRoomACK();
  
  MJLeaveRoomACK(const MJLeaveRoomACK& from);
  
  inline MJLeaveRoomACK& operator=(const MJLeaveRoomACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJLeaveRoomACK& default_instance();
  
  void Swap(MJLeaveRoomACK* other);
  
  // implements Message ----------------------------------------------
  
  MJLeaveRoomACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJLeaveRoomACK& from);
  void MergeFrom(const MJLeaveRoomACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // required bool isChangeDesk = 2;
  inline bool has_ischangedesk() const;
  inline void clear_ischangedesk();
  static const int kIsChangeDeskFieldNumber = 2;
  inline bool ischangedesk() const;
  inline void set_ischangedesk(bool value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJLeaveRoomACK)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_ischangedesk();
  inline void clear_has_ischangedesk();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  bool ischangedesk_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJLeaveRoomACK* default_instance_;
};
// -------------------------------------------------------------------

class MJCountDown : public ::google::protobuf::Message {
 public:
  MJCountDown();
  virtual ~MJCountDown();
  
  MJCountDown(const MJCountDown& from);
  
  inline MJCountDown& operator=(const MJCountDown& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJCountDown& default_instance();
  
  void Swap(MJCountDown* other);
  
  // implements Message ----------------------------------------------
  
  MJCountDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJCountDown& from);
  void MergeFrom(const MJCountDown& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional int32 currentCountDown = 2;
  inline bool has_currentcountdown() const;
  inline void clear_currentcountdown();
  static const int kCurrentCountDownFieldNumber = 2;
  inline ::google::protobuf::int32 currentcountdown() const;
  inline void set_currentcountdown(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJCountDown)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_currentcountdown();
  inline void clear_has_currentcountdown();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::google::protobuf::int32 currentcountdown_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJCountDown* default_instance_;
};
// -------------------------------------------------------------------

class MJFightPlayerInfo : public ::google::protobuf::Message {
 public:
  MJFightPlayerInfo();
  virtual ~MJFightPlayerInfo();
  
  MJFightPlayerInfo(const MJFightPlayerInfo& from);
  
  inline MJFightPlayerInfo& operator=(const MJFightPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJFightPlayerInfo& default_instance();
  
  void Swap(MJFightPlayerInfo* other);
  
  // implements Message ----------------------------------------------
  
  MJFightPlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJFightPlayerInfo& from);
  void MergeFrom(const MJFightPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // repeated .rpc.MJCard handCards = 2;
  inline int handcards_size() const;
  inline void clear_handcards();
  static const int kHandCardsFieldNumber = 2;
  inline const ::rpc::MJCard& handcards(int index) const;
  inline ::rpc::MJCard* mutable_handcards(int index);
  inline ::rpc::MJCard* add_handcards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >&
      handcards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >*
      mutable_handcards();
  
  // repeated .rpc.MJPattern showPatterns = 4;
  inline int showpatterns_size() const;
  inline void clear_showpatterns();
  static const int kShowPatternsFieldNumber = 4;
  inline const ::rpc::MJPattern& showpatterns(int index) const;
  inline ::rpc::MJPattern* mutable_showpatterns(int index);
  inline ::rpc::MJPattern* add_showpatterns();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >&
      showpatterns() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >*
      mutable_showpatterns();
  
  // repeated .rpc.MJCard chuCards = 6;
  inline int chucards_size() const;
  inline void clear_chucards();
  static const int kChuCardsFieldNumber = 6;
  inline const ::rpc::MJCard& chucards(int index) const;
  inline ::rpc::MJCard* mutable_chucards(int index);
  inline ::rpc::MJCard* add_chucards();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >&
      chucards() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >*
      mutable_chucards();
  
  // optional bool bZhuang = 9;
  inline bool has_bzhuang() const;
  inline void clear_bzhuang();
  static const int kBZhuangFieldNumber = 9;
  inline bool bzhuang() const;
  inline void set_bzhuang(bool value);
  
  // optional bool bBao = 10;
  inline bool has_bbao() const;
  inline void clear_bbao();
  static const int kBBaoFieldNumber = 10;
  inline bool bbao() const;
  inline void set_bbao(bool value);
  
  // optional bool bTuoGuan = 11;
  inline bool has_btuoguan() const;
  inline void clear_btuoguan();
  static const int kBTuoGuanFieldNumber = 11;
  inline bool btuoguan() const;
  inline void set_btuoguan(bool value);
  
  // optional int32 handCardCount = 12;
  inline bool has_handcardcount() const;
  inline void clear_handcardcount();
  static const int kHandCardCountFieldNumber = 12;
  inline ::google::protobuf::int32 handcardcount() const;
  inline void set_handcardcount(::google::protobuf::int32 value);
  
  // optional .rpc.MJCard alreadyCardArg = 13;
  inline bool has_alreadycardarg() const;
  inline void clear_alreadycardarg();
  static const int kAlreadyCardArgFieldNumber = 13;
  inline const ::rpc::MJCard& alreadycardarg() const;
  inline ::rpc::MJCard* mutable_alreadycardarg();
  inline ::rpc::MJCard* release_alreadycardarg();
  
  // @@protoc_insertion_point(class_scope:rpc.MJFightPlayerInfo)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_bzhuang();
  inline void clear_has_bzhuang();
  inline void set_has_bbao();
  inline void clear_has_bbao();
  inline void set_has_btuoguan();
  inline void clear_has_btuoguan();
  inline void set_has_handcardcount();
  inline void clear_has_handcardcount();
  inline void set_has_alreadycardarg();
  inline void clear_has_alreadycardarg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::google::protobuf::RepeatedPtrField< ::rpc::MJCard > handcards_;
  ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern > showpatterns_;
  ::google::protobuf::RepeatedPtrField< ::rpc::MJCard > chucards_;
  bool bzhuang_;
  bool bbao_;
  bool btuoguan_;
  ::google::protobuf::int32 handcardcount_;
  ::rpc::MJCard* alreadycardarg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJFightPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class MJFightCurrentStateInfo : public ::google::protobuf::Message {
 public:
  MJFightCurrentStateInfo();
  virtual ~MJFightCurrentStateInfo();
  
  MJFightCurrentStateInfo(const MJFightCurrentStateInfo& from);
  
  inline MJFightCurrentStateInfo& operator=(const MJFightCurrentStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJFightCurrentStateInfo& default_instance();
  
  void Swap(MJFightCurrentStateInfo* other);
  
  // implements Message ----------------------------------------------
  
  MJFightCurrentStateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJFightCurrentStateInfo& from);
  void MergeFrom(const MJFightCurrentStateInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 currentCountDown = 2;
  inline bool has_currentcountdown() const;
  inline void clear_currentcountdown();
  static const int kCurrentCountDownFieldNumber = 2;
  inline ::google::protobuf::int32 currentcountdown() const;
  inline void set_currentcountdown(::google::protobuf::int32 value);
  
  // required string activePlayerID = 3;
  inline bool has_activeplayerid() const;
  inline void clear_activeplayerid();
  static const int kActivePlayerIDFieldNumber = 3;
  inline const ::std::string& activeplayerid() const;
  inline void set_activeplayerid(const ::std::string& value);
  inline void set_activeplayerid(const char* value);
  inline void set_activeplayerid(const char* value, size_t size);
  inline ::std::string* mutable_activeplayerid();
  inline ::std::string* release_activeplayerid();
  
  // optional string lastActivePlayerID = 4;
  inline bool has_lastactiveplayerid() const;
  inline void clear_lastactiveplayerid();
  static const int kLastActivePlayerIDFieldNumber = 4;
  inline const ::std::string& lastactiveplayerid() const;
  inline void set_lastactiveplayerid(const ::std::string& value);
  inline void set_lastactiveplayerid(const char* value);
  inline void set_lastactiveplayerid(const char* value, size_t size);
  inline ::std::string* mutable_lastactiveplayerid();
  inline ::std::string* release_lastactiveplayerid();
  
  // required int32 currentDeskRemainCard = 5;
  inline bool has_currentdeskremaincard() const;
  inline void clear_currentdeskremaincard();
  static const int kCurrentDeskRemainCardFieldNumber = 5;
  inline ::google::protobuf::int32 currentdeskremaincard() const;
  inline void set_currentdeskremaincard(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJFightCurrentStateInfo)
 private:
  inline void set_has_currentcountdown();
  inline void clear_has_currentcountdown();
  inline void set_has_activeplayerid();
  inline void clear_has_activeplayerid();
  inline void set_has_lastactiveplayerid();
  inline void clear_has_lastactiveplayerid();
  inline void set_has_currentdeskremaincard();
  inline void clear_has_currentdeskremaincard();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* activeplayerid_;
  ::google::protobuf::int32 currentcountdown_;
  ::google::protobuf::int32 currentdeskremaincard_;
  ::std::string* lastactiveplayerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJFightCurrentStateInfo* default_instance_;
};
// -------------------------------------------------------------------

class MJGameStartACK : public ::google::protobuf::Message {
 public:
  MJGameStartACK();
  virtual ~MJGameStartACK();
  
  MJGameStartACK(const MJGameStartACK& from);
  
  inline MJGameStartACK& operator=(const MJGameStartACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJGameStartACK& default_instance();
  
  void Swap(MJGameStartACK* other);
  
  // implements Message ----------------------------------------------
  
  MJGameStartACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJGameStartACK& from);
  void MergeFrom(const MJGameStartACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.MJFightPlayerInfo fightPlayersInfo = 1;
  inline int fightplayersinfo_size() const;
  inline void clear_fightplayersinfo();
  static const int kFightPlayersInfoFieldNumber = 1;
  inline const ::rpc::MJFightPlayerInfo& fightplayersinfo(int index) const;
  inline ::rpc::MJFightPlayerInfo* mutable_fightplayersinfo(int index);
  inline ::rpc::MJFightPlayerInfo* add_fightplayersinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJFightPlayerInfo >&
      fightplayersinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJFightPlayerInfo >*
      mutable_fightplayersinfo();
  
  // optional .rpc.MJFightCurrentStateInfo currentFightState = 2;
  inline bool has_currentfightstate() const;
  inline void clear_currentfightstate();
  static const int kCurrentFightStateFieldNumber = 2;
  inline const ::rpc::MJFightCurrentStateInfo& currentfightstate() const;
  inline ::rpc::MJFightCurrentStateInfo* mutable_currentfightstate();
  inline ::rpc::MJFightCurrentStateInfo* release_currentfightstate();
  
  // optional int32 fightState = 5;
  inline bool has_fightstate() const;
  inline void clear_fightstate();
  static const int kFightStateFieldNumber = 5;
  inline ::google::protobuf::int32 fightstate() const;
  inline void set_fightstate(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJGameStartACK)
 private:
  inline void set_has_currentfightstate();
  inline void clear_has_currentfightstate();
  inline void set_has_fightstate();
  inline void clear_has_fightstate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::MJFightPlayerInfo > fightplayersinfo_;
  ::rpc::MJFightCurrentStateInfo* currentfightstate_;
  ::google::protobuf::int32 fightstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJGameStartACK* default_instance_;
};
// -------------------------------------------------------------------

class MJActionACK : public ::google::protobuf::Message {
 public:
  MJActionACK();
  virtual ~MJActionACK();
  
  MJActionACK(const MJActionACK& from);
  
  inline MJActionACK& operator=(const MJActionACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJActionACK& default_instance();
  
  void Swap(MJActionACK* other);
  
  // implements Message ----------------------------------------------
  
  MJActionACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJActionACK& from);
  void MergeFrom(const MJActionACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);
  
  // optional string playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional .rpc.MJCard cardArgs = 4;
  inline bool has_cardargs() const;
  inline void clear_cardargs();
  static const int kCardArgsFieldNumber = 4;
  inline const ::rpc::MJCard& cardargs() const;
  inline ::rpc::MJCard* mutable_cardargs();
  inline ::rpc::MJCard* release_cardargs();
  
  // repeated .rpc.MJPattern pengGangPattern = 6;
  inline int penggangpattern_size() const;
  inline void clear_penggangpattern();
  static const int kPengGangPatternFieldNumber = 6;
  inline const ::rpc::MJPattern& penggangpattern(int index) const;
  inline ::rpc::MJPattern* mutable_penggangpattern(int index);
  inline ::rpc::MJPattern* add_penggangpattern();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >&
      penggangpattern() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >*
      mutable_penggangpattern();
  
  // optional int32 currenDeskRemianCard = 8;
  inline bool has_currendeskremiancard() const;
  inline void clear_currendeskremiancard();
  static const int kCurrenDeskRemianCardFieldNumber = 8;
  inline ::google::protobuf::int32 currendeskremiancard() const;
  inline void set_currendeskremiancard(::google::protobuf::int32 value);
  
  // required int32 result = 9;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 9;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJActionACK)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_cardargs();
  inline void clear_has_cardargs();
  inline void set_has_currendeskremiancard();
  inline void clear_has_currendeskremiancard();
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::rpc::MJCard* cardargs_;
  ::google::protobuf::int32 action_;
  ::google::protobuf::int32 currendeskremiancard_;
  ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern > penggangpattern_;
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJActionACK* default_instance_;
};
// -------------------------------------------------------------------

class MJActionArgs : public ::google::protobuf::Message {
 public:
  MJActionArgs();
  virtual ~MJActionArgs();
  
  MJActionArgs(const MJActionArgs& from);
  
  inline MJActionArgs& operator=(const MJActionArgs& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJActionArgs& default_instance();
  
  void Swap(MJActionArgs* other);
  
  // implements Message ----------------------------------------------
  
  MJActionArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJActionArgs& from);
  void MergeFrom(const MJActionArgs& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);
  
  // repeated .rpc.MJCard cardsArgs = 3;
  inline int cardsargs_size() const;
  inline void clear_cardsargs();
  static const int kCardsArgsFieldNumber = 3;
  inline const ::rpc::MJCard& cardsargs(int index) const;
  inline ::rpc::MJCard* mutable_cardsargs(int index);
  inline ::rpc::MJCard* add_cardsargs();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >&
      cardsargs() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >*
      mutable_cardsargs();
  
  // @@protoc_insertion_point(class_scope:rpc.MJActionArgs)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::MJCard > cardsargs_;
  ::google::protobuf::int32 action_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJActionArgs* default_instance_;
};
// -------------------------------------------------------------------

class MJActionNotifyACK : public ::google::protobuf::Message {
 public:
  MJActionNotifyACK();
  virtual ~MJActionNotifyACK();
  
  MJActionNotifyACK(const MJActionNotifyACK& from);
  
  inline MJActionNotifyACK& operator=(const MJActionNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJActionNotifyACK& default_instance();
  
  void Swap(MJActionNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  MJActionNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJActionNotifyACK& from);
  void MergeFrom(const MJActionNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.MJActionArgs actions = 1;
  inline int actions_size() const;
  inline void clear_actions();
  static const int kActionsFieldNumber = 1;
  inline const ::rpc::MJActionArgs& actions(int index) const;
  inline ::rpc::MJActionArgs* mutable_actions(int index);
  inline ::rpc::MJActionArgs* add_actions();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJActionArgs >&
      actions() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJActionArgs >*
      mutable_actions();
  
  // @@protoc_insertion_point(class_scope:rpc.MJActionNotifyACK)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::MJActionArgs > actions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJActionNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class MJCountdownNotifyACK : public ::google::protobuf::Message {
 public:
  MJCountdownNotifyACK();
  virtual ~MJCountdownNotifyACK();
  
  MJCountdownNotifyACK(const MJCountdownNotifyACK& from);
  
  inline MJCountdownNotifyACK& operator=(const MJCountdownNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJCountdownNotifyACK& default_instance();
  
  void Swap(MJCountdownNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  MJCountdownNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJCountdownNotifyACK& from);
  void MergeFrom(const MJCountdownNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .rpc.MJCountDown countDown = 1;
  inline bool has_countdown() const;
  inline void clear_countdown();
  static const int kCountDownFieldNumber = 1;
  inline const ::rpc::MJCountDown& countdown() const;
  inline ::rpc::MJCountDown* mutable_countdown();
  inline ::rpc::MJCountDown* release_countdown();
  
  // @@protoc_insertion_point(class_scope:rpc.MJCountdownNotifyACK)
 private:
  inline void set_has_countdown();
  inline void clear_has_countdown();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::MJCountDown* countdown_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJCountdownNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class MJRemoveCardNotifyACK : public ::google::protobuf::Message {
 public:
  MJRemoveCardNotifyACK();
  virtual ~MJRemoveCardNotifyACK();
  
  MJRemoveCardNotifyACK(const MJRemoveCardNotifyACK& from);
  
  inline MJRemoveCardNotifyACK& operator=(const MJRemoveCardNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJRemoveCardNotifyACK& default_instance();
  
  void Swap(MJRemoveCardNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  MJRemoveCardNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJRemoveCardNotifyACK& from);
  void MergeFrom(const MJRemoveCardNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // required bool isRemoveHandCard = 2;
  inline bool has_isremovehandcard() const;
  inline void clear_isremovehandcard();
  static const int kIsRemoveHandCardFieldNumber = 2;
  inline bool isremovehandcard() const;
  inline void set_isremovehandcard(bool value);
  
  // required .rpc.MJCard card = 3;
  inline bool has_card() const;
  inline void clear_card();
  static const int kCardFieldNumber = 3;
  inline const ::rpc::MJCard& card() const;
  inline ::rpc::MJCard* mutable_card();
  inline ::rpc::MJCard* release_card();
  
  // @@protoc_insertion_point(class_scope:rpc.MJRemoveCardNotifyACK)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_isremovehandcard();
  inline void clear_has_isremovehandcard();
  inline void set_has_card();
  inline void clear_has_card();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::rpc::MJCard* card_;
  bool isremovehandcard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJRemoveCardNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class MJTieGuiREQ : public ::google::protobuf::Message {
 public:
  MJTieGuiREQ();
  virtual ~MJTieGuiREQ();
  
  MJTieGuiREQ(const MJTieGuiREQ& from);
  
  inline MJTieGuiREQ& operator=(const MJTieGuiREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJTieGuiREQ& default_instance();
  
  void Swap(MJTieGuiREQ* other);
  
  // implements Message ----------------------------------------------
  
  MJTieGuiREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJTieGuiREQ& from);
  void MergeFrom(const MJTieGuiREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool bTieGui = 1;
  inline bool has_btiegui() const;
  inline void clear_btiegui();
  static const int kBTieGuiFieldNumber = 1;
  inline bool btiegui() const;
  inline void set_btiegui(bool value);
  
  // required string playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // required int32 sysType = 6;
  inline bool has_systype() const;
  inline void clear_systype();
  static const int kSysTypeFieldNumber = 6;
  inline ::google::protobuf::int32 systype() const;
  inline void set_systype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJTieGuiREQ)
 private:
  inline void set_has_btiegui();
  inline void clear_has_btiegui();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_systype();
  inline void clear_has_systype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  bool btiegui_;
  ::google::protobuf::int32 systype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJTieGuiREQ* default_instance_;
};
// -------------------------------------------------------------------

class MJMingTang : public ::google::protobuf::Message {
 public:
  MJMingTang();
  virtual ~MJMingTang();
  
  MJMingTang(const MJMingTang& from);
  
  inline MJMingTang& operator=(const MJMingTang& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJMingTang& default_instance();
  
  void Swap(MJMingTang* other);
  
  // implements Message ----------------------------------------------
  
  MJMingTang* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJMingTang& from);
  void MergeFrom(const MJMingTang& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 mingTang = 1;
  inline bool has_mingtang() const;
  inline void clear_mingtang();
  static const int kMingTangFieldNumber = 1;
  inline ::google::protobuf::int32 mingtang() const;
  inline void set_mingtang(::google::protobuf::int32 value);
  
  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJMingTang)
 private:
  inline void set_has_mingtang();
  inline void clear_has_mingtang();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 mingtang_;
  ::google::protobuf::int32 value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJMingTang* default_instance_;
};
// -------------------------------------------------------------------

class MJPlayerJieSuanInfo : public ::google::protobuf::Message {
 public:
  MJPlayerJieSuanInfo();
  virtual ~MJPlayerJieSuanInfo();
  
  MJPlayerJieSuanInfo(const MJPlayerJieSuanInfo& from);
  
  inline MJPlayerJieSuanInfo& operator=(const MJPlayerJieSuanInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJPlayerJieSuanInfo& default_instance();
  
  void Swap(MJPlayerJieSuanInfo* other);
  
  // implements Message ----------------------------------------------
  
  MJPlayerJieSuanInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJPlayerJieSuanInfo& from);
  void MergeFrom(const MJPlayerJieSuanInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional int32 coin = 2;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 2;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // repeated .rpc.MJPattern patterns = 6;
  inline int patterns_size() const;
  inline void clear_patterns();
  static const int kPatternsFieldNumber = 6;
  inline const ::rpc::MJPattern& patterns(int index) const;
  inline ::rpc::MJPattern* mutable_patterns(int index);
  inline ::rpc::MJPattern* add_patterns();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >&
      patterns() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >*
      mutable_patterns();
  
  // repeated .rpc.MJMingTang mingTang = 10;
  inline int mingtang_size() const;
  inline void clear_mingtang();
  static const int kMingTangFieldNumber = 10;
  inline const ::rpc::MJMingTang& mingtang(int index) const;
  inline ::rpc::MJMingTang* mutable_mingtang(int index);
  inline ::rpc::MJMingTang* add_mingtang();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJMingTang >&
      mingtang() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJMingTang >*
      mutable_mingtang();
  
  // optional int32 tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.MJPlayerJieSuanInfo)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_tag();
  inline void clear_has_tag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern > patterns_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 tag_;
  ::google::protobuf::RepeatedPtrField< ::rpc::MJMingTang > mingtang_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJPlayerJieSuanInfo* default_instance_;
};
// -------------------------------------------------------------------

class MJJieSuanNotifyACK : public ::google::protobuf::Message {
 public:
  MJJieSuanNotifyACK();
  virtual ~MJJieSuanNotifyACK();
  
  MJJieSuanNotifyACK(const MJJieSuanNotifyACK& from);
  
  inline MJJieSuanNotifyACK& operator=(const MJJieSuanNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MJJieSuanNotifyACK& default_instance();
  
  void Swap(MJJieSuanNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  MJJieSuanNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJJieSuanNotifyACK& from);
  void MergeFrom(const MJJieSuanNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.MJPlayerJieSuanInfo playerJieSuanInfo = 3;
  inline int playerjiesuaninfo_size() const;
  inline void clear_playerjiesuaninfo();
  static const int kPlayerJieSuanInfoFieldNumber = 3;
  inline const ::rpc::MJPlayerJieSuanInfo& playerjiesuaninfo(int index) const;
  inline ::rpc::MJPlayerJieSuanInfo* mutable_playerjiesuaninfo(int index);
  inline ::rpc::MJPlayerJieSuanInfo* add_playerjiesuaninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJPlayerJieSuanInfo >&
      playerjiesuaninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::MJPlayerJieSuanInfo >*
      mutable_playerjiesuaninfo();
  
  // optional bool huangZhuang = 9;
  inline bool has_huangzhuang() const;
  inline void clear_huangzhuang();
  static const int kHuangZhuangFieldNumber = 9;
  inline bool huangzhuang() const;
  inline void set_huangzhuang(bool value);
  
  // optional .rpc.JieSuanAdditionData addi = 11;
  inline bool has_addi() const;
  inline void clear_addi();
  static const int kAddiFieldNumber = 11;
  inline const ::rpc::JieSuanAdditionData& addi() const;
  inline ::rpc::JieSuanAdditionData* mutable_addi();
  inline ::rpc::JieSuanAdditionData* release_addi();
  
  // @@protoc_insertion_point(class_scope:rpc.MJJieSuanNotifyACK)
 private:
  inline void set_has_huangzhuang();
  inline void clear_has_huangzhuang();
  inline void set_has_addi();
  inline void clear_has_addi();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::MJPlayerJieSuanInfo > playerjiesuaninfo_;
  ::rpc::JieSuanAdditionData* addi_;
  bool huangzhuang_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MJJieSuanNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoomREQ : public ::google::protobuf::Message {
 public:
  CreateRoomREQ();
  virtual ~CreateRoomREQ();
  
  CreateRoomREQ(const CreateRoomREQ& from);
  
  inline CreateRoomREQ& operator=(const CreateRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomREQ& default_instance();
  
  void Swap(CreateRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  CreateRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomREQ& from);
  void MergeFrom(const CreateRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 currencyType = 1;
  inline bool has_currencytype() const;
  inline void clear_currencytype();
  static const int kCurrencyTypeFieldNumber = 1;
  inline ::google::protobuf::int32 currencytype() const;
  inline void set_currencytype(::google::protobuf::int32 value);
  
  // required int32 gameType = 2;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 2;
  inline ::google::protobuf::int32 gametype() const;
  inline void set_gametype(::google::protobuf::int32 value);
  
  // optional int32 difen = 4;
  inline bool has_difen() const;
  inline void clear_difen();
  static const int kDifenFieldNumber = 4;
  inline ::google::protobuf::int32 difen() const;
  inline void set_difen(::google::protobuf::int32 value);
  
  // optional int32 limitCoin = 5;
  inline bool has_limitcoin() const;
  inline void clear_limitcoin();
  static const int kLimitCoinFieldNumber = 5;
  inline ::google::protobuf::int32 limitcoin() const;
  inline void set_limitcoin(::google::protobuf::int32 value);
  
  // optional int32 times = 6;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 6;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);
  
  // required int32 maxMultiple = 7;
  inline bool has_maxmultiple() const;
  inline void clear_maxmultiple();
  static const int kMaxMultipleFieldNumber = 7;
  inline ::google::protobuf::int32 maxmultiple() const;
  inline void set_maxmultiple(::google::protobuf::int32 value);
  
  // optional bool isDaiGui = 8;
  inline bool has_isdaigui() const;
  inline void clear_isdaigui();
  static const int kIsDaiGuiFieldNumber = 8;
  inline bool isdaigui() const;
  inline void set_isdaigui(bool value);
  
  // optional int32 tiYongAmount = 9;
  inline bool has_tiyongamount() const;
  inline void clear_tiyongamount();
  static const int kTiYongAmountFieldNumber = 9;
  inline ::google::protobuf::int32 tiyongamount() const;
  inline void set_tiyongamount(::google::protobuf::int32 value);
  
  // optional int32 qiHuKeAmount = 10;
  inline bool has_qihukeamount() const;
  inline void clear_qihukeamount();
  static const int kQiHuKeAmountFieldNumber = 10;
  inline ::google::protobuf::int32 qihukeamount() const;
  inline void set_qihukeamount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.CreateRoomREQ)
 private:
  inline void set_has_currencytype();
  inline void clear_has_currencytype();
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_difen();
  inline void clear_has_difen();
  inline void set_has_limitcoin();
  inline void clear_has_limitcoin();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_maxmultiple();
  inline void clear_has_maxmultiple();
  inline void set_has_isdaigui();
  inline void clear_has_isdaigui();
  inline void set_has_tiyongamount();
  inline void clear_has_tiyongamount();
  inline void set_has_qihukeamount();
  inline void clear_has_qihukeamount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 currencytype_;
  ::google::protobuf::int32 gametype_;
  ::google::protobuf::int32 difen_;
  ::google::protobuf::int32 limitcoin_;
  ::google::protobuf::int32 times_;
  ::google::protobuf::int32 maxmultiple_;
  bool isdaigui_;
  ::google::protobuf::int32 tiyongamount_;
  ::google::protobuf::int32 qihukeamount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static CreateRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::Message {
 public:
  RoomInfo();
  virtual ~RoomInfo();
  
  RoomInfo(const RoomInfo& from);
  
  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();
  
  void Swap(RoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 currencyType = 2;
  inline bool has_currencytype() const;
  inline void clear_currencytype();
  static const int kCurrencyTypeFieldNumber = 2;
  inline ::google::protobuf::int32 currencytype() const;
  inline void set_currencytype(::google::protobuf::int32 value);
  
  // required int32 gameType = 3;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 3;
  inline ::google::protobuf::int32 gametype() const;
  inline void set_gametype(::google::protobuf::int32 value);
  
  // required int32 difen = 4;
  inline bool has_difen() const;
  inline void clear_difen();
  static const int kDifenFieldNumber = 4;
  inline ::google::protobuf::int32 difen() const;
  inline void set_difen(::google::protobuf::int32 value);
  
  // required int32 limitCoin = 5;
  inline bool has_limitcoin() const;
  inline void clear_limitcoin();
  static const int kLimitCoinFieldNumber = 5;
  inline ::google::protobuf::int32 limitcoin() const;
  inline void set_limitcoin(::google::protobuf::int32 value);
  
  // required int32 times = 6;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 6;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);
  
  // required int32 maxMultiple = 7;
  inline bool has_maxmultiple() const;
  inline void clear_maxmultiple();
  static const int kMaxMultipleFieldNumber = 7;
  inline ::google::protobuf::int32 maxmultiple() const;
  inline void set_maxmultiple(::google::protobuf::int32 value);
  
  // optional bool isDaiGui = 8;
  inline bool has_isdaigui() const;
  inline void clear_isdaigui();
  static const int kIsDaiGuiFieldNumber = 8;
  inline bool isdaigui() const;
  inline void set_isdaigui(bool value);
  
  // optional int32 tiYongAmount = 9;
  inline bool has_tiyongamount() const;
  inline void clear_tiyongamount();
  static const int kTiYongAmountFieldNumber = 9;
  inline ::google::protobuf::int32 tiyongamount() const;
  inline void set_tiyongamount(::google::protobuf::int32 value);
  
  // optional int32 qiHuKeAmount = 10;
  inline bool has_qihukeamount() const;
  inline void clear_qihukeamount();
  static const int kQiHuKeAmountFieldNumber = 10;
  inline ::google::protobuf::int32 qihukeamount() const;
  inline void set_qihukeamount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.RoomInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_currencytype();
  inline void clear_has_currencytype();
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_difen();
  inline void clear_has_difen();
  inline void set_has_limitcoin();
  inline void clear_has_limitcoin();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_maxmultiple();
  inline void clear_has_maxmultiple();
  inline void set_has_isdaigui();
  inline void clear_has_isdaigui();
  inline void set_has_tiyongamount();
  inline void clear_has_tiyongamount();
  inline void set_has_qihukeamount();
  inline void clear_has_qihukeamount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 currencytype_;
  ::google::protobuf::int32 gametype_;
  ::google::protobuf::int32 difen_;
  ::google::protobuf::int32 limitcoin_;
  ::google::protobuf::int32 times_;
  ::google::protobuf::int32 maxmultiple_;
  bool isdaigui_;
  ::google::protobuf::int32 tiyongamount_;
  ::google::protobuf::int32 qihukeamount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoomACK : public ::google::protobuf::Message {
 public:
  CreateRoomACK();
  virtual ~CreateRoomACK();
  
  CreateRoomACK(const CreateRoomACK& from);
  
  inline CreateRoomACK& operator=(const CreateRoomACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomACK& default_instance();
  
  void Swap(CreateRoomACK* other);
  
  // implements Message ----------------------------------------------
  
  CreateRoomACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomACK& from);
  void MergeFrom(const CreateRoomACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .rpc.RoomInfo room = 1;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 1;
  inline const ::rpc::RoomInfo& room() const;
  inline ::rpc::RoomInfo* mutable_room();
  inline ::rpc::RoomInfo* release_room();
  
  // required int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.CreateRoomACK)
 private:
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_code();
  inline void clear_has_code();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::RoomInfo* room_;
  ::google::protobuf::int32 code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static CreateRoomACK* default_instance_;
};
// -------------------------------------------------------------------

class RoomListREQ : public ::google::protobuf::Message {
 public:
  RoomListREQ();
  virtual ~RoomListREQ();
  
  RoomListREQ(const RoomListREQ& from);
  
  inline RoomListREQ& operator=(const RoomListREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListREQ& default_instance();
  
  void Swap(RoomListREQ* other);
  
  // implements Message ----------------------------------------------
  
  RoomListREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListREQ& from);
  void MergeFrom(const RoomListREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:rpc.RoomListREQ)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static RoomListREQ* default_instance_;
};
// -------------------------------------------------------------------

class RoomListACK : public ::google::protobuf::Message {
 public:
  RoomListACK();
  virtual ~RoomListACK();
  
  RoomListACK(const RoomListACK& from);
  
  inline RoomListACK& operator=(const RoomListACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListACK& default_instance();
  
  void Swap(RoomListACK* other);
  
  // implements Message ----------------------------------------------
  
  RoomListACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListACK& from);
  void MergeFrom(const RoomListACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.RoomInfo roomList = 1;
  inline int roomlist_size() const;
  inline void clear_roomlist();
  static const int kRoomListFieldNumber = 1;
  inline const ::rpc::RoomInfo& roomlist(int index) const;
  inline ::rpc::RoomInfo* mutable_roomlist(int index);
  inline ::rpc::RoomInfo* add_roomlist();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::RoomInfo >&
      roomlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::RoomInfo >*
      mutable_roomlist();
  
  // @@protoc_insertion_point(class_scope:rpc.RoomListACK)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::RoomInfo > roomlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static RoomListACK* default_instance_;
};
// -------------------------------------------------------------------

class JieSanRoomREQ : public ::google::protobuf::Message {
 public:
  JieSanRoomREQ();
  virtual ~JieSanRoomREQ();
  
  JieSanRoomREQ(const JieSanRoomREQ& from);
  
  inline JieSanRoomREQ& operator=(const JieSanRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JieSanRoomREQ& default_instance();
  
  void Swap(JieSanRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  JieSanRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JieSanRoomREQ& from);
  void MergeFrom(const JieSanRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 operatorStatus = 3;
  inline bool has_operatorstatus() const;
  inline void clear_operatorstatus();
  static const int kOperatorStatusFieldNumber = 3;
  inline ::google::protobuf::int32 operatorstatus() const;
  inline void set_operatorstatus(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.JieSanRoomREQ)
 private:
  inline void set_has_operatorstatus();
  inline void clear_has_operatorstatus();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 operatorstatus_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static JieSanRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class JieSanPlayerInfo : public ::google::protobuf::Message {
 public:
  JieSanPlayerInfo();
  virtual ~JieSanPlayerInfo();
  
  JieSanPlayerInfo(const JieSanPlayerInfo& from);
  
  inline JieSanPlayerInfo& operator=(const JieSanPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JieSanPlayerInfo& default_instance();
  
  void Swap(JieSanPlayerInfo* other);
  
  // implements Message ----------------------------------------------
  
  JieSanPlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JieSanPlayerInfo& from);
  void MergeFrom(const JieSanPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // required int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.JieSanPlayerInfo)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  ::google::protobuf::int32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static JieSanPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class JieSanRoomNotify : public ::google::protobuf::Message {
 public:
  JieSanRoomNotify();
  virtual ~JieSanRoomNotify();
  
  JieSanRoomNotify(const JieSanRoomNotify& from);
  
  inline JieSanRoomNotify& operator=(const JieSanRoomNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JieSanRoomNotify& default_instance();
  
  void Swap(JieSanRoomNotify* other);
  
  // implements Message ----------------------------------------------
  
  JieSanRoomNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JieSanRoomNotify& from);
  void MergeFrom(const JieSanRoomNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.JieSanPlayerInfo jieSanPlayerInfo = 1;
  inline int jiesanplayerinfo_size() const;
  inline void clear_jiesanplayerinfo();
  static const int kJieSanPlayerInfoFieldNumber = 1;
  inline const ::rpc::JieSanPlayerInfo& jiesanplayerinfo(int index) const;
  inline ::rpc::JieSanPlayerInfo* mutable_jiesanplayerinfo(int index);
  inline ::rpc::JieSanPlayerInfo* add_jiesanplayerinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::JieSanPlayerInfo >&
      jiesanplayerinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::JieSanPlayerInfo >*
      mutable_jiesanplayerinfo();
  
  // required int32 remainTime = 3;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 3;
  inline ::google::protobuf::int32 remaintime() const;
  inline void set_remaintime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.JieSanRoomNotify)
 private:
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::JieSanPlayerInfo > jiesanplayerinfo_;
  ::google::protobuf::int32 remaintime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static JieSanRoomNotify* default_instance_;
};
// -------------------------------------------------------------------

class JieSanRoomUpdateStatusNotify : public ::google::protobuf::Message {
 public:
  JieSanRoomUpdateStatusNotify();
  virtual ~JieSanRoomUpdateStatusNotify();
  
  JieSanRoomUpdateStatusNotify(const JieSanRoomUpdateStatusNotify& from);
  
  inline JieSanRoomUpdateStatusNotify& operator=(const JieSanRoomUpdateStatusNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JieSanRoomUpdateStatusNotify& default_instance();
  
  void Swap(JieSanRoomUpdateStatusNotify* other);
  
  // implements Message ----------------------------------------------
  
  JieSanRoomUpdateStatusNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JieSanRoomUpdateStatusNotify& from);
  void MergeFrom(const JieSanRoomUpdateStatusNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .rpc.JieSanPlayerInfo jieSanPlayerInfo = 1;
  inline bool has_jiesanplayerinfo() const;
  inline void clear_jiesanplayerinfo();
  static const int kJieSanPlayerInfoFieldNumber = 1;
  inline const ::rpc::JieSanPlayerInfo& jiesanplayerinfo() const;
  inline ::rpc::JieSanPlayerInfo* mutable_jiesanplayerinfo();
  inline ::rpc::JieSanPlayerInfo* release_jiesanplayerinfo();
  
  // @@protoc_insertion_point(class_scope:rpc.JieSanRoomUpdateStatusNotify)
 private:
  inline void set_has_jiesanplayerinfo();
  inline void clear_has_jiesanplayerinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::JieSanPlayerInfo* jiesanplayerinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static JieSanRoomUpdateStatusNotify* default_instance_;
};
// -------------------------------------------------------------------

class EnterCustomRoomREQ : public ::google::protobuf::Message {
 public:
  EnterCustomRoomREQ();
  virtual ~EnterCustomRoomREQ();
  
  EnterCustomRoomREQ(const EnterCustomRoomREQ& from);
  
  inline EnterCustomRoomREQ& operator=(const EnterCustomRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterCustomRoomREQ& default_instance();
  
  void Swap(EnterCustomRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  EnterCustomRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterCustomRoomREQ& from);
  void MergeFrom(const EnterCustomRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string gameType = 1;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 1;
  inline const ::std::string& gametype() const;
  inline void set_gametype(const ::std::string& value);
  inline void set_gametype(const char* value);
  inline void set_gametype(const char* value, size_t size);
  inline ::std::string* mutable_gametype();
  inline ::std::string* release_gametype();
  
  // required int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string pwd = 4;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 4;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  
  // @@protoc_insertion_point(class_scope:rpc.EnterCustomRoomREQ)
 private:
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* gametype_;
  ::std::string* pwd_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static EnterCustomRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class EnterCustomRoomACK : public ::google::protobuf::Message {
 public:
  EnterCustomRoomACK();
  virtual ~EnterCustomRoomACK();
  
  EnterCustomRoomACK(const EnterCustomRoomACK& from);
  
  inline EnterCustomRoomACK& operator=(const EnterCustomRoomACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterCustomRoomACK& default_instance();
  
  void Swap(EnterCustomRoomACK* other);
  
  // implements Message ----------------------------------------------
  
  EnterCustomRoomACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterCustomRoomACK& from);
  void MergeFrom(const EnterCustomRoomACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .rpc.PlayerBaseInfo playerInfo = 1;
  inline bool has_playerinfo() const;
  inline void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 1;
  inline const ::rpc::PlayerBaseInfo& playerinfo() const;
  inline ::rpc::PlayerBaseInfo* mutable_playerinfo();
  inline ::rpc::PlayerBaseInfo* release_playerinfo();
  
  // optional int32 shangjiaType = 2;
  inline bool has_shangjiatype() const;
  inline void clear_shangjiatype();
  static const int kShangjiaTypeFieldNumber = 2;
  inline ::google::protobuf::int32 shangjiatype() const;
  inline void set_shangjiatype(::google::protobuf::int32 value);
  
  // optional int32 location = 20;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 20;
  inline ::google::protobuf::int32 location() const;
  inline void set_location(::google::protobuf::int32 value);
  
  // optional bool bReady = 3;
  inline bool has_bready() const;
  inline void clear_bready();
  static const int kBReadyFieldNumber = 3;
  inline bool bready() const;
  inline void set_bready(bool value);
  
  // optional int32 code = 4;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 4;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // optional int32 roomId = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 5;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // optional int32 gameType = 6;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 6;
  inline ::google::protobuf::int32 gametype() const;
  inline void set_gametype(::google::protobuf::int32 value);
  
  // optional int32 times = 7;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 7;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);
  
  // optional int32 curTimes = 8;
  inline bool has_curtimes() const;
  inline void clear_curtimes();
  static const int kCurTimesFieldNumber = 8;
  inline ::google::protobuf::int32 curtimes() const;
  inline void set_curtimes(::google::protobuf::int32 value);
  
  // optional bool isOwner = 9;
  inline bool has_isowner() const;
  inline void clear_isowner();
  static const int kIsOwnerFieldNumber = 9;
  inline bool isowner() const;
  inline void set_isowner(bool value);
  
  // optional int32 currencyType = 10;
  inline bool has_currencytype() const;
  inline void clear_currencytype();
  static const int kCurrencyTypeFieldNumber = 10;
  inline ::google::protobuf::int32 currencytype() const;
  inline void set_currencytype(::google::protobuf::int32 value);
  
  // optional int32 difen = 11;
  inline bool has_difen() const;
  inline void clear_difen();
  static const int kDifenFieldNumber = 11;
  inline ::google::protobuf::int32 difen() const;
  inline void set_difen(::google::protobuf::int32 value);
  
  // optional int32 qiHuKeAmount = 12;
  inline bool has_qihukeamount() const;
  inline void clear_qihukeamount();
  static const int kQiHuKeAmountFieldNumber = 12;
  inline ::google::protobuf::int32 qihukeamount() const;
  inline void set_qihukeamount(::google::protobuf::int32 value);
  
  // optional int32 tiYongAmount = 13;
  inline bool has_tiyongamount() const;
  inline void clear_tiyongamount();
  static const int kTiYongAmountFieldNumber = 13;
  inline ::google::protobuf::int32 tiyongamount() const;
  inline void set_tiyongamount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.EnterCustomRoomACK)
 private:
  inline void set_has_playerinfo();
  inline void clear_has_playerinfo();
  inline void set_has_shangjiatype();
  inline void clear_has_shangjiatype();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_bready();
  inline void clear_has_bready();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_curtimes();
  inline void clear_has_curtimes();
  inline void set_has_isowner();
  inline void clear_has_isowner();
  inline void set_has_currencytype();
  inline void clear_has_currencytype();
  inline void set_has_difen();
  inline void clear_has_difen();
  inline void set_has_qihukeamount();
  inline void clear_has_qihukeamount();
  inline void set_has_tiyongamount();
  inline void clear_has_tiyongamount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::PlayerBaseInfo* playerinfo_;
  ::google::protobuf::int32 shangjiatype_;
  ::google::protobuf::int32 location_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 gametype_;
  bool bready_;
  bool isowner_;
  ::google::protobuf::int32 times_;
  ::google::protobuf::int32 curtimes_;
  ::google::protobuf::int32 currencytype_;
  ::google::protobuf::int32 difen_;
  ::google::protobuf::int32 qihukeamount_;
  ::google::protobuf::int32 tiyongamount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static EnterCustomRoomACK* default_instance_;
};
// -------------------------------------------------------------------

class LeaveCustomRoomREQ : public ::google::protobuf::Message {
 public:
  LeaveCustomRoomREQ();
  virtual ~LeaveCustomRoomREQ();
  
  LeaveCustomRoomREQ(const LeaveCustomRoomREQ& from);
  
  inline LeaveCustomRoomREQ& operator=(const LeaveCustomRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveCustomRoomREQ& default_instance();
  
  void Swap(LeaveCustomRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  LeaveCustomRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveCustomRoomREQ& from);
  void MergeFrom(const LeaveCustomRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // @@protoc_insertion_point(class_scope:rpc.LeaveCustomRoomREQ)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static LeaveCustomRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class LeaveCustomRoomACK : public ::google::protobuf::Message {
 public:
  LeaveCustomRoomACK();
  virtual ~LeaveCustomRoomACK();
  
  LeaveCustomRoomACK(const LeaveCustomRoomACK& from);
  
  inline LeaveCustomRoomACK& operator=(const LeaveCustomRoomACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveCustomRoomACK& default_instance();
  
  void Swap(LeaveCustomRoomACK* other);
  
  // implements Message ----------------------------------------------
  
  LeaveCustomRoomACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveCustomRoomACK& from);
  void MergeFrom(const LeaveCustomRoomACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // @@protoc_insertion_point(class_scope:rpc.LeaveCustomRoomACK)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static LeaveCustomRoomACK* default_instance_;
};
// -------------------------------------------------------------------

class FindRoomREQ : public ::google::protobuf::Message {
 public:
  FindRoomREQ();
  virtual ~FindRoomREQ();
  
  FindRoomREQ(const FindRoomREQ& from);
  
  inline FindRoomREQ& operator=(const FindRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FindRoomREQ& default_instance();
  
  void Swap(FindRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  FindRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FindRoomREQ& from);
  void MergeFrom(const FindRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:rpc.FindRoomREQ)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FindRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class FindRoomACK : public ::google::protobuf::Message {
 public:
  FindRoomACK();
  virtual ~FindRoomACK();
  
  FindRoomACK(const FindRoomACK& from);
  
  inline FindRoomACK& operator=(const FindRoomACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FindRoomACK& default_instance();
  
  void Swap(FindRoomACK* other);
  
  // implements Message ----------------------------------------------
  
  FindRoomACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FindRoomACK& from);
  void MergeFrom(const FindRoomACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .rpc.RoomInfo room = 1;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 1;
  inline const ::rpc::RoomInfo& room() const;
  inline ::rpc::RoomInfo* mutable_room();
  inline ::rpc::RoomInfo* release_room();
  
  // required int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.FindRoomACK)
 private:
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_code();
  inline void clear_has_code();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::RoomInfo* room_;
  ::google::protobuf::int32 code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static FindRoomACK* default_instance_;
};
// -------------------------------------------------------------------

class ForceLeaveRoomREQ : public ::google::protobuf::Message {
 public:
  ForceLeaveRoomREQ();
  virtual ~ForceLeaveRoomREQ();
  
  ForceLeaveRoomREQ(const ForceLeaveRoomREQ& from);
  
  inline ForceLeaveRoomREQ& operator=(const ForceLeaveRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ForceLeaveRoomREQ& default_instance();
  
  void Swap(ForceLeaveRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  ForceLeaveRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForceLeaveRoomREQ& from);
  void MergeFrom(const ForceLeaveRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required int32 sysType = 2;
  inline bool has_systype() const;
  inline void clear_systype();
  static const int kSysTypeFieldNumber = 2;
  inline ::google::protobuf::int32 systype() const;
  inline void set_systype(::google::protobuf::int32 value);
  
  // required int32 gameType = 3;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 3;
  inline ::google::protobuf::int32 gametype() const;
  inline void set_gametype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.ForceLeaveRoomREQ)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_systype();
  inline void clear_has_systype();
  inline void set_has_gametype();
  inline void clear_has_gametype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::int32 systype_;
  ::google::protobuf::int32 gametype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ForceLeaveRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class InviteFirendsJionCustomRoomREQ : public ::google::protobuf::Message {
 public:
  InviteFirendsJionCustomRoomREQ();
  virtual ~InviteFirendsJionCustomRoomREQ();
  
  InviteFirendsJionCustomRoomREQ(const InviteFirendsJionCustomRoomREQ& from);
  
  inline InviteFirendsJionCustomRoomREQ& operator=(const InviteFirendsJionCustomRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InviteFirendsJionCustomRoomREQ& default_instance();
  
  void Swap(InviteFirendsJionCustomRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  InviteFirendsJionCustomRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InviteFirendsJionCustomRoomREQ& from);
  void MergeFrom(const InviteFirendsJionCustomRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string playerID = 1;
  inline int playerid_size() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid(int index) const;
  inline ::std::string* mutable_playerid(int index);
  inline void set_playerid(int index, const ::std::string& value);
  inline void set_playerid(int index, const char* value);
  inline void set_playerid(int index, const char* value, size_t size);
  inline ::std::string* add_playerid();
  inline void add_playerid(const ::std::string& value);
  inline void add_playerid(const char* value);
  inline void add_playerid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& playerid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_playerid();
  
  // optional int32 currencyType = 2;
  inline bool has_currencytype() const;
  inline void clear_currencytype();
  static const int kCurrencyTypeFieldNumber = 2;
  inline ::google::protobuf::int32 currencytype() const;
  inline void set_currencytype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.InviteFirendsJionCustomRoomREQ)
 private:
  inline void set_has_currencytype();
  inline void clear_has_currencytype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> playerid_;
  ::google::protobuf::int32 currencytype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static InviteFirendsJionCustomRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class InviteFirendsJionCustomRoomNotify : public ::google::protobuf::Message {
 public:
  InviteFirendsJionCustomRoomNotify();
  virtual ~InviteFirendsJionCustomRoomNotify();
  
  InviteFirendsJionCustomRoomNotify(const InviteFirendsJionCustomRoomNotify& from);
  
  inline InviteFirendsJionCustomRoomNotify& operator=(const InviteFirendsJionCustomRoomNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InviteFirendsJionCustomRoomNotify& default_instance();
  
  void Swap(InviteFirendsJionCustomRoomNotify* other);
  
  // implements Message ----------------------------------------------
  
  InviteFirendsJionCustomRoomNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InviteFirendsJionCustomRoomNotify& from);
  void MergeFrom(const InviteFirendsJionCustomRoomNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // optional string gameType = 2;
  inline bool has_gametype() const;
  inline void clear_gametype();
  static const int kGameTypeFieldNumber = 2;
  inline const ::std::string& gametype() const;
  inline void set_gametype(const ::std::string& value);
  inline void set_gametype(const char* value);
  inline void set_gametype(const char* value, size_t size);
  inline ::std::string* mutable_gametype();
  inline ::std::string* release_gametype();
  
  // optional int32 roomID = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 3;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // optional string invitePlayerName = 4;
  inline bool has_inviteplayername() const;
  inline void clear_inviteplayername();
  static const int kInvitePlayerNameFieldNumber = 4;
  inline const ::std::string& inviteplayername() const;
  inline void set_inviteplayername(const ::std::string& value);
  inline void set_inviteplayername(const char* value);
  inline void set_inviteplayername(const char* value, size_t size);
  inline ::std::string* mutable_inviteplayername();
  inline ::std::string* release_inviteplayername();
  
  // optional int32 currencyType = 5;
  inline bool has_currencytype() const;
  inline void clear_currencytype();
  static const int kCurrencyTypeFieldNumber = 5;
  inline ::google::protobuf::int32 currencytype() const;
  inline void set_currencytype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.InviteFirendsJionCustomRoomNotify)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_gametype();
  inline void clear_has_gametype();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_inviteplayername();
  inline void clear_has_inviteplayername();
  inline void set_has_currencytype();
  inline void clear_has_currencytype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* gametype_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 roomid_;
  ::std::string* inviteplayername_;
  ::google::protobuf::int32 currencytype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static InviteFirendsJionCustomRoomNotify* default_instance_;
};
// -------------------------------------------------------------------

class OtherPlayerInfo : public ::google::protobuf::Message {
 public:
  OtherPlayerInfo();
  virtual ~OtherPlayerInfo();
  
  OtherPlayerInfo(const OtherPlayerInfo& from);
  
  inline OtherPlayerInfo& operator=(const OtherPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OtherPlayerInfo& default_instance();
  
  void Swap(OtherPlayerInfo* other);
  
  // implements Message ----------------------------------------------
  
  OtherPlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtherPlayerInfo& from);
  void MergeFrom(const OtherPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);
  
  // required int32 userName = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 2;
  inline ::google::protobuf::int32 username() const;
  inline void set_username(::google::protobuf::int32 value);
  
  // optional int32 userHeadID = 3;
  inline bool has_userheadid() const;
  inline void clear_userheadid();
  static const int kUserHeadIDFieldNumber = 3;
  inline ::google::protobuf::int32 userheadid() const;
  inline void set_userheadid(::google::protobuf::int32 value);
  
  // optional int32 userwechatHeadURL = 4;
  inline bool has_userwechatheadurl() const;
  inline void clear_userwechatheadurl();
  static const int kUserwechatHeadURLFieldNumber = 4;
  inline ::google::protobuf::int32 userwechatheadurl() const;
  inline void set_userwechatheadurl(::google::protobuf::int32 value);
  
  // optional int32 winNum = 5;
  inline bool has_winnum() const;
  inline void clear_winnum();
  static const int kWinNumFieldNumber = 5;
  inline ::google::protobuf::int32 winnum() const;
  inline void set_winnum(::google::protobuf::int32 value);
  
  // optional int32 loseNum = 6;
  inline bool has_losenum() const;
  inline void clear_losenum();
  static const int kLoseNumFieldNumber = 6;
  inline ::google::protobuf::int32 losenum() const;
  inline void set_losenum(::google::protobuf::int32 value);
  
  // optional int32 lv = 7;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 7;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);
  
  // optional int32 coin = 8;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 8;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.OtherPlayerInfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_userheadid();
  inline void clear_has_userheadid();
  inline void set_has_userwechatheadurl();
  inline void clear_has_userwechatheadurl();
  inline void set_has_winnum();
  inline void clear_has_winnum();
  inline void set_has_losenum();
  inline void clear_has_losenum();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_coin();
  inline void clear_has_coin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 username_;
  ::google::protobuf::int32 userheadid_;
  ::google::protobuf::int32 userwechatheadurl_;
  ::google::protobuf::int32 winnum_;
  ::google::protobuf::int32 losenum_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 coin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static OtherPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class OtherPlayerInfoREQ : public ::google::protobuf::Message {
 public:
  OtherPlayerInfoREQ();
  virtual ~OtherPlayerInfoREQ();
  
  OtherPlayerInfoREQ(const OtherPlayerInfoREQ& from);
  
  inline OtherPlayerInfoREQ& operator=(const OtherPlayerInfoREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OtherPlayerInfoREQ& default_instance();
  
  void Swap(OtherPlayerInfoREQ* other);
  
  // implements Message ----------------------------------------------
  
  OtherPlayerInfoREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtherPlayerInfoREQ& from);
  void MergeFrom(const OtherPlayerInfoREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // @@protoc_insertion_point(class_scope:rpc.OtherPlayerInfoREQ)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static OtherPlayerInfoREQ* default_instance_;
};
// -------------------------------------------------------------------

class MatchListREQ : public ::google::protobuf::Message {
 public:
  MatchListREQ();
  virtual ~MatchListREQ();
  
  MatchListREQ(const MatchListREQ& from);
  
  inline MatchListREQ& operator=(const MatchListREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchListREQ& default_instance();
  
  void Swap(MatchListREQ* other);
  
  // implements Message ----------------------------------------------
  
  MatchListREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchListREQ& from);
  void MergeFrom(const MatchListREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:rpc.MatchListREQ)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MatchListREQ* default_instance_;
};
// -------------------------------------------------------------------

class MatchListACK : public ::google::protobuf::Message {
 public:
  MatchListACK();
  virtual ~MatchListACK();
  
  MatchListACK(const MatchListACK& from);
  
  inline MatchListACK& operator=(const MatchListACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchListACK& default_instance();
  
  void Swap(MatchListACK* other);
  
  // implements Message ----------------------------------------------
  
  MatchListACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchListACK& from);
  void MergeFrom(const MatchListACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.Match matches = 1;
  inline int matches_size() const;
  inline void clear_matches();
  static const int kMatchesFieldNumber = 1;
  inline const ::rpc::Match& matches(int index) const;
  inline ::rpc::Match* mutable_matches(int index);
  inline ::rpc::Match* add_matches();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Match >&
      matches() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Match >*
      mutable_matches();
  
  // @@protoc_insertion_point(class_scope:rpc.MatchListACK)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::Match > matches_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static MatchListACK* default_instance_;
};
// -------------------------------------------------------------------

class Match : public ::google::protobuf::Message {
 public:
  Match();
  virtual ~Match();
  
  Match(const Match& from);
  
  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Match& default_instance();
  
  void Swap(Match* other);
  
  // implements Message ----------------------------------------------
  
  Match* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Match& from);
  void MergeFrom(const Match& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 enrollAmount = 2;
  inline bool has_enrollamount() const;
  inline void clear_enrollamount();
  static const int kEnrollAmountFieldNumber = 2;
  inline ::google::protobuf::int32 enrollamount() const;
  inline void set_enrollamount(::google::protobuf::int32 value);
  
  // optional int64 countdown = 3;
  inline bool has_countdown() const;
  inline void clear_countdown();
  static const int kCountdownFieldNumber = 3;
  inline ::google::protobuf::int64 countdown() const;
  inline void set_countdown(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:rpc.Match)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_enrollamount();
  inline void clear_has_enrollamount();
  inline void set_has_countdown();
  inline void clear_has_countdown();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 enrollamount_;
  ::google::protobuf::int64 countdown_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Match* default_instance_;
};
// -------------------------------------------------------------------

class EnrollREQ : public ::google::protobuf::Message {
 public:
  EnrollREQ();
  virtual ~EnrollREQ();
  
  EnrollREQ(const EnrollREQ& from);
  
  inline EnrollREQ& operator=(const EnrollREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnrollREQ& default_instance();
  
  void Swap(EnrollREQ* other);
  
  // implements Message ----------------------------------------------
  
  EnrollREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnrollREQ& from);
  void MergeFrom(const EnrollREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.EnrollREQ)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static EnrollREQ* default_instance_;
};
// -------------------------------------------------------------------

class EnrollACK : public ::google::protobuf::Message {
 public:
  EnrollACK();
  virtual ~EnrollACK();
  
  EnrollACK(const EnrollACK& from);
  
  inline EnrollACK& operator=(const EnrollACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnrollACK& default_instance();
  
  void Swap(EnrollACK* other);
  
  // implements Message ----------------------------------------------
  
  EnrollACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnrollACK& from);
  void MergeFrom(const EnrollACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.EnrollACK)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static EnrollACK* default_instance_;
};
// -------------------------------------------------------------------

class WithdrawREQ : public ::google::protobuf::Message {
 public:
  WithdrawREQ();
  virtual ~WithdrawREQ();
  
  WithdrawREQ(const WithdrawREQ& from);
  
  inline WithdrawREQ& operator=(const WithdrawREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WithdrawREQ& default_instance();
  
  void Swap(WithdrawREQ* other);
  
  // implements Message ----------------------------------------------
  
  WithdrawREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WithdrawREQ& from);
  void MergeFrom(const WithdrawREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.WithdrawREQ)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static WithdrawREQ* default_instance_;
};
// -------------------------------------------------------------------

class WithdrawACK : public ::google::protobuf::Message {
 public:
  WithdrawACK();
  virtual ~WithdrawACK();
  
  WithdrawACK(const WithdrawACK& from);
  
  inline WithdrawACK& operator=(const WithdrawACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WithdrawACK& default_instance();
  
  void Swap(WithdrawACK* other);
  
  // implements Message ----------------------------------------------
  
  WithdrawACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WithdrawACK& from);
  void MergeFrom(const WithdrawACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.WithdrawACK)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static WithdrawACK* default_instance_;
};
// -------------------------------------------------------------------

class AmountChangeNotifyACK : public ::google::protobuf::Message {
 public:
  AmountChangeNotifyACK();
  virtual ~AmountChangeNotifyACK();
  
  AmountChangeNotifyACK(const AmountChangeNotifyACK& from);
  
  inline AmountChangeNotifyACK& operator=(const AmountChangeNotifyACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AmountChangeNotifyACK& default_instance();
  
  void Swap(AmountChangeNotifyACK* other);
  
  // implements Message ----------------------------------------------
  
  AmountChangeNotifyACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AmountChangeNotifyACK& from);
  void MergeFrom(const AmountChangeNotifyACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.Match matches = 1;
  inline int matches_size() const;
  inline void clear_matches();
  static const int kMatchesFieldNumber = 1;
  inline const ::rpc::Match& matches(int index) const;
  inline ::rpc::Match* mutable_matches(int index);
  inline ::rpc::Match* add_matches();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Match >&
      matches() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Match >*
      mutable_matches();
  
  // @@protoc_insertion_point(class_scope:rpc.AmountChangeNotifyACK)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::Match > matches_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static AmountChangeNotifyACK* default_instance_;
};
// -------------------------------------------------------------------

class StartEntranceACK : public ::google::protobuf::Message {
 public:
  StartEntranceACK();
  virtual ~StartEntranceACK();
  
  StartEntranceACK(const StartEntranceACK& from);
  
  inline StartEntranceACK& operator=(const StartEntranceACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartEntranceACK& default_instance();
  
  void Swap(StartEntranceACK* other);
  
  // implements Message ----------------------------------------------
  
  StartEntranceACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartEntranceACK& from);
  void MergeFrom(const StartEntranceACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .rpc.Match match = 1;
  inline bool has_match() const;
  inline void clear_match();
  static const int kMatchFieldNumber = 1;
  inline const ::rpc::Match& match() const;
  inline ::rpc::Match* mutable_match();
  inline ::rpc::Match* release_match();
  
  // @@protoc_insertion_point(class_scope:rpc.StartEntranceACK)
 private:
  inline void set_has_match();
  inline void clear_has_match();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpc::Match* match_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static StartEntranceACK* default_instance_;
};
// -------------------------------------------------------------------

class OrderInfoNofity : public ::google::protobuf::Message {
 public:
  OrderInfoNofity();
  virtual ~OrderInfoNofity();
  
  OrderInfoNofity(const OrderInfoNofity& from);
  
  inline OrderInfoNofity& operator=(const OrderInfoNofity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderInfoNofity& default_instance();
  
  void Swap(OrderInfoNofity* other);
  
  // implements Message ----------------------------------------------
  
  OrderInfoNofity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderInfoNofity& from);
  void MergeFrom(const OrderInfoNofity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string partnerId = 1;
  inline bool has_partnerid() const;
  inline void clear_partnerid();
  static const int kPartnerIdFieldNumber = 1;
  inline const ::std::string& partnerid() const;
  inline void set_partnerid(const ::std::string& value);
  inline void set_partnerid(const char* value);
  inline void set_partnerid(const char* value, size_t size);
  inline ::std::string* mutable_partnerid();
  inline ::std::string* release_partnerid();
  
  // optional string prepayId = 2;
  inline bool has_prepayid() const;
  inline void clear_prepayid();
  static const int kPrepayIdFieldNumber = 2;
  inline const ::std::string& prepayid() const;
  inline void set_prepayid(const ::std::string& value);
  inline void set_prepayid(const char* value);
  inline void set_prepayid(const char* value, size_t size);
  inline ::std::string* mutable_prepayid();
  inline ::std::string* release_prepayid();
  
  // optional string package = 3;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 3;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  
  // optional string nonceStr = 4;
  inline bool has_noncestr() const;
  inline void clear_noncestr();
  static const int kNonceStrFieldNumber = 4;
  inline const ::std::string& noncestr() const;
  inline void set_noncestr(const ::std::string& value);
  inline void set_noncestr(const char* value);
  inline void set_noncestr(const char* value, size_t size);
  inline ::std::string* mutable_noncestr();
  inline ::std::string* release_noncestr();
  
  // optional int32 timeStamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 5;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);
  
  // optional string sign = 6;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 6;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  
  // optional string appId = 7;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 7;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  
  // @@protoc_insertion_point(class_scope:rpc.OrderInfoNofity)
 private:
  inline void set_has_partnerid();
  inline void clear_has_partnerid();
  inline void set_has_prepayid();
  inline void clear_has_prepayid();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_noncestr();
  inline void clear_has_noncestr();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_appid();
  inline void clear_has_appid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* partnerid_;
  ::std::string* prepayid_;
  ::std::string* package_;
  ::std::string* noncestr_;
  ::std::string* sign_;
  ::std::string* appid_;
  ::google::protobuf::int32 timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static OrderInfoNofity* default_instance_;
};
// -------------------------------------------------------------------

class PayResultNotify : public ::google::protobuf::Message {
 public:
  PayResultNotify();
  virtual ~PayResultNotify();
  
  PayResultNotify(const PayResultNotify& from);
  
  inline PayResultNotify& operator=(const PayResultNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PayResultNotify& default_instance();
  
  void Swap(PayResultNotify* other);
  
  // implements Message ----------------------------------------------
  
  PayResultNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayResultNotify& from);
  void MergeFrom(const PayResultNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string partnerId = 1;
  inline bool has_partnerid() const;
  inline void clear_partnerid();
  static const int kPartnerIdFieldNumber = 1;
  inline const ::std::string& partnerid() const;
  inline void set_partnerid(const ::std::string& value);
  inline void set_partnerid(const char* value);
  inline void set_partnerid(const char* value, size_t size);
  inline ::std::string* mutable_partnerid();
  inline ::std::string* release_partnerid();
  
  // optional bool result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline bool result() const;
  inline void set_result(bool value);
  
  // optional string error_desc = 3;
  inline bool has_error_desc() const;
  inline void clear_error_desc();
  static const int kErrorDescFieldNumber = 3;
  inline const ::std::string& error_desc() const;
  inline void set_error_desc(const ::std::string& value);
  inline void set_error_desc(const char* value);
  inline void set_error_desc(const char* value, size_t size);
  inline ::std::string* mutable_error_desc();
  inline ::std::string* release_error_desc();
  
  // optional int32 vipDay = 4;
  inline bool has_vipday() const;
  inline void clear_vipday();
  static const int kVipDayFieldNumber = 4;
  inline ::google::protobuf::int32 vipday() const;
  inline void set_vipday(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.PayResultNotify)
 private:
  inline void set_has_partnerid();
  inline void clear_has_partnerid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_error_desc();
  inline void clear_has_error_desc();
  inline void set_has_vipday();
  inline void clear_has_vipday();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* partnerid_;
  ::std::string* error_desc_;
  bool result_;
  ::google::protobuf::int32 vipday_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PayResultNotify* default_instance_;
};
// -------------------------------------------------------------------

class PokerQuickEnterRoomREQ : public ::google::protobuf::Message {
 public:
  PokerQuickEnterRoomREQ();
  virtual ~PokerQuickEnterRoomREQ();
  
  PokerQuickEnterRoomREQ(const PokerQuickEnterRoomREQ& from);
  
  inline PokerQuickEnterRoomREQ& operator=(const PokerQuickEnterRoomREQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PokerQuickEnterRoomREQ& default_instance();
  
  void Swap(PokerQuickEnterRoomREQ* other);
  
  // implements Message ----------------------------------------------
  
  PokerQuickEnterRoomREQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PokerQuickEnterRoomREQ& from);
  void MergeFrom(const PokerQuickEnterRoomREQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:rpc.PokerQuickEnterRoomREQ)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PokerQuickEnterRoomREQ* default_instance_;
};
// -------------------------------------------------------------------

class CreatePockerRoomReq : public ::google::protobuf::Message {
 public:
  CreatePockerRoomReq();
  virtual ~CreatePockerRoomReq();
  
  CreatePockerRoomReq(const CreatePockerRoomReq& from);
  
  inline CreatePockerRoomReq& operator=(const CreatePockerRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePockerRoomReq& default_instance();
  
  void Swap(CreatePockerRoomReq* other);
  
  // implements Message ----------------------------------------------
  
  CreatePockerRoomReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePockerRoomReq& from);
  void MergeFrom(const CreatePockerRoomReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional int32 BlindId = 2;
  inline bool has_blindid() const;
  inline void clear_blindid();
  static const int kBlindIdFieldNumber = 2;
  inline ::google::protobuf::int32 blindid() const;
  inline void set_blindid(::google::protobuf::int32 value);
  
  // optional int32 LimId = 3;
  inline bool has_limid() const;
  inline void clear_limid();
  static const int kLimIdFieldNumber = 3;
  inline ::google::protobuf::int32 limid() const;
  inline void set_limid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.CreatePockerRoomReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_blindid();
  inline void clear_has_blindid();
  inline void set_has_limid();
  inline void clear_has_limid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::google::protobuf::int32 blindid_;
  ::google::protobuf::int32 limid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static CreatePockerRoomReq* default_instance_;
};
// -------------------------------------------------------------------

class CreatePockerRoomAck : public ::google::protobuf::Message {
 public:
  CreatePockerRoomAck();
  virtual ~CreatePockerRoomAck();
  
  CreatePockerRoomAck(const CreatePockerRoomAck& from);
  
  inline CreatePockerRoomAck& operator=(const CreatePockerRoomAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePockerRoomAck& default_instance();
  
  void Swap(CreatePockerRoomAck* other);
  
  // implements Message ----------------------------------------------
  
  CreatePockerRoomAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePockerRoomAck& from);
  void MergeFrom(const CreatePockerRoomAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 roomNo = 1;
  inline bool has_roomno() const;
  inline void clear_roomno();
  static const int kRoomNoFieldNumber = 1;
  inline ::google::protobuf::int32 roomno() const;
  inline void set_roomno(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.CreatePockerRoomAck)
 private:
  inline void set_has_roomno();
  inline void clear_has_roomno();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 roomno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static CreatePockerRoomAck* default_instance_;
};
// -------------------------------------------------------------------

class C2SAction : public ::google::protobuf::Message {
 public:
  C2SAction();
  virtual ~C2SAction();
  
  C2SAction(const C2SAction& from);
  
  inline C2SAction& operator=(const C2SAction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2SAction& default_instance();
  
  void Swap(C2SAction* other);
  
  // implements Message ----------------------------------------------
  
  C2SAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2SAction& from);
  void MergeFrom(const C2SAction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 act = 1;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 1;
  inline ::google::protobuf::int32 act() const;
  inline void set_act(::google::protobuf::int32 value);
  
  // optional string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional int32 raise = 3;
  inline bool has_raise() const;
  inline void clear_raise();
  static const int kRaiseFieldNumber = 3;
  inline ::google::protobuf::int32 raise() const;
  inline void set_raise(::google::protobuf::int32 value);
  
  // optional .rpc.PlayerBaseInfo base = 4;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 4;
  inline const ::rpc::PlayerBaseInfo& base() const;
  inline ::rpc::PlayerBaseInfo* mutable_base();
  inline ::rpc::PlayerBaseInfo* release_base();
  
  // @@protoc_insertion_point(class_scope:rpc.C2SAction)
 private:
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_raise();
  inline void clear_has_raise();
  inline void set_has_base();
  inline void clear_has_base();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::google::protobuf::int32 act_;
  ::google::protobuf::int32 raise_;
  ::rpc::PlayerBaseInfo* base_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static C2SAction* default_instance_;
};
// -------------------------------------------------------------------

class S2CAction : public ::google::protobuf::Message {
 public:
  S2CAction();
  virtual ~S2CAction();
  
  S2CAction(const S2CAction& from);
  
  inline S2CAction& operator=(const S2CAction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2CAction& default_instance();
  
  void Swap(S2CAction* other);
  
  // implements Message ----------------------------------------------
  
  S2CAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2CAction& from);
  void MergeFrom(const S2CAction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string operater = 1;
  inline bool has_operater() const;
  inline void clear_operater();
  static const int kOperaterFieldNumber = 1;
  inline const ::std::string& operater() const;
  inline void set_operater(const ::std::string& value);
  inline void set_operater(const char* value);
  inline void set_operater(const char* value, size_t size);
  inline ::std::string* mutable_operater();
  inline ::std::string* release_operater();
  
  // optional int32 act = 2;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 2;
  inline ::google::protobuf::int32 act() const;
  inline void set_act(::google::protobuf::int32 value);
  
  // optional int32 raise = 3;
  inline bool has_raise() const;
  inline void clear_raise();
  static const int kRaiseFieldNumber = 3;
  inline ::google::protobuf::int32 raise() const;
  inline void set_raise(::google::protobuf::int32 value);
  
  // repeated .rpc.Pocker pockers = 4;
  inline int pockers_size() const;
  inline void clear_pockers();
  static const int kPockersFieldNumber = 4;
  inline const ::rpc::Pocker& pockers(int index) const;
  inline ::rpc::Pocker* mutable_pockers(int index);
  inline ::rpc::Pocker* add_pockers();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
      pockers() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
      mutable_pockers();
  
  // optional int32 combineNum = 5;
  inline bool has_combinenum() const;
  inline void clear_combinenum();
  static const int kCombineNumFieldNumber = 5;
  inline ::google::protobuf::int32 combinenum() const;
  inline void set_combinenum(::google::protobuf::int32 value);
  
  // optional int32 countdownEnd = 6;
  inline bool has_countdownend() const;
  inline void clear_countdownend();
  static const int kCountdownEndFieldNumber = 6;
  inline ::google::protobuf::int32 countdownend() const;
  inline void set_countdownend(::google::protobuf::int32 value);
  
  // repeated int32 pots = 7;
  inline int pots_size() const;
  inline void clear_pots();
  static const int kPotsFieldNumber = 7;
  inline ::google::protobuf::int32 pots(int index) const;
  inline void set_pots(int index, ::google::protobuf::int32 value);
  inline void add_pots(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pots() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pots();
  
  // repeated string winners = 8;
  inline int winners_size() const;
  inline void clear_winners();
  static const int kWinnersFieldNumber = 8;
  inline const ::std::string& winners(int index) const;
  inline ::std::string* mutable_winners(int index);
  inline void set_winners(int index, const ::std::string& value);
  inline void set_winners(int index, const char* value);
  inline void set_winners(int index, const char* value, size_t size);
  inline ::std::string* add_winners();
  inline void add_winners(const ::std::string& value);
  inline void add_winners(const char* value);
  inline void add_winners(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& winners() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_winners();
  
  // repeated .rpc.PockerManBase infos = 9;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 9;
  inline const ::rpc::PockerManBase& infos(int index) const;
  inline ::rpc::PockerManBase* mutable_infos(int index);
  inline ::rpc::PockerManBase* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase >*
      mutable_infos();
  
  // optional .rpc.PockerBegin beginInfo = 10;
  inline bool has_begininfo() const;
  inline void clear_begininfo();
  static const int kBeginInfoFieldNumber = 10;
  inline const ::rpc::PockerBegin& begininfo() const;
  inline ::rpc::PockerBegin* mutable_begininfo();
  inline ::rpc::PockerBegin* release_begininfo();
  
  // repeated .rpc.ComparePokerPlayer comparePlayers = 11;
  inline int compareplayers_size() const;
  inline void clear_compareplayers();
  static const int kComparePlayersFieldNumber = 11;
  inline const ::rpc::ComparePokerPlayer& compareplayers(int index) const;
  inline ::rpc::ComparePokerPlayer* mutable_compareplayers(int index);
  inline ::rpc::ComparePokerPlayer* add_compareplayers();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::ComparePokerPlayer >&
      compareplayers() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::ComparePokerPlayer >*
      mutable_compareplayers();
  
  // @@protoc_insertion_point(class_scope:rpc.S2CAction)
 private:
  inline void set_has_operater();
  inline void clear_has_operater();
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_raise();
  inline void clear_has_raise();
  inline void set_has_combinenum();
  inline void clear_has_combinenum();
  inline void set_has_countdownend();
  inline void clear_has_countdownend();
  inline void set_has_begininfo();
  inline void clear_has_begininfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* operater_;
  ::google::protobuf::int32 act_;
  ::google::protobuf::int32 raise_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pocker > pockers_;
  ::google::protobuf::int32 combinenum_;
  ::google::protobuf::int32 countdownend_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pots_;
  ::google::protobuf::RepeatedPtrField< ::std::string> winners_;
  ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase > infos_;
  ::rpc::PockerBegin* begininfo_;
  ::google::protobuf::RepeatedPtrField< ::rpc::ComparePokerPlayer > compareplayers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static S2CAction* default_instance_;
};
// -------------------------------------------------------------------

class ComparePokerPlayer : public ::google::protobuf::Message {
 public:
  ComparePokerPlayer();
  virtual ~ComparePokerPlayer();
  
  ComparePokerPlayer(const ComparePokerPlayer& from);
  
  inline ComparePokerPlayer& operator=(const ComparePokerPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ComparePokerPlayer& default_instance();
  
  void Swap(ComparePokerPlayer* other);
  
  // implements Message ----------------------------------------------
  
  ComparePokerPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComparePokerPlayer& from);
  void MergeFrom(const ComparePokerPlayer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // repeated .rpc.Pocker pockers = 2;
  inline int pockers_size() const;
  inline void clear_pockers();
  static const int kPockersFieldNumber = 2;
  inline const ::rpc::Pocker& pockers(int index) const;
  inline ::rpc::Pocker* mutable_pockers(int index);
  inline ::rpc::Pocker* add_pockers();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
      pockers() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
      mutable_pockers();
  
  // repeated .rpc.Pocker combinePockers = 3;
  inline int combinepockers_size() const;
  inline void clear_combinepockers();
  static const int kCombinePockersFieldNumber = 3;
  inline const ::rpc::Pocker& combinepockers(int index) const;
  inline ::rpc::Pocker* mutable_combinepockers(int index);
  inline ::rpc::Pocker* add_combinepockers();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
      combinepockers() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
      mutable_combinepockers();
  
  // optional int32 combineNum = 4;
  inline bool has_combinenum() const;
  inline void clear_combinenum();
  static const int kCombineNumFieldNumber = 4;
  inline ::google::protobuf::int32 combinenum() const;
  inline void set_combinenum(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.ComparePokerPlayer)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_combinenum();
  inline void clear_has_combinenum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pocker > pockers_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pocker > combinepockers_;
  ::google::protobuf::int32 combinenum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static ComparePokerPlayer* default_instance_;
};
// -------------------------------------------------------------------

class PockerBegin : public ::google::protobuf::Message {
 public:
  PockerBegin();
  virtual ~PockerBegin();
  
  PockerBegin(const PockerBegin& from);
  
  inline PockerBegin& operator=(const PockerBegin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PockerBegin& default_instance();
  
  void Swap(PockerBegin* other);
  
  // implements Message ----------------------------------------------
  
  PockerBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PockerBegin& from);
  void MergeFrom(const PockerBegin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string dealerUid = 1;
  inline bool has_dealeruid() const;
  inline void clear_dealeruid();
  static const int kDealerUidFieldNumber = 1;
  inline const ::std::string& dealeruid() const;
  inline void set_dealeruid(const ::std::string& value);
  inline void set_dealeruid(const char* value);
  inline void set_dealeruid(const char* value, size_t size);
  inline ::std::string* mutable_dealeruid();
  inline ::std::string* release_dealeruid();
  
  // optional string smBlindUid = 2;
  inline bool has_smblinduid() const;
  inline void clear_smblinduid();
  static const int kSmBlindUidFieldNumber = 2;
  inline const ::std::string& smblinduid() const;
  inline void set_smblinduid(const ::std::string& value);
  inline void set_smblinduid(const char* value);
  inline void set_smblinduid(const char* value, size_t size);
  inline ::std::string* mutable_smblinduid();
  inline ::std::string* release_smblinduid();
  
  // optional string bigBlindUid = 3;
  inline bool has_bigblinduid() const;
  inline void clear_bigblinduid();
  static const int kBigBlindUidFieldNumber = 3;
  inline const ::std::string& bigblinduid() const;
  inline void set_bigblinduid(const ::std::string& value);
  inline void set_bigblinduid(const char* value);
  inline void set_bigblinduid(const char* value, size_t size);
  inline ::std::string* mutable_bigblinduid();
  inline ::std::string* release_bigblinduid();
  
  // repeated string attendUids = 4;
  inline int attenduids_size() const;
  inline void clear_attenduids();
  static const int kAttendUidsFieldNumber = 4;
  inline const ::std::string& attenduids(int index) const;
  inline ::std::string* mutable_attenduids(int index);
  inline void set_attenduids(int index, const ::std::string& value);
  inline void set_attenduids(int index, const char* value);
  inline void set_attenduids(int index, const char* value, size_t size);
  inline ::std::string* add_attenduids();
  inline void add_attenduids(const ::std::string& value);
  inline void add_attenduids(const char* value);
  inline void add_attenduids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attenduids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attenduids();
  
  // @@protoc_insertion_point(class_scope:rpc.PockerBegin)
 private:
  inline void set_has_dealeruid();
  inline void clear_has_dealeruid();
  inline void set_has_smblinduid();
  inline void clear_has_smblinduid();
  inline void set_has_bigblinduid();
  inline void clear_has_bigblinduid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dealeruid_;
  ::std::string* smblinduid_;
  ::std::string* bigblinduid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attenduids_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PockerBegin* default_instance_;
};
// -------------------------------------------------------------------

class S2CPockerManInfo : public ::google::protobuf::Message {
 public:
  S2CPockerManInfo();
  virtual ~S2CPockerManInfo();
  
  S2CPockerManInfo(const S2CPockerManInfo& from);
  
  inline S2CPockerManInfo& operator=(const S2CPockerManInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2CPockerManInfo& default_instance();
  
  void Swap(S2CPockerManInfo* other);
  
  // implements Message ----------------------------------------------
  
  S2CPockerManInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2CPockerManInfo& from);
  void MergeFrom(const S2CPockerManInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string headerUrl = 1;
  inline bool has_headerurl() const;
  inline void clear_headerurl();
  static const int kHeaderUrlFieldNumber = 1;
  inline const ::std::string& headerurl() const;
  inline void set_headerurl(const ::std::string& value);
  inline void set_headerurl(const char* value);
  inline void set_headerurl(const char* value, size_t size);
  inline ::std::string* mutable_headerurl();
  inline ::std::string* release_headerurl();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int32 sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // optional int32 coin = 4;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 4;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // optional int32 gem = 5;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 5;
  inline ::google::protobuf::int32 gem() const;
  inline void set_gem(::google::protobuf::int32 value);
  
  // optional int32 roleId = 6;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 6;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);
  
  // optional int32 bestPocker = 7;
  inline bool has_bestpocker() const;
  inline void clear_bestpocker();
  static const int kBestPockerFieldNumber = 7;
  inline ::google::protobuf::int32 bestpocker() const;
  inline void set_bestpocker(::google::protobuf::int32 value);
  
  // optional int32 lv = 8;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 8;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.S2CPockerManInfo)
 private:
  inline void set_has_headerurl();
  inline void clear_has_headerurl();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_gem();
  inline void clear_has_gem();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_bestpocker();
  inline void clear_has_bestpocker();
  inline void set_has_lv();
  inline void clear_has_lv();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* headerurl_;
  ::std::string* name_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 gem_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 bestpocker_;
  ::google::protobuf::int32 lv_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static S2CPockerManInfo* default_instance_;
};
// -------------------------------------------------------------------

class PockerManBase : public ::google::protobuf::Message {
 public:
  PockerManBase();
  virtual ~PockerManBase();
  
  PockerManBase(const PockerManBase& from);
  
  inline PockerManBase& operator=(const PockerManBase& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PockerManBase& default_instance();
  
  void Swap(PockerManBase* other);
  
  // implements Message ----------------------------------------------
  
  PockerManBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PockerManBase& from);
  void MergeFrom(const PockerManBase& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional string headerUrl = 2;
  inline bool has_headerurl() const;
  inline void clear_headerurl();
  static const int kHeaderUrlFieldNumber = 2;
  inline const ::std::string& headerurl() const;
  inline void set_headerurl(const ::std::string& value);
  inline void set_headerurl(const char* value);
  inline void set_headerurl(const char* value, size_t size);
  inline ::std::string* mutable_headerurl();
  inline ::std::string* release_headerurl();
  
  // optional int32 coin = 3;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 3;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);
  
  // optional int32 drops = 4;
  inline bool has_drops() const;
  inline void clear_drops();
  static const int kDropsFieldNumber = 4;
  inline ::google::protobuf::int32 drops() const;
  inline void set_drops(::google::protobuf::int32 value);
  
  // optional int32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // repeated .rpc.Pocker pockers = 6;
  inline int pockers_size() const;
  inline void clear_pockers();
  static const int kPockersFieldNumber = 6;
  inline const ::rpc::Pocker& pockers(int index) const;
  inline ::rpc::Pocker* mutable_pockers(int index);
  inline ::rpc::Pocker* add_pockers();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
      pockers() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
      mutable_pockers();
  
  // optional int32 deskIdx = 7;
  inline bool has_deskidx() const;
  inline void clear_deskidx();
  static const int kDeskIdxFieldNumber = 7;
  inline ::google::protobuf::int32 deskidx() const;
  inline void set_deskidx(::google::protobuf::int32 value);
  
  // optional string nickName = 8;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 8;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // optional int32 endTime = 9;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 9;
  inline ::google::protobuf::int32 endtime() const;
  inline void set_endtime(::google::protobuf::int32 value);
  
  // optional int32 sex = 10;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 10;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.PockerManBase)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_headerurl();
  inline void clear_has_headerurl();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_drops();
  inline void clear_has_drops();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_deskidx();
  inline void clear_has_deskidx();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_sex();
  inline void clear_has_sex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::std::string* headerurl_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 drops_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Pocker > pockers_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 deskidx_;
  ::std::string* nickname_;
  ::google::protobuf::int32 endtime_;
  ::google::protobuf::int32 sex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PockerManBase* default_instance_;
};
// -------------------------------------------------------------------

class Pocker : public ::google::protobuf::Message {
 public:
  Pocker();
  virtual ~Pocker();
  
  Pocker(const Pocker& from);
  
  inline Pocker& operator=(const Pocker& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pocker& default_instance();
  
  void Swap(Pocker* other);
  
  // implements Message ----------------------------------------------
  
  Pocker* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pocker& from);
  void MergeFrom(const Pocker& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 eType = 1;
  inline bool has_etype() const;
  inline void clear_etype();
  static const int kETypeFieldNumber = 1;
  inline ::google::protobuf::int32 etype() const;
  inline void set_etype(::google::protobuf::int32 value);
  
  // required int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.Pocker)
 private:
  inline void set_has_etype();
  inline void clear_has_etype();
  inline void set_has_num();
  inline void clear_has_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 etype_;
  ::google::protobuf::int32 num_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static Pocker* default_instance_;
};
// -------------------------------------------------------------------

class PockerRoomBase : public ::google::protobuf::Message {
 public:
  PockerRoomBase();
  virtual ~PockerRoomBase();
  
  PockerRoomBase(const PockerRoomBase& from);
  
  inline PockerRoomBase& operator=(const PockerRoomBase& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PockerRoomBase& default_instance();
  
  void Swap(PockerRoomBase* other);
  
  // implements Message ----------------------------------------------
  
  PockerRoomBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PockerRoomBase& from);
  void MergeFrom(const PockerRoomBase& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.Pocker pockers = 1;
  inline int pockers_size() const;
  inline void clear_pockers();
  static const int kPockersFieldNumber = 1;
  inline const ::rpc::Pocker& pockers(int index) const;
  inline ::rpc::Pocker* mutable_pockers(int index);
  inline ::rpc::Pocker* add_pockers();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
      pockers() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
      mutable_pockers();
  
  // repeated int32 pots = 2;
  inline int pots_size() const;
  inline void clear_pots();
  static const int kPotsFieldNumber = 2;
  inline ::google::protobuf::int32 pots(int index) const;
  inline void set_pots(int index, ::google::protobuf::int32 value);
  inline void add_pots(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pots() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pots();
  
  // optional string dealerUid = 3;
  inline bool has_dealeruid() const;
  inline void clear_dealeruid();
  static const int kDealerUidFieldNumber = 3;
  inline const ::std::string& dealeruid() const;
  inline void set_dealeruid(const ::std::string& value);
  inline void set_dealeruid(const char* value);
  inline void set_dealeruid(const char* value, size_t size);
  inline ::std::string* mutable_dealeruid();
  inline ::std::string* release_dealeruid();
  
  // optional int32 roomId = 4;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 4;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // optional int32 smallBlind = 5;
  inline bool has_smallblind() const;
  inline void clear_smallblind();
  static const int kSmallBlindFieldNumber = 5;
  inline ::google::protobuf::int32 smallblind() const;
  inline void set_smallblind(::google::protobuf::int32 value);
  
  // optional int32 bigBlind = 6;
  inline bool has_bigblind() const;
  inline void clear_bigblind();
  static const int kBigBlindFieldNumber = 6;
  inline ::google::protobuf::int32 bigblind() const;
  inline void set_bigblind(::google::protobuf::int32 value);
  
  // optional int32 roomNo = 7;
  inline bool has_roomno() const;
  inline void clear_roomno();
  static const int kRoomNoFieldNumber = 7;
  inline ::google::protobuf::int32 roomno() const;
  inline void set_roomno(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.PockerRoomBase)
 private:
  inline void set_has_dealeruid();
  inline void clear_has_dealeruid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_smallblind();
  inline void clear_has_smallblind();
  inline void set_has_bigblind();
  inline void clear_has_bigblind();
  inline void set_has_roomno();
  inline void clear_has_roomno();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::Pocker > pockers_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pots_;
  ::std::string* dealeruid_;
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 smallblind_;
  ::google::protobuf::int32 bigblind_;
  ::google::protobuf::int32 roomno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PockerRoomBase* default_instance_;
};
// -------------------------------------------------------------------

class PockerRoomInfo : public ::google::protobuf::Message {
 public:
  PockerRoomInfo();
  virtual ~PockerRoomInfo();
  
  PockerRoomInfo(const PockerRoomInfo& from);
  
  inline PockerRoomInfo& operator=(const PockerRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PockerRoomInfo& default_instance();
  
  void Swap(PockerRoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  PockerRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PockerRoomInfo& from);
  void MergeFrom(const PockerRoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.PockerManBase players = 1;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 1;
  inline const ::rpc::PockerManBase& players(int index) const;
  inline ::rpc::PockerManBase* mutable_players(int index);
  inline ::rpc::PockerManBase* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase >*
      mutable_players();
  
  // optional .rpc.PockerRoomBase roombase = 2;
  inline bool has_roombase() const;
  inline void clear_roombase();
  static const int kRoombaseFieldNumber = 2;
  inline const ::rpc::PockerRoomBase& roombase() const;
  inline ::rpc::PockerRoomBase* mutable_roombase();
  inline ::rpc::PockerRoomBase* release_roombase();
  
  // optional int32 code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.PockerRoomInfo)
 private:
  inline void set_has_roombase();
  inline void clear_has_roombase();
  inline void set_has_code();
  inline void clear_has_code();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase > players_;
  ::rpc::PockerRoomBase* roombase_;
  ::google::protobuf::int32 code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static PockerRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class LeavePockerRoom : public ::google::protobuf::Message {
 public:
  LeavePockerRoom();
  virtual ~LeavePockerRoom();
  
  LeavePockerRoom(const LeavePockerRoom& from);
  
  inline LeavePockerRoom& operator=(const LeavePockerRoom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeavePockerRoom& default_instance();
  
  void Swap(LeavePockerRoom* other);
  
  // implements Message ----------------------------------------------
  
  LeavePockerRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeavePockerRoom& from);
  void MergeFrom(const LeavePockerRoom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // @@protoc_insertion_point(class_scope:rpc.LeavePockerRoom)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static LeavePockerRoom* default_instance_;
};
// ===================================================================


// ===================================================================

// PlayerBaseInfo

// required string uid = 1;
inline bool PlayerBaseInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerBaseInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerBaseInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerBaseInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& PlayerBaseInfo::uid() const {
  return *uid_;
}
inline void PlayerBaseInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void PlayerBaseInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void PlayerBaseInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerBaseInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* PlayerBaseInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool PlayerBaseInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerBaseInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerBaseInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerBaseInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerBaseInfo::name() const {
  return *name_;
}
inline void PlayerBaseInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerBaseInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerBaseInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerBaseInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlayerBaseInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 sex = 3;
inline bool PlayerBaseInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerBaseInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerBaseInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerBaseInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 PlayerBaseInfo::sex() const {
  return sex_;
}
inline void PlayerBaseInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// required int32 level = 4;
inline bool PlayerBaseInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerBaseInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerBaseInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerBaseInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 PlayerBaseInfo::level() const {
  return level_;
}
inline void PlayerBaseInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 exp = 5;
inline bool PlayerBaseInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerBaseInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerBaseInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerBaseInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 PlayerBaseInfo::exp() const {
  return exp_;
}
inline void PlayerBaseInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 vipLeftDay = 6;
inline bool PlayerBaseInfo::has_vipleftday() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerBaseInfo::set_has_vipleftday() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerBaseInfo::clear_has_vipleftday() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerBaseInfo::clear_vipleftday() {
  vipleftday_ = 0;
  clear_has_vipleftday();
}
inline ::google::protobuf::int32 PlayerBaseInfo::vipleftday() const {
  return vipleftday_;
}
inline void PlayerBaseInfo::set_vipleftday(::google::protobuf::int32 value) {
  set_has_vipleftday();
  vipleftday_ = value;
}

// optional int32 header = 7;
inline bool PlayerBaseInfo::has_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerBaseInfo::set_has_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerBaseInfo::clear_has_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerBaseInfo::clear_header() {
  header_ = 0;
  clear_has_header();
}
inline ::google::protobuf::int32 PlayerBaseInfo::header() const {
  return header_;
}
inline void PlayerBaseInfo::set_header(::google::protobuf::int32 value) {
  set_has_header();
  header_ = value;
}

// optional int32 coin = 8;
inline bool PlayerBaseInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerBaseInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerBaseInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerBaseInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 PlayerBaseInfo::coin() const {
  return coin_;
}
inline void PlayerBaseInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 gem = 9;
inline bool PlayerBaseInfo::has_gem() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerBaseInfo::set_has_gem() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerBaseInfo::clear_has_gem() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerBaseInfo::clear_gem() {
  gem_ = 0;
  clear_has_gem();
}
inline ::google::protobuf::int32 PlayerBaseInfo::gem() const {
  return gem_;
}
inline void PlayerBaseInfo::set_gem(::google::protobuf::int32 value) {
  set_has_gem();
  gem_ = value;
}

// optional int32 roleId = 10;
inline bool PlayerBaseInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerBaseInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerBaseInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerBaseInfo::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 PlayerBaseInfo::roleid() const {
  return roleid_;
}
inline void PlayerBaseInfo::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
}

// optional string gameType = 11;
inline bool PlayerBaseInfo::has_gametype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerBaseInfo::set_has_gametype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerBaseInfo::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerBaseInfo::clear_gametype() {
  if (gametype_ != &::google::protobuf::internal::kEmptyString) {
    gametype_->clear();
  }
  clear_has_gametype();
}
inline const ::std::string& PlayerBaseInfo::gametype() const {
  return *gametype_;
}
inline void PlayerBaseInfo::set_gametype(const ::std::string& value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void PlayerBaseInfo::set_gametype(const char* value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void PlayerBaseInfo::set_gametype(const char* value, size_t size) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerBaseInfo::mutable_gametype() {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  return gametype_;
}
inline ::std::string* PlayerBaseInfo::release_gametype() {
  clear_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gametype_;
    gametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 roomType = 12;
inline bool PlayerBaseInfo::has_roomtype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlayerBaseInfo::set_has_roomtype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlayerBaseInfo::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlayerBaseInfo::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 PlayerBaseInfo::roomtype() const {
  return roomtype_;
}
inline void PlayerBaseInfo::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional int32 insurCoin = 13;
inline bool PlayerBaseInfo::has_insurcoin() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlayerBaseInfo::set_has_insurcoin() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlayerBaseInfo::clear_has_insurcoin() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlayerBaseInfo::clear_insurcoin() {
  insurcoin_ = 0;
  clear_has_insurcoin();
}
inline ::google::protobuf::int32 PlayerBaseInfo::insurcoin() const {
  return insurcoin_;
}
inline void PlayerBaseInfo::set_insurcoin(::google::protobuf::int32 value) {
  set_has_insurcoin();
  insurcoin_ = value;
}

// optional int32 accountType = 14;
inline bool PlayerBaseInfo::has_accounttype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PlayerBaseInfo::set_has_accounttype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PlayerBaseInfo::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PlayerBaseInfo::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::google::protobuf::int32 PlayerBaseInfo::accounttype() const {
  return accounttype_;
}
inline void PlayerBaseInfo::set_accounttype(::google::protobuf::int32 value) {
  set_has_accounttype();
  accounttype_ = value;
}

// repeated string friendUids = 15;
inline int PlayerBaseInfo::frienduids_size() const {
  return frienduids_.size();
}
inline void PlayerBaseInfo::clear_frienduids() {
  frienduids_.Clear();
}
inline const ::std::string& PlayerBaseInfo::frienduids(int index) const {
  return frienduids_.Get(index);
}
inline ::std::string* PlayerBaseInfo::mutable_frienduids(int index) {
  return frienduids_.Mutable(index);
}
inline void PlayerBaseInfo::set_frienduids(int index, const ::std::string& value) {
  frienduids_.Mutable(index)->assign(value);
}
inline void PlayerBaseInfo::set_frienduids(int index, const char* value) {
  frienduids_.Mutable(index)->assign(value);
}
inline void PlayerBaseInfo::set_frienduids(int index, const char* value, size_t size) {
  frienduids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerBaseInfo::add_frienduids() {
  return frienduids_.Add();
}
inline void PlayerBaseInfo::add_frienduids(const ::std::string& value) {
  frienduids_.Add()->assign(value);
}
inline void PlayerBaseInfo::add_frienduids(const char* value) {
  frienduids_.Add()->assign(value);
}
inline void PlayerBaseInfo::add_frienduids(const char* value, size_t size) {
  frienduids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PlayerBaseInfo::frienduids() const {
  return frienduids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PlayerBaseInfo::mutable_frienduids() {
  return &frienduids_;
}

// optional string headerUrl = 16;
inline bool PlayerBaseInfo::has_headerurl() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PlayerBaseInfo::set_has_headerurl() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PlayerBaseInfo::clear_has_headerurl() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PlayerBaseInfo::clear_headerurl() {
  if (headerurl_ != &::google::protobuf::internal::kEmptyString) {
    headerurl_->clear();
  }
  clear_has_headerurl();
}
inline const ::std::string& PlayerBaseInfo::headerurl() const {
  return *headerurl_;
}
inline void PlayerBaseInfo::set_headerurl(const ::std::string& value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void PlayerBaseInfo::set_headerurl(const char* value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void PlayerBaseInfo::set_headerurl(const char* value, size_t size) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerBaseInfo::mutable_headerurl() {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  return headerurl_;
}
inline ::std::string* PlayerBaseInfo::release_headerurl() {
  clear_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headerurl_;
    headerurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string phone = 17;
inline bool PlayerBaseInfo::has_phone() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PlayerBaseInfo::set_has_phone() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PlayerBaseInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PlayerBaseInfo::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& PlayerBaseInfo::phone() const {
  return *phone_;
}
inline void PlayerBaseInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void PlayerBaseInfo::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void PlayerBaseInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerBaseInfo::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* PlayerBaseInfo::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool bModifyName = 18;
inline bool PlayerBaseInfo::has_bmodifyname() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PlayerBaseInfo::set_has_bmodifyname() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PlayerBaseInfo::clear_has_bmodifyname() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PlayerBaseInfo::clear_bmodifyname() {
  bmodifyname_ = false;
  clear_has_bmodifyname();
}
inline bool PlayerBaseInfo::bmodifyname() const {
  return bmodifyname_;
}
inline void PlayerBaseInfo::set_bmodifyname(bool value) {
  set_has_bmodifyname();
  bmodifyname_ = value;
}

// optional bool bModifySex = 19;
inline bool PlayerBaseInfo::has_bmodifysex() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PlayerBaseInfo::set_has_bmodifysex() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PlayerBaseInfo::clear_has_bmodifysex() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PlayerBaseInfo::clear_bmodifysex() {
  bmodifysex_ = false;
  clear_has_bmodifysex();
}
inline bool PlayerBaseInfo::bmodifysex() const {
  return bmodifysex_;
}
inline void PlayerBaseInfo::set_bmodifysex(bool value) {
  set_has_bmodifysex();
  bmodifysex_ = value;
}

// optional int32 lastLoginTime = 20;
inline bool PlayerBaseInfo::has_lastlogintime() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PlayerBaseInfo::set_has_lastlogintime() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PlayerBaseInfo::clear_has_lastlogintime() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PlayerBaseInfo::clear_lastlogintime() {
  lastlogintime_ = 0;
  clear_has_lastlogintime();
}
inline ::google::protobuf::int32 PlayerBaseInfo::lastlogintime() const {
  return lastlogintime_;
}
inline void PlayerBaseInfo::set_lastlogintime(::google::protobuf::int32 value) {
  set_has_lastlogintime();
  lastlogintime_ = value;
}

// optional int32 profits = 21;
inline bool PlayerBaseInfo::has_profits() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PlayerBaseInfo::set_has_profits() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PlayerBaseInfo::clear_has_profits() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PlayerBaseInfo::clear_profits() {
  profits_ = 0;
  clear_has_profits();
}
inline ::google::protobuf::int32 PlayerBaseInfo::profits() const {
  return profits_;
}
inline void PlayerBaseInfo::set_profits(::google::protobuf::int32 value) {
  set_has_profits();
  profits_ = value;
}

// optional int32 expTotal = 22;
inline bool PlayerBaseInfo::has_exptotal() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PlayerBaseInfo::set_has_exptotal() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PlayerBaseInfo::clear_has_exptotal() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PlayerBaseInfo::clear_exptotal() {
  exptotal_ = 0;
  clear_has_exptotal();
}
inline ::google::protobuf::int32 PlayerBaseInfo::exptotal() const {
  return exptotal_;
}
inline void PlayerBaseInfo::set_exptotal(::google::protobuf::int32 value) {
  set_has_exptotal();
  exptotal_ = value;
}

// optional int32 vipOpenTime = 23;
inline bool PlayerBaseInfo::has_vipopentime() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PlayerBaseInfo::set_has_vipopentime() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PlayerBaseInfo::clear_has_vipopentime() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PlayerBaseInfo::clear_vipopentime() {
  vipopentime_ = 0;
  clear_has_vipopentime();
}
inline ::google::protobuf::int32 PlayerBaseInfo::vipopentime() const {
  return vipopentime_;
}
inline void PlayerBaseInfo::set_vipopentime(::google::protobuf::int32 value) {
  set_has_vipopentime();
  vipopentime_ = value;
}

// -------------------------------------------------------------------

// PlayerExtraInfo

// repeated .rpc.BagItem items = 1;
inline int PlayerExtraInfo::items_size() const {
  return items_.size();
}
inline void PlayerExtraInfo::clear_items() {
  items_.Clear();
}
inline const ::rpc::BagItem& PlayerExtraInfo::items(int index) const {
  return items_.Get(index);
}
inline ::rpc::BagItem* PlayerExtraInfo::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::rpc::BagItem* PlayerExtraInfo::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::BagItem >&
PlayerExtraInfo::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::BagItem >*
PlayerExtraInfo::mutable_items() {
  return &items_;
}

// optional .rpc.Signature sign = 2;
inline bool PlayerExtraInfo::has_sign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerExtraInfo::set_has_sign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerExtraInfo::clear_has_sign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerExtraInfo::clear_sign() {
  if (sign_ != NULL) sign_->::rpc::Signature::Clear();
  clear_has_sign();
}
inline const ::rpc::Signature& PlayerExtraInfo::sign() const {
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
}
inline ::rpc::Signature* PlayerExtraInfo::mutable_sign() {
  set_has_sign();
  if (sign_ == NULL) sign_ = new ::rpc::Signature;
  return sign_;
}
inline ::rpc::Signature* PlayerExtraInfo::release_sign() {
  clear_has_sign();
  ::rpc::Signature* temp = sign_;
  sign_ = NULL;
  return temp;
}

// optional .rpc.DailyTask tasks = 3;
inline bool PlayerExtraInfo::has_tasks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerExtraInfo::set_has_tasks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerExtraInfo::clear_has_tasks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerExtraInfo::clear_tasks() {
  if (tasks_ != NULL) tasks_->::rpc::DailyTask::Clear();
  clear_has_tasks();
}
inline const ::rpc::DailyTask& PlayerExtraInfo::tasks() const {
  return tasks_ != NULL ? *tasks_ : *default_instance_->tasks_;
}
inline ::rpc::DailyTask* PlayerExtraInfo::mutable_tasks() {
  set_has_tasks();
  if (tasks_ == NULL) tasks_ = new ::rpc::DailyTask;
  return tasks_;
}
inline ::rpc::DailyTask* PlayerExtraInfo::release_tasks() {
  clear_has_tasks();
  ::rpc::DailyTask* temp = tasks_;
  tasks_ = NULL;
  return temp;
}

// repeated .rpc.Score scores = 4;
inline int PlayerExtraInfo::scores_size() const {
  return scores_.size();
}
inline void PlayerExtraInfo::clear_scores() {
  scores_.Clear();
}
inline const ::rpc::Score& PlayerExtraInfo::scores(int index) const {
  return scores_.Get(index);
}
inline ::rpc::Score* PlayerExtraInfo::mutable_scores(int index) {
  return scores_.Mutable(index);
}
inline ::rpc::Score* PlayerExtraInfo::add_scores() {
  return scores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Score >&
PlayerExtraInfo::scores() const {
  return scores_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Score >*
PlayerExtraInfo::mutable_scores() {
  return &scores_;
}

// optional .rpc.BankruptInfo bankrupt = 5;
inline bool PlayerExtraInfo::has_bankrupt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerExtraInfo::set_has_bankrupt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerExtraInfo::clear_has_bankrupt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerExtraInfo::clear_bankrupt() {
  if (bankrupt_ != NULL) bankrupt_->::rpc::BankruptInfo::Clear();
  clear_has_bankrupt();
}
inline const ::rpc::BankruptInfo& PlayerExtraInfo::bankrupt() const {
  return bankrupt_ != NULL ? *bankrupt_ : *default_instance_->bankrupt_;
}
inline ::rpc::BankruptInfo* PlayerExtraInfo::mutable_bankrupt() {
  set_has_bankrupt();
  if (bankrupt_ == NULL) bankrupt_ = new ::rpc::BankruptInfo;
  return bankrupt_;
}
inline ::rpc::BankruptInfo* PlayerExtraInfo::release_bankrupt() {
  clear_has_bankrupt();
  ::rpc::BankruptInfo* temp = bankrupt_;
  bankrupt_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// BagItem

// required string id = 1;
inline bool BagItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagItem::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BagItem::id() const {
  return *id_;
}
inline void BagItem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BagItem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BagItem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BagItem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* BagItem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 num = 2;
inline bool BagItem::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagItem::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagItem::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagItem::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 BagItem::num() const {
  return num_;
}
inline void BagItem::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// BagItemNofity

// repeated .rpc.BagItem items = 1;
inline int BagItemNofity::items_size() const {
  return items_.size();
}
inline void BagItemNofity::clear_items() {
  items_.Clear();
}
inline const ::rpc::BagItem& BagItemNofity::items(int index) const {
  return items_.Get(index);
}
inline ::rpc::BagItem* BagItemNofity::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::rpc::BagItem* BagItemNofity::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::BagItem >&
BagItemNofity::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::BagItem >*
BagItemNofity::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// Signature

// optional int32 month = 1;
inline bool Signature::has_month() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signature::set_has_month() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signature::clear_has_month() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signature::clear_month() {
  month_ = 0;
  clear_has_month();
}
inline ::google::protobuf::int32 Signature::month() const {
  return month_;
}
inline void Signature::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
}

// repeated int32 signs = 2;
inline int Signature::signs_size() const {
  return signs_.size();
}
inline void Signature::clear_signs() {
  signs_.Clear();
}
inline ::google::protobuf::int32 Signature::signs(int index) const {
  return signs_.Get(index);
}
inline void Signature::set_signs(int index, ::google::protobuf::int32 value) {
  signs_.Set(index, value);
}
inline void Signature::add_signs(::google::protobuf::int32 value) {
  signs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Signature::signs() const {
  return signs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Signature::mutable_signs() {
  return &signs_;
}

// optional int32 lastSign = 3;
inline bool Signature::has_lastsign() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signature::set_has_lastsign() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Signature::clear_has_lastsign() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Signature::clear_lastsign() {
  lastsign_ = 0;
  clear_has_lastsign();
}
inline ::google::protobuf::int32 Signature::lastsign() const {
  return lastsign_;
}
inline void Signature::set_lastsign(::google::protobuf::int32 value) {
  set_has_lastsign();
  lastsign_ = value;
}

// optional int32 contiDay = 4;
inline bool Signature::has_contiday() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Signature::set_has_contiday() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Signature::clear_has_contiday() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Signature::clear_contiday() {
  contiday_ = 0;
  clear_has_contiday();
}
inline ::google::protobuf::int32 Signature::contiday() const {
  return contiday_;
}
inline void Signature::set_contiday(::google::protobuf::int32 value) {
  set_has_contiday();
  contiday_ = value;
}

// optional int32 contiRewardTms = 5;
inline bool Signature::has_contirewardtms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Signature::set_has_contirewardtms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Signature::clear_has_contirewardtms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Signature::clear_contirewardtms() {
  contirewardtms_ = 0;
  clear_has_contirewardtms();
}
inline ::google::protobuf::int32 Signature::contirewardtms() const {
  return contirewardtms_;
}
inline void Signature::set_contirewardtms(::google::protobuf::int32 value) {
  set_has_contirewardtms();
  contirewardtms_ = value;
}

// -------------------------------------------------------------------

// DailyTask

// optional int32 resetTime = 1;
inline bool DailyTask::has_resettime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyTask::set_has_resettime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyTask::clear_has_resettime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyTask::clear_resettime() {
  resettime_ = 0;
  clear_has_resettime();
}
inline ::google::protobuf::int32 DailyTask::resettime() const {
  return resettime_;
}
inline void DailyTask::set_resettime(::google::protobuf::int32 value) {
  set_has_resettime();
  resettime_ = value;
}

// repeated int32 doneIds = 2;
inline int DailyTask::doneids_size() const {
  return doneids_.size();
}
inline void DailyTask::clear_doneids() {
  doneids_.Clear();
}
inline ::google::protobuf::int32 DailyTask::doneids(int index) const {
  return doneids_.Get(index);
}
inline void DailyTask::set_doneids(int index, ::google::protobuf::int32 value) {
  doneids_.Set(index, value);
}
inline void DailyTask::add_doneids(::google::protobuf::int32 value) {
  doneids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DailyTask::doneids() const {
  return doneids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DailyTask::mutable_doneids() {
  return &doneids_;
}

// repeated int32 getIds = 3;
inline int DailyTask::getids_size() const {
  return getids_.size();
}
inline void DailyTask::clear_getids() {
  getids_.Clear();
}
inline ::google::protobuf::int32 DailyTask::getids(int index) const {
  return getids_.Get(index);
}
inline void DailyTask::set_getids(int index, ::google::protobuf::int32 value) {
  getids_.Set(index, value);
}
inline void DailyTask::add_getids(::google::protobuf::int32 value) {
  getids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DailyTask::getids() const {
  return getids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DailyTask::mutable_getids() {
  return &getids_;
}

// optional int32 shares = 4;
inline bool DailyTask::has_shares() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DailyTask::set_has_shares() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DailyTask::clear_has_shares() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DailyTask::clear_shares() {
  shares_ = 0;
  clear_has_shares();
}
inline ::google::protobuf::int32 DailyTask::shares() const {
  return shares_;
}
inline void DailyTask::set_shares(::google::protobuf::int32 value) {
  set_has_shares();
  shares_ = value;
}

// optional int32 shareFris = 5;
inline bool DailyTask::has_sharefris() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DailyTask::set_has_sharefris() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DailyTask::clear_has_sharefris() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DailyTask::clear_sharefris() {
  sharefris_ = 0;
  clear_has_sharefris();
}
inline ::google::protobuf::int32 DailyTask::sharefris() const {
  return sharefris_;
}
inline void DailyTask::set_sharefris(::google::protobuf::int32 value) {
  set_has_sharefris();
  sharefris_ = value;
}

// optional int32 daerTms = 6;
inline bool DailyTask::has_daertms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DailyTask::set_has_daertms() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DailyTask::clear_has_daertms() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DailyTask::clear_daertms() {
  daertms_ = 0;
  clear_has_daertms();
}
inline ::google::protobuf::int32 DailyTask::daertms() const {
  return daertms_;
}
inline void DailyTask::set_daertms(::google::protobuf::int32 value) {
  set_has_daertms();
  daertms_ = value;
}

// optional int32 mjTms = 7;
inline bool DailyTask::has_mjtms() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DailyTask::set_has_mjtms() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DailyTask::clear_has_mjtms() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DailyTask::clear_mjtms() {
  mjtms_ = 0;
  clear_has_mjtms();
}
inline ::google::protobuf::int32 DailyTask::mjtms() const {
  return mjtms_;
}
inline void DailyTask::set_mjtms(::google::protobuf::int32 value) {
  set_has_mjtms();
  mjtms_ = value;
}

// optional int32 pokerTms = 8;
inline bool DailyTask::has_pokertms() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DailyTask::set_has_pokertms() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DailyTask::clear_has_pokertms() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DailyTask::clear_pokertms() {
  pokertms_ = 0;
  clear_has_pokertms();
}
inline ::google::protobuf::int32 DailyTask::pokertms() const {
  return pokertms_;
}
inline void DailyTask::set_pokertms(::google::protobuf::int32 value) {
  set_has_pokertms();
  pokertms_ = value;
}

// optional int32 winDaerTms = 9;
inline bool DailyTask::has_windaertms() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DailyTask::set_has_windaertms() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DailyTask::clear_has_windaertms() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DailyTask::clear_windaertms() {
  windaertms_ = 0;
  clear_has_windaertms();
}
inline ::google::protobuf::int32 DailyTask::windaertms() const {
  return windaertms_;
}
inline void DailyTask::set_windaertms(::google::protobuf::int32 value) {
  set_has_windaertms();
  windaertms_ = value;
}

// optional int32 winMjTms = 10;
inline bool DailyTask::has_winmjtms() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DailyTask::set_has_winmjtms() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DailyTask::clear_has_winmjtms() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DailyTask::clear_winmjtms() {
  winmjtms_ = 0;
  clear_has_winmjtms();
}
inline ::google::protobuf::int32 DailyTask::winmjtms() const {
  return winmjtms_;
}
inline void DailyTask::set_winmjtms(::google::protobuf::int32 value) {
  set_has_winmjtms();
  winmjtms_ = value;
}

// optional int32 winPokerTms = 11;
inline bool DailyTask::has_winpokertms() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DailyTask::set_has_winpokertms() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DailyTask::clear_has_winpokertms() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DailyTask::clear_winpokertms() {
  winpokertms_ = 0;
  clear_has_winpokertms();
}
inline ::google::protobuf::int32 DailyTask::winpokertms() const {
  return winpokertms_;
}
inline void DailyTask::set_winpokertms(::google::protobuf::int32 value) {
  set_has_winpokertms();
  winpokertms_ = value;
}

// -------------------------------------------------------------------

// Score

// required string name = 1;
inline bool Score::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Score::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Score::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Score::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Score::name() const {
  return *name_;
}
inline void Score::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Score::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Score::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Score::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Score::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 win = 2;
inline bool Score::has_win() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Score::set_has_win() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Score::clear_has_win() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Score::clear_win() {
  win_ = 0;
  clear_has_win();
}
inline ::google::protobuf::int32 Score::win() const {
  return win_;
}
inline void Score::set_win(::google::protobuf::int32 value) {
  set_has_win();
  win_ = value;
}

// required int32 loss = 3;
inline bool Score::has_loss() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Score::set_has_loss() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Score::clear_has_loss() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Score::clear_loss() {
  loss_ = 0;
  clear_has_loss();
}
inline ::google::protobuf::int32 Score::loss() const {
  return loss_;
}
inline void Score::set_loss(::google::protobuf::int32 value) {
  set_has_loss();
  loss_ = value;
}

// -------------------------------------------------------------------

// BankruptInfo

// optional int32 time = 1;
inline bool BankruptInfo::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BankruptInfo::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BankruptInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BankruptInfo::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 BankruptInfo::time() const {
  return time_;
}
inline void BankruptInfo::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 rewardTimes = 2;
inline bool BankruptInfo::has_rewardtimes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BankruptInfo::set_has_rewardtimes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BankruptInfo::clear_has_rewardtimes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BankruptInfo::clear_rewardtimes() {
  rewardtimes_ = 0;
  clear_has_rewardtimes();
}
inline ::google::protobuf::int32 BankruptInfo::rewardtimes() const {
  return rewardtimes_;
}
inline void BankruptInfo::set_rewardtimes(::google::protobuf::int32 value) {
  set_has_rewardtimes();
  rewardtimes_ = value;
}

// -------------------------------------------------------------------

// ScoreNofify

// repeated .rpc.Score scores = 1;
inline int ScoreNofify::scores_size() const {
  return scores_.size();
}
inline void ScoreNofify::clear_scores() {
  scores_.Clear();
}
inline const ::rpc::Score& ScoreNofify::scores(int index) const {
  return scores_.Get(index);
}
inline ::rpc::Score* ScoreNofify::mutable_scores(int index) {
  return scores_.Mutable(index);
}
inline ::rpc::Score* ScoreNofify::add_scores() {
  return scores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Score >&
ScoreNofify::scores() const {
  return scores_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Score >*
ScoreNofify::mutable_scores() {
  return &scores_;
}

// -------------------------------------------------------------------

// Request

// required string method = 1;
inline bool Request::has_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_method() {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& Request::method() const {
  return *method_;
}
inline void Request::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void Request::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void Request::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  return method_;
}
inline ::std::string* Request::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes serialized_request = 2;
inline bool Request::has_serialized_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_serialized_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_serialized_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_serialized_request() {
  if (serialized_request_ != &::google::protobuf::internal::kEmptyString) {
    serialized_request_->clear();
  }
  clear_has_serialized_request();
}
inline const ::std::string& Request::serialized_request() const {
  return *serialized_request_;
}
inline void Request::set_serialized_request(const ::std::string& value) {
  set_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    serialized_request_ = new ::std::string;
  }
  serialized_request_->assign(value);
}
inline void Request::set_serialized_request(const char* value) {
  set_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    serialized_request_ = new ::std::string;
  }
  serialized_request_->assign(value);
}
inline void Request::set_serialized_request(const void* value, size_t size) {
  set_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    serialized_request_ = new ::std::string;
  }
  serialized_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_serialized_request() {
  set_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    serialized_request_ = new ::std::string;
  }
  return serialized_request_;
}
inline ::std::string* Request::release_serialized_request() {
  clear_has_serialized_request();
  if (serialized_request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_request_;
    serialized_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginCnsInfo

// required string cnsIp = 1;
inline bool LoginCnsInfo::has_cnsip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginCnsInfo::set_has_cnsip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginCnsInfo::clear_has_cnsip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginCnsInfo::clear_cnsip() {
  if (cnsip_ != &::google::protobuf::internal::kEmptyString) {
    cnsip_->clear();
  }
  clear_has_cnsip();
}
inline const ::std::string& LoginCnsInfo::cnsip() const {
  return *cnsip_;
}
inline void LoginCnsInfo::set_cnsip(const ::std::string& value) {
  set_has_cnsip();
  if (cnsip_ == &::google::protobuf::internal::kEmptyString) {
    cnsip_ = new ::std::string;
  }
  cnsip_->assign(value);
}
inline void LoginCnsInfo::set_cnsip(const char* value) {
  set_has_cnsip();
  if (cnsip_ == &::google::protobuf::internal::kEmptyString) {
    cnsip_ = new ::std::string;
  }
  cnsip_->assign(value);
}
inline void LoginCnsInfo::set_cnsip(const char* value, size_t size) {
  set_has_cnsip();
  if (cnsip_ == &::google::protobuf::internal::kEmptyString) {
    cnsip_ = new ::std::string;
  }
  cnsip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCnsInfo::mutable_cnsip() {
  set_has_cnsip();
  if (cnsip_ == &::google::protobuf::internal::kEmptyString) {
    cnsip_ = new ::std::string;
  }
  return cnsip_;
}
inline ::std::string* LoginCnsInfo::release_cnsip() {
  clear_has_cnsip();
  if (cnsip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cnsip_;
    cnsip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string gsInfo = 2;
inline bool LoginCnsInfo::has_gsinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginCnsInfo::set_has_gsinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginCnsInfo::clear_has_gsinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginCnsInfo::clear_gsinfo() {
  if (gsinfo_ != &::google::protobuf::internal::kEmptyString) {
    gsinfo_->clear();
  }
  clear_has_gsinfo();
}
inline const ::std::string& LoginCnsInfo::gsinfo() const {
  return *gsinfo_;
}
inline void LoginCnsInfo::set_gsinfo(const ::std::string& value) {
  set_has_gsinfo();
  if (gsinfo_ == &::google::protobuf::internal::kEmptyString) {
    gsinfo_ = new ::std::string;
  }
  gsinfo_->assign(value);
}
inline void LoginCnsInfo::set_gsinfo(const char* value) {
  set_has_gsinfo();
  if (gsinfo_ == &::google::protobuf::internal::kEmptyString) {
    gsinfo_ = new ::std::string;
  }
  gsinfo_->assign(value);
}
inline void LoginCnsInfo::set_gsinfo(const char* value, size_t size) {
  set_has_gsinfo();
  if (gsinfo_ == &::google::protobuf::internal::kEmptyString) {
    gsinfo_ = new ::std::string;
  }
  gsinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCnsInfo::mutable_gsinfo() {
  set_has_gsinfo();
  if (gsinfo_ == &::google::protobuf::internal::kEmptyString) {
    gsinfo_ = new ::std::string;
  }
  return gsinfo_;
}
inline ::std::string* LoginCnsInfo::release_gsinfo() {
  clear_has_gsinfo();
  if (gsinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gsinfo_;
    gsinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 versionOld = 3;
inline bool LoginCnsInfo::has_versionold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginCnsInfo::set_has_versionold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginCnsInfo::clear_has_versionold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginCnsInfo::clear_versionold() {
  versionold_ = 0;
  clear_has_versionold();
}
inline ::google::protobuf::int32 LoginCnsInfo::versionold() const {
  return versionold_;
}
inline void LoginCnsInfo::set_versionold(::google::protobuf::int32 value) {
  set_has_versionold();
  versionold_ = value;
}

// optional int32 versionNew = 4;
inline bool LoginCnsInfo::has_versionnew() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginCnsInfo::set_has_versionnew() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginCnsInfo::clear_has_versionnew() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginCnsInfo::clear_versionnew() {
  versionnew_ = 0;
  clear_has_versionnew();
}
inline ::google::protobuf::int32 LoginCnsInfo::versionnew() const {
  return versionnew_;
}
inline void LoginCnsInfo::set_versionnew(::google::protobuf::int32 value) {
  set_has_versionnew();
  versionnew_ = value;
}

// optional string downloadUrl = 5;
inline bool LoginCnsInfo::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginCnsInfo::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginCnsInfo::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginCnsInfo::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& LoginCnsInfo::downloadurl() const {
  return *downloadurl_;
}
inline void LoginCnsInfo::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void LoginCnsInfo::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void LoginCnsInfo::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCnsInfo::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* LoginCnsInfo::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 versionMid = 6;
inline bool LoginCnsInfo::has_versionmid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginCnsInfo::set_has_versionmid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginCnsInfo::clear_has_versionmid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginCnsInfo::clear_versionmid() {
  versionmid_ = 0;
  clear_has_versionmid();
}
inline ::google::protobuf::int32 LoginCnsInfo::versionmid() const {
  return versionmid_;
}
inline void LoginCnsInfo::set_versionmid(::google::protobuf::int32 value) {
  set_has_versionmid();
  versionmid_ = value;
}

// -------------------------------------------------------------------

// Login

// optional string uid = 1;
inline bool Login::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& Login::uid() const {
  return *uid_;
}
inline void Login::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Login::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Login::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* Login::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string openid = 2;
inline bool Login::has_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& Login::openid() const {
  return *openid_;
}
inline void Login::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void Login::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void Login::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* Login::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 roleId = 3;
inline bool Login::has_roleid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Login::set_has_roleid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Login::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Login::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 Login::roleid() const {
  return roleid_;
}
inline void Login::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
}

// optional string headerUrl = 4;
inline bool Login::has_headerurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Login::set_has_headerurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Login::clear_has_headerurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Login::clear_headerurl() {
  if (headerurl_ != &::google::protobuf::internal::kEmptyString) {
    headerurl_->clear();
  }
  clear_has_headerurl();
}
inline const ::std::string& Login::headerurl() const {
  return *headerurl_;
}
inline void Login::set_headerurl(const ::std::string& value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void Login::set_headerurl(const char* value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void Login::set_headerurl(const char* value, size_t size) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_headerurl() {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  return headerurl_;
}
inline ::std::string* Login::release_headerurl() {
  clear_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headerurl_;
    headerurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nickName = 5;
inline bool Login::has_nickname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Login::set_has_nickname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Login::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Login::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& Login::nickname() const {
  return *nickname_;
}
inline void Login::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void Login::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void Login::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* Login::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 sex = 6;
inline bool Login::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Login::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Login::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Login::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 Login::sex() const {
  return sex_;
}
inline void Login::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string clientVersion = 7;
inline bool Login::has_clientversion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Login::set_has_clientversion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Login::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Login::clear_clientversion() {
  if (clientversion_ != &::google::protobuf::internal::kEmptyString) {
    clientversion_->clear();
  }
  clear_has_clientversion();
}
inline const ::std::string& Login::clientversion() const {
  return *clientversion_;
}
inline void Login::set_clientversion(const ::std::string& value) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(value);
}
inline void Login::set_clientversion(const char* value) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(value);
}
inline void Login::set_clientversion(const char* value, size_t size) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_clientversion() {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  return clientversion_;
}
inline ::std::string* Login::release_clientversion() {
  clear_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientversion_;
    clientversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginResult

// required string result = 1;
inline bool LoginResult::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResult::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResult::clear_result() {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& LoginResult::result() const {
  return *result_;
}
inline void LoginResult::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void LoginResult::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void LoginResult::set_result(const char* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResult::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  return result_;
}
inline ::std::string* LoginResult::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 server_time = 2;
inline bool LoginResult::has_server_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResult::set_has_server_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResult::clear_has_server_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResult::clear_server_time() {
  server_time_ = GOOGLE_LONGLONG(0);
  clear_has_server_time();
}
inline ::google::protobuf::int64 LoginResult::server_time() const {
  return server_time_;
}
inline void LoginResult::set_server_time(::google::protobuf::int64 value) {
  set_has_server_time();
  server_time_ = value;
}

// optional string errmsg = 3;
inline bool LoginResult::has_errmsg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResult::set_has_errmsg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResult::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResult::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& LoginResult::errmsg() const {
  return *errmsg_;
}
inline void LoginResult::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void LoginResult::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void LoginResult::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResult::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  return errmsg_;
}
inline ::std::string* LoginResult::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string openid = 4;
inline bool LoginResult::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResult::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResult::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResult::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& LoginResult::openid() const {
  return *openid_;
}
inline void LoginResult::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void LoginResult::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void LoginResult::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResult::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* LoginResult::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uid = 5;
inline bool LoginResult::has_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResult::set_has_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResult::clear_has_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResult::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& LoginResult::uid() const {
  return *uid_;
}
inline void LoginResult::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void LoginResult::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void LoginResult::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResult::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* LoginResult::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 roleId = 6;
inline bool LoginResult::has_roleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResult::set_has_roleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResult::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResult::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 LoginResult::roleid() const {
  return roleid_;
}
inline void LoginResult::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
}

// -------------------------------------------------------------------

// PlayerInfo

// required .rpc.PlayerBaseInfo base = 1;
inline bool PlayerInfo::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfo::clear_base() {
  if (base_ != NULL) base_->::rpc::PlayerBaseInfo::Clear();
  clear_has_base();
}
inline const ::rpc::PlayerBaseInfo& PlayerInfo::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::rpc::PlayerBaseInfo* PlayerInfo::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::rpc::PlayerBaseInfo;
  return base_;
}
inline ::rpc::PlayerBaseInfo* PlayerInfo::release_base() {
  clear_has_base();
  ::rpc::PlayerBaseInfo* temp = base_;
  base_ = NULL;
  return temp;
}

// optional .rpc.PlayerExtraInfo extra = 2;
inline bool PlayerInfo::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfo::clear_extra() {
  if (extra_ != NULL) extra_->::rpc::PlayerExtraInfo::Clear();
  clear_has_extra();
}
inline const ::rpc::PlayerExtraInfo& PlayerInfo::extra() const {
  return extra_ != NULL ? *extra_ : *default_instance_->extra_;
}
inline ::rpc::PlayerExtraInfo* PlayerInfo::mutable_extra() {
  set_has_extra();
  if (extra_ == NULL) extra_ = new ::rpc::PlayerExtraInfo;
  return extra_;
}
inline ::rpc::PlayerExtraInfo* PlayerInfo::release_extra() {
  clear_has_extra();
  ::rpc::PlayerExtraInfo* temp = extra_;
  extra_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ResourceNotify

// optional int32 coin = 1;
inline bool ResourceNotify::has_coin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceNotify::set_has_coin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceNotify::clear_has_coin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceNotify::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 ResourceNotify::coin() const {
  return coin_;
}
inline void ResourceNotify::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 gem = 2;
inline bool ResourceNotify::has_gem() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceNotify::set_has_gem() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceNotify::clear_has_gem() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceNotify::clear_gem() {
  gem_ = 0;
  clear_has_gem();
}
inline ::google::protobuf::int32 ResourceNotify::gem() const {
  return gem_;
}
inline void ResourceNotify::set_gem(::google::protobuf::int32 value) {
  set_has_gem();
  gem_ = value;
}

// optional int32 insurCoin = 3;
inline bool ResourceNotify::has_insurcoin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceNotify::set_has_insurcoin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceNotify::clear_has_insurcoin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceNotify::clear_insurcoin() {
  insurcoin_ = 0;
  clear_has_insurcoin();
}
inline ::google::protobuf::int32 ResourceNotify::insurcoin() const {
  return insurcoin_;
}
inline void ResourceNotify::set_insurcoin(::google::protobuf::int32 value) {
  set_has_insurcoin();
  insurcoin_ = value;
}

// optional int32 level = 4;
inline bool ResourceNotify::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceNotify::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceNotify::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceNotify::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ResourceNotify::level() const {
  return level_;
}
inline void ResourceNotify::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 exp = 5;
inline bool ResourceNotify::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceNotify::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceNotify::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceNotify::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 ResourceNotify::exp() const {
  return exp_;
}
inline void ResourceNotify::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// OnlineBody

// required int32 roomId = 1;
inline bool OnlineBody::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnlineBody::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnlineBody::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnlineBody::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 OnlineBody::roomid() const {
  return roomid_;
}
inline void OnlineBody::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required int32 num = 2;
inline bool OnlineBody::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlineBody::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlineBody::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlineBody::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 OnlineBody::num() const {
  return num_;
}
inline void OnlineBody::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// OnlineInfo

// repeated .rpc.OnlineBody info = 1;
inline int OnlineInfo::info_size() const {
  return info_.size();
}
inline void OnlineInfo::clear_info() {
  info_.Clear();
}
inline const ::rpc::OnlineBody& OnlineInfo::info(int index) const {
  return info_.Get(index);
}
inline ::rpc::OnlineBody* OnlineInfo::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::rpc::OnlineBody* OnlineInfo::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::OnlineBody >&
OnlineInfo::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::OnlineBody >*
OnlineInfo::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// OnlinePlayerReq

// repeated int32 partIds = 1;
inline int OnlinePlayerReq::partids_size() const {
  return partids_.size();
}
inline void OnlinePlayerReq::clear_partids() {
  partids_.Clear();
}
inline ::google::protobuf::int32 OnlinePlayerReq::partids(int index) const {
  return partids_.Get(index);
}
inline void OnlinePlayerReq::set_partids(int index, ::google::protobuf::int32 value) {
  partids_.Set(index, value);
}
inline void OnlinePlayerReq::add_partids(::google::protobuf::int32 value) {
  partids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OnlinePlayerReq::partids() const {
  return partids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OnlinePlayerReq::mutable_partids() {
  return &partids_;
}

// -------------------------------------------------------------------

// OnlinePlayerMsg

// optional .rpc.OnlineInfo daerInfo = 1;
inline bool OnlinePlayerMsg::has_daerinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnlinePlayerMsg::set_has_daerinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnlinePlayerMsg::clear_has_daerinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnlinePlayerMsg::clear_daerinfo() {
  if (daerinfo_ != NULL) daerinfo_->::rpc::OnlineInfo::Clear();
  clear_has_daerinfo();
}
inline const ::rpc::OnlineInfo& OnlinePlayerMsg::daerinfo() const {
  return daerinfo_ != NULL ? *daerinfo_ : *default_instance_->daerinfo_;
}
inline ::rpc::OnlineInfo* OnlinePlayerMsg::mutable_daerinfo() {
  set_has_daerinfo();
  if (daerinfo_ == NULL) daerinfo_ = new ::rpc::OnlineInfo;
  return daerinfo_;
}
inline ::rpc::OnlineInfo* OnlinePlayerMsg::release_daerinfo() {
  clear_has_daerinfo();
  ::rpc::OnlineInfo* temp = daerinfo_;
  daerinfo_ = NULL;
  return temp;
}

// optional .rpc.OnlineInfo mjInfo = 2;
inline bool OnlinePlayerMsg::has_mjinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlinePlayerMsg::set_has_mjinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlinePlayerMsg::clear_has_mjinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlinePlayerMsg::clear_mjinfo() {
  if (mjinfo_ != NULL) mjinfo_->::rpc::OnlineInfo::Clear();
  clear_has_mjinfo();
}
inline const ::rpc::OnlineInfo& OnlinePlayerMsg::mjinfo() const {
  return mjinfo_ != NULL ? *mjinfo_ : *default_instance_->mjinfo_;
}
inline ::rpc::OnlineInfo* OnlinePlayerMsg::mutable_mjinfo() {
  set_has_mjinfo();
  if (mjinfo_ == NULL) mjinfo_ = new ::rpc::OnlineInfo;
  return mjinfo_;
}
inline ::rpc::OnlineInfo* OnlinePlayerMsg::release_mjinfo() {
  clear_has_mjinfo();
  ::rpc::OnlineInfo* temp = mjinfo_;
  mjinfo_ = NULL;
  return temp;
}

// optional .rpc.OnlineInfo pokerInfo = 3;
inline bool OnlinePlayerMsg::has_pokerinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OnlinePlayerMsg::set_has_pokerinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OnlinePlayerMsg::clear_has_pokerinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OnlinePlayerMsg::clear_pokerinfo() {
  if (pokerinfo_ != NULL) pokerinfo_->::rpc::OnlineInfo::Clear();
  clear_has_pokerinfo();
}
inline const ::rpc::OnlineInfo& OnlinePlayerMsg::pokerinfo() const {
  return pokerinfo_ != NULL ? *pokerinfo_ : *default_instance_->pokerinfo_;
}
inline ::rpc::OnlineInfo* OnlinePlayerMsg::mutable_pokerinfo() {
  set_has_pokerinfo();
  if (pokerinfo_ == NULL) pokerinfo_ = new ::rpc::OnlineInfo;
  return pokerinfo_;
}
inline ::rpc::OnlineInfo* OnlinePlayerMsg::release_pokerinfo() {
  clear_has_pokerinfo();
  ::rpc::OnlineInfo* temp = pokerinfo_;
  pokerinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NotifyMsg

// optional string txtId = 1;
inline bool NotifyMsg::has_txtid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyMsg::set_has_txtid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyMsg::clear_has_txtid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyMsg::clear_txtid() {
  if (txtid_ != &::google::protobuf::internal::kEmptyString) {
    txtid_->clear();
  }
  clear_has_txtid();
}
inline const ::std::string& NotifyMsg::txtid() const {
  return *txtid_;
}
inline void NotifyMsg::set_txtid(const ::std::string& value) {
  set_has_txtid();
  if (txtid_ == &::google::protobuf::internal::kEmptyString) {
    txtid_ = new ::std::string;
  }
  txtid_->assign(value);
}
inline void NotifyMsg::set_txtid(const char* value) {
  set_has_txtid();
  if (txtid_ == &::google::protobuf::internal::kEmptyString) {
    txtid_ = new ::std::string;
  }
  txtid_->assign(value);
}
inline void NotifyMsg::set_txtid(const char* value, size_t size) {
  set_has_txtid();
  if (txtid_ == &::google::protobuf::internal::kEmptyString) {
    txtid_ = new ::std::string;
  }
  txtid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyMsg::mutable_txtid() {
  set_has_txtid();
  if (txtid_ == &::google::protobuf::internal::kEmptyString) {
    txtid_ = new ::std::string;
  }
  return txtid_;
}
inline ::std::string* NotifyMsg::release_txtid() {
  clear_has_txtid();
  if (txtid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txtid_;
    txtid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// HeartBeat

// -------------------------------------------------------------------

// HeartBeatRst

// optional int64 time = 1;
inline bool HeartBeatRst::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartBeatRst::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartBeatRst::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartBeatRst::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 HeartBeatRst::time() const {
  return time_;
}
inline void HeartBeatRst::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// PlayerInRoomNotify

// required string gameType = 1;
inline bool PlayerInRoomNotify::has_gametype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInRoomNotify::set_has_gametype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInRoomNotify::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInRoomNotify::clear_gametype() {
  if (gametype_ != &::google::protobuf::internal::kEmptyString) {
    gametype_->clear();
  }
  clear_has_gametype();
}
inline const ::std::string& PlayerInRoomNotify::gametype() const {
  return *gametype_;
}
inline void PlayerInRoomNotify::set_gametype(const ::std::string& value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void PlayerInRoomNotify::set_gametype(const char* value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void PlayerInRoomNotify::set_gametype(const char* value, size_t size) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInRoomNotify::mutable_gametype() {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  return gametype_;
}
inline ::std::string* PlayerInRoomNotify::release_gametype() {
  clear_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gametype_;
    gametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 roomType = 2;
inline bool PlayerInRoomNotify::has_roomtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInRoomNotify::set_has_roomtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInRoomNotify::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInRoomNotify::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 PlayerInRoomNotify::roomtype() const {
  return roomtype_;
}
inline void PlayerInRoomNotify::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// -------------------------------------------------------------------

// RoleInfo

// optional string name = 1;
inline bool RoleInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoleInfo::name() const {
  return *name_;
}
inline void RoleInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoleInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoleInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RoleInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 sex = 2;
inline bool RoleInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 RoleInfo::sex() const {
  return sex_;
}
inline void RoleInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string phone = 3;
inline bool RoleInfo::has_phone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleInfo::set_has_phone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleInfo::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& RoleInfo::phone() const {
  return *phone_;
}
inline void RoleInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RoleInfo::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RoleInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleInfo::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* RoleInfo::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SysMail

// required string mailId = 1;
inline bool SysMail::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysMail::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysMail::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysMail::clear_mailid() {
  if (mailid_ != &::google::protobuf::internal::kEmptyString) {
    mailid_->clear();
  }
  clear_has_mailid();
}
inline const ::std::string& SysMail::mailid() const {
  return *mailid_;
}
inline void SysMail::set_mailid(const ::std::string& value) {
  set_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    mailid_ = new ::std::string;
  }
  mailid_->assign(value);
}
inline void SysMail::set_mailid(const char* value) {
  set_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    mailid_ = new ::std::string;
  }
  mailid_->assign(value);
}
inline void SysMail::set_mailid(const char* value, size_t size) {
  set_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    mailid_ = new ::std::string;
  }
  mailid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SysMail::mutable_mailid() {
  set_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    mailid_ = new ::std::string;
  }
  return mailid_;
}
inline ::std::string* SysMail::release_mailid() {
  clear_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailid_;
    mailid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 version = 2;
inline bool SysMail::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysMail::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysMail::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysMail::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 SysMail::version() const {
  return version_;
}
inline void SysMail::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required string title = 3;
inline bool SysMail::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysMail::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysMail::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysMail::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& SysMail::title() const {
  return *title_;
}
inline void SysMail::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void SysMail::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void SysMail::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SysMail::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* SysMail::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string content = 4;
inline bool SysMail::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SysMail::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SysMail::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SysMail::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& SysMail::content() const {
  return *content_;
}
inline void SysMail::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SysMail::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SysMail::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SysMail::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* SysMail::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 sendtime = 5;
inline bool SysMail::has_sendtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SysMail::set_has_sendtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SysMail::clear_has_sendtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SysMail::clear_sendtime() {
  sendtime_ = 0;
  clear_has_sendtime();
}
inline ::google::protobuf::int32 SysMail::sendtime() const {
  return sendtime_;
}
inline void SysMail::set_sendtime(::google::protobuf::int32 value) {
  set_has_sendtime();
  sendtime_ = value;
}

// optional string attach = 6;
inline bool SysMail::has_attach() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SysMail::set_has_attach() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SysMail::clear_has_attach() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SysMail::clear_attach() {
  if (attach_ != &::google::protobuf::internal::kEmptyString) {
    attach_->clear();
  }
  clear_has_attach();
}
inline const ::std::string& SysMail::attach() const {
  return *attach_;
}
inline void SysMail::set_attach(const ::std::string& value) {
  set_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    attach_ = new ::std::string;
  }
  attach_->assign(value);
}
inline void SysMail::set_attach(const char* value) {
  set_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    attach_ = new ::std::string;
  }
  attach_->assign(value);
}
inline void SysMail::set_attach(const char* value, size_t size) {
  set_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    attach_ = new ::std::string;
  }
  attach_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SysMail::mutable_attach() {
  set_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    attach_ = new ::std::string;
  }
  return attach_;
}
inline ::std::string* SysMail::release_attach() {
  clear_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_;
    attach_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 overduetime = 7;
inline bool SysMail::has_overduetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SysMail::set_has_overduetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SysMail::clear_has_overduetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SysMail::clear_overduetime() {
  overduetime_ = 0;
  clear_has_overduetime();
}
inline ::google::protobuf::int32 SysMail::overduetime() const {
  return overduetime_;
}
inline void SysMail::set_overduetime(::google::protobuf::int32 value) {
  set_has_overduetime();
  overduetime_ = value;
}

// optional bool bRead = 8;
inline bool SysMail::has_bread() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SysMail::set_has_bread() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SysMail::clear_has_bread() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SysMail::clear_bread() {
  bread_ = false;
  clear_has_bread();
}
inline bool SysMail::bread() const {
  return bread_;
}
inline void SysMail::set_bread(bool value) {
  set_has_bread();
  bread_ = value;
}

// -------------------------------------------------------------------

// PlayerMailInfo

// required int32 sysmail_version = 1;
inline bool PlayerMailInfo::has_sysmail_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerMailInfo::set_has_sysmail_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerMailInfo::clear_has_sysmail_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerMailInfo::clear_sysmail_version() {
  sysmail_version_ = 0;
  clear_has_sysmail_version();
}
inline ::google::protobuf::int32 PlayerMailInfo::sysmail_version() const {
  return sysmail_version_;
}
inline void PlayerMailInfo::set_sysmail_version(::google::protobuf::int32 value) {
  set_has_sysmail_version();
  sysmail_version_ = value;
}

// repeated .rpc.SysMail maillist = 2;
inline int PlayerMailInfo::maillist_size() const {
  return maillist_.size();
}
inline void PlayerMailInfo::clear_maillist() {
  maillist_.Clear();
}
inline const ::rpc::SysMail& PlayerMailInfo::maillist(int index) const {
  return maillist_.Get(index);
}
inline ::rpc::SysMail* PlayerMailInfo::mutable_maillist(int index) {
  return maillist_.Mutable(index);
}
inline ::rpc::SysMail* PlayerMailInfo::add_maillist() {
  return maillist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::SysMail >&
PlayerMailInfo::maillist() const {
  return maillist_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::SysMail >*
PlayerMailInfo::mutable_maillist() {
  return &maillist_;
}

// -------------------------------------------------------------------

// ReqReadOneMail

// required string mailId = 1;
inline bool ReqReadOneMail::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqReadOneMail::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqReadOneMail::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqReadOneMail::clear_mailid() {
  if (mailid_ != &::google::protobuf::internal::kEmptyString) {
    mailid_->clear();
  }
  clear_has_mailid();
}
inline const ::std::string& ReqReadOneMail::mailid() const {
  return *mailid_;
}
inline void ReqReadOneMail::set_mailid(const ::std::string& value) {
  set_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    mailid_ = new ::std::string;
  }
  mailid_->assign(value);
}
inline void ReqReadOneMail::set_mailid(const char* value) {
  set_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    mailid_ = new ::std::string;
  }
  mailid_->assign(value);
}
inline void ReqReadOneMail::set_mailid(const char* value, size_t size) {
  set_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    mailid_ = new ::std::string;
  }
  mailid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqReadOneMail::mutable_mailid() {
  set_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    mailid_ = new ::std::string;
  }
  return mailid_;
}
inline ::std::string* ReqReadOneMail::release_mailid() {
  clear_has_mailid();
  if (mailid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailid_;
    mailid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RemoveMailNotify

// repeated int32 mailIds = 1;
inline int RemoveMailNotify::mailids_size() const {
  return mailids_.size();
}
inline void RemoveMailNotify::clear_mailids() {
  mailids_.Clear();
}
inline ::google::protobuf::int32 RemoveMailNotify::mailids(int index) const {
  return mailids_.Get(index);
}
inline void RemoveMailNotify::set_mailids(int index, ::google::protobuf::int32 value) {
  mailids_.Set(index, value);
}
inline void RemoveMailNotify::add_mailids(::google::protobuf::int32 value) {
  mailids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RemoveMailNotify::mailids() const {
  return mailids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RemoveMailNotify::mutable_mailids() {
  return &mailids_;
}

// -------------------------------------------------------------------

// AddMailNotify

// repeated .rpc.SysMail maillist = 1;
inline int AddMailNotify::maillist_size() const {
  return maillist_.size();
}
inline void AddMailNotify::clear_maillist() {
  maillist_.Clear();
}
inline const ::rpc::SysMail& AddMailNotify::maillist(int index) const {
  return maillist_.Get(index);
}
inline ::rpc::SysMail* AddMailNotify::mutable_maillist(int index) {
  return maillist_.Mutable(index);
}
inline ::rpc::SysMail* AddMailNotify::add_maillist() {
  return maillist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::SysMail >&
AddMailNotify::maillist() const {
  return maillist_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::SysMail >*
AddMailNotify::mutable_maillist() {
  return &maillist_;
}

// -------------------------------------------------------------------

// ReqBroadCast

// required string playerID = 1;
inline bool ReqBroadCast::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqBroadCast::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqBroadCast::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqBroadCast::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& ReqBroadCast::playerid() const {
  return *playerid_;
}
inline void ReqBroadCast::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ReqBroadCast::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ReqBroadCast::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqBroadCast::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* ReqBroadCast::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string content = 2;
inline bool ReqBroadCast::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqBroadCast::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqBroadCast::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqBroadCast::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ReqBroadCast::content() const {
  return *content_;
}
inline void ReqBroadCast::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ReqBroadCast::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ReqBroadCast::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqBroadCast::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* ReqBroadCast::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool bVip = 3;
inline bool ReqBroadCast::has_bvip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqBroadCast::set_has_bvip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqBroadCast::clear_has_bvip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqBroadCast::clear_bvip() {
  bvip_ = false;
  clear_has_bvip();
}
inline bool ReqBroadCast::bvip() const {
  return bvip_;
}
inline void ReqBroadCast::set_bvip(bool value) {
  set_has_bvip();
  bvip_ = value;
}

// optional string playerName = 4;
inline bool ReqBroadCast::has_playername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqBroadCast::set_has_playername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqBroadCast::clear_has_playername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqBroadCast::clear_playername() {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    playername_->clear();
  }
  clear_has_playername();
}
inline const ::std::string& ReqBroadCast::playername() const {
  return *playername_;
}
inline void ReqBroadCast::set_playername(const ::std::string& value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void ReqBroadCast::set_playername(const char* value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void ReqBroadCast::set_playername(const char* value, size_t size) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqBroadCast::mutable_playername() {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  return playername_;
}
inline ::std::string* ReqBroadCast::release_playername() {
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BroadCastNotify

// required int32 broadCastID = 1;
inline bool BroadCastNotify::has_broadcastid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadCastNotify::set_has_broadcastid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadCastNotify::clear_has_broadcastid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadCastNotify::clear_broadcastid() {
  broadcastid_ = 0;
  clear_has_broadcastid();
}
inline ::google::protobuf::int32 BroadCastNotify::broadcastid() const {
  return broadcastid_;
}
inline void BroadCastNotify::set_broadcastid(::google::protobuf::int32 value) {
  set_has_broadcastid();
  broadcastid_ = value;
}

// required bool sysBroad = 2;
inline bool BroadCastNotify::has_sysbroad() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadCastNotify::set_has_sysbroad() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadCastNotify::clear_has_sysbroad() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadCastNotify::clear_sysbroad() {
  sysbroad_ = false;
  clear_has_sysbroad();
}
inline bool BroadCastNotify::sysbroad() const {
  return sysbroad_;
}
inline void BroadCastNotify::set_sysbroad(bool value) {
  set_has_sysbroad();
  sysbroad_ = value;
}

// required string content = 3;
inline bool BroadCastNotify::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BroadCastNotify::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BroadCastNotify::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BroadCastNotify::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& BroadCastNotify::content() const {
  return *content_;
}
inline void BroadCastNotify::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void BroadCastNotify::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void BroadCastNotify::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadCastNotify::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* BroadCastNotify::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string playerName = 4;
inline bool BroadCastNotify::has_playername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BroadCastNotify::set_has_playername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BroadCastNotify::clear_has_playername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BroadCastNotify::clear_playername() {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    playername_->clear();
  }
  clear_has_playername();
}
inline const ::std::string& BroadCastNotify::playername() const {
  return *playername_;
}
inline void BroadCastNotify::set_playername(const ::std::string& value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void BroadCastNotify::set_playername(const char* value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void BroadCastNotify::set_playername(const char* value, size_t size) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadCastNotify::mutable_playername() {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  return playername_;
}
inline ::std::string* BroadCastNotify::release_playername() {
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string playerID = 5;
inline bool BroadCastNotify::has_playerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BroadCastNotify::set_has_playerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BroadCastNotify::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BroadCastNotify::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& BroadCastNotify::playerid() const {
  return *playerid_;
}
inline void BroadCastNotify::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void BroadCastNotify::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void BroadCastNotify::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadCastNotify::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* BroadCastNotify::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool vip = 6;
inline bool BroadCastNotify::has_vip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BroadCastNotify::set_has_vip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BroadCastNotify::clear_has_vip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BroadCastNotify::clear_vip() {
  vip_ = false;
  clear_has_vip();
}
inline bool BroadCastNotify::vip() const {
  return vip_;
}
inline void BroadCastNotify::set_vip(bool value) {
  set_has_vip();
  vip_ = value;
}

// -------------------------------------------------------------------

// FightChat

// optional int32 chatType = 1;
inline bool FightChat::has_chattype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightChat::set_has_chattype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightChat::clear_has_chattype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightChat::clear_chattype() {
  chattype_ = 0;
  clear_has_chattype();
}
inline ::google::protobuf::int32 FightChat::chattype() const {
  return chattype_;
}
inline void FightChat::set_chattype(::google::protobuf::int32 value) {
  set_has_chattype();
  chattype_ = value;
}

// optional int32 faceID = 2;
inline bool FightChat::has_faceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightChat::set_has_faceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightChat::clear_has_faceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightChat::clear_faceid() {
  faceid_ = 0;
  clear_has_faceid();
}
inline ::google::protobuf::int32 FightChat::faceid() const {
  return faceid_;
}
inline void FightChat::set_faceid(::google::protobuf::int32 value) {
  set_has_faceid();
  faceid_ = value;
}

// optional int32 fixWordID = 3;
inline bool FightChat::has_fixwordid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightChat::set_has_fixwordid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightChat::clear_has_fixwordid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightChat::clear_fixwordid() {
  fixwordid_ = 0;
  clear_has_fixwordid();
}
inline ::google::protobuf::int32 FightChat::fixwordid() const {
  return fixwordid_;
}
inline void FightChat::set_fixwordid(::google::protobuf::int32 value) {
  set_has_fixwordid();
  fixwordid_ = value;
}

// optional string gameType = 4;
inline bool FightChat::has_gametype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightChat::set_has_gametype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightChat::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightChat::clear_gametype() {
  if (gametype_ != &::google::protobuf::internal::kEmptyString) {
    gametype_->clear();
  }
  clear_has_gametype();
}
inline const ::std::string& FightChat::gametype() const {
  return *gametype_;
}
inline void FightChat::set_gametype(const ::std::string& value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void FightChat::set_gametype(const char* value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void FightChat::set_gametype(const char* value, size_t size) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightChat::mutable_gametype() {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  return gametype_;
}
inline ::std::string* FightChat::release_gametype() {
  clear_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gametype_;
    gametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string customContent = 5;
inline bool FightChat::has_customcontent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightChat::set_has_customcontent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightChat::clear_has_customcontent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightChat::clear_customcontent() {
  if (customcontent_ != &::google::protobuf::internal::kEmptyString) {
    customcontent_->clear();
  }
  clear_has_customcontent();
}
inline const ::std::string& FightChat::customcontent() const {
  return *customcontent_;
}
inline void FightChat::set_customcontent(const ::std::string& value) {
  set_has_customcontent();
  if (customcontent_ == &::google::protobuf::internal::kEmptyString) {
    customcontent_ = new ::std::string;
  }
  customcontent_->assign(value);
}
inline void FightChat::set_customcontent(const char* value) {
  set_has_customcontent();
  if (customcontent_ == &::google::protobuf::internal::kEmptyString) {
    customcontent_ = new ::std::string;
  }
  customcontent_->assign(value);
}
inline void FightChat::set_customcontent(const char* value, size_t size) {
  set_has_customcontent();
  if (customcontent_ == &::google::protobuf::internal::kEmptyString) {
    customcontent_ = new ::std::string;
  }
  customcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightChat::mutable_customcontent() {
  set_has_customcontent();
  if (customcontent_ == &::google::protobuf::internal::kEmptyString) {
    customcontent_ = new ::std::string;
  }
  return customcontent_;
}
inline ::std::string* FightChat::release_customcontent() {
  clear_has_customcontent();
  if (customcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customcontent_;
    customcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string itemId = 6;
inline bool FightChat::has_itemid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FightChat::set_has_itemid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FightChat::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FightChat::clear_itemid() {
  if (itemid_ != &::google::protobuf::internal::kEmptyString) {
    itemid_->clear();
  }
  clear_has_itemid();
}
inline const ::std::string& FightChat::itemid() const {
  return *itemid_;
}
inline void FightChat::set_itemid(const ::std::string& value) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(value);
}
inline void FightChat::set_itemid(const char* value) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(value);
}
inline void FightChat::set_itemid(const char* value, size_t size) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightChat::mutable_itemid() {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  return itemid_;
}
inline ::std::string* FightChat::release_itemid() {
  clear_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = itemid_;
    itemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string receiverPlayerID = 7;
inline bool FightChat::has_receiverplayerid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FightChat::set_has_receiverplayerid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FightChat::clear_has_receiverplayerid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FightChat::clear_receiverplayerid() {
  if (receiverplayerid_ != &::google::protobuf::internal::kEmptyString) {
    receiverplayerid_->clear();
  }
  clear_has_receiverplayerid();
}
inline const ::std::string& FightChat::receiverplayerid() const {
  return *receiverplayerid_;
}
inline void FightChat::set_receiverplayerid(const ::std::string& value) {
  set_has_receiverplayerid();
  if (receiverplayerid_ == &::google::protobuf::internal::kEmptyString) {
    receiverplayerid_ = new ::std::string;
  }
  receiverplayerid_->assign(value);
}
inline void FightChat::set_receiverplayerid(const char* value) {
  set_has_receiverplayerid();
  if (receiverplayerid_ == &::google::protobuf::internal::kEmptyString) {
    receiverplayerid_ = new ::std::string;
  }
  receiverplayerid_->assign(value);
}
inline void FightChat::set_receiverplayerid(const char* value, size_t size) {
  set_has_receiverplayerid();
  if (receiverplayerid_ == &::google::protobuf::internal::kEmptyString) {
    receiverplayerid_ = new ::std::string;
  }
  receiverplayerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightChat::mutable_receiverplayerid() {
  set_has_receiverplayerid();
  if (receiverplayerid_ == &::google::protobuf::internal::kEmptyString) {
    receiverplayerid_ = new ::std::string;
  }
  return receiverplayerid_;
}
inline ::std::string* FightChat::release_receiverplayerid() {
  clear_has_receiverplayerid();
  if (receiverplayerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiverplayerid_;
    receiverplayerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqFightRoomChat

// required string playerID = 1;
inline bool ReqFightRoomChat::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqFightRoomChat::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqFightRoomChat::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqFightRoomChat::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& ReqFightRoomChat::playerid() const {
  return *playerid_;
}
inline void ReqFightRoomChat::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ReqFightRoomChat::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ReqFightRoomChat::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqFightRoomChat::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* ReqFightRoomChat::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .rpc.FightChat fighChatinfo = 2;
inline bool ReqFightRoomChat::has_fighchatinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqFightRoomChat::set_has_fighchatinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqFightRoomChat::clear_has_fighchatinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqFightRoomChat::clear_fighchatinfo() {
  if (fighchatinfo_ != NULL) fighchatinfo_->::rpc::FightChat::Clear();
  clear_has_fighchatinfo();
}
inline const ::rpc::FightChat& ReqFightRoomChat::fighchatinfo() const {
  return fighchatinfo_ != NULL ? *fighchatinfo_ : *default_instance_->fighchatinfo_;
}
inline ::rpc::FightChat* ReqFightRoomChat::mutable_fighchatinfo() {
  set_has_fighchatinfo();
  if (fighchatinfo_ == NULL) fighchatinfo_ = new ::rpc::FightChat;
  return fighchatinfo_;
}
inline ::rpc::FightChat* ReqFightRoomChat::release_fighchatinfo() {
  clear_has_fighchatinfo();
  ::rpc::FightChat* temp = fighchatinfo_;
  fighchatinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// FightRoomChatNotify

// required string playerID = 1;
inline bool FightRoomChatNotify::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightRoomChatNotify::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightRoomChatNotify::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightRoomChatNotify::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& FightRoomChatNotify::playerid() const {
  return *playerid_;
}
inline void FightRoomChatNotify::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void FightRoomChatNotify::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void FightRoomChatNotify::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightRoomChatNotify::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* FightRoomChatNotify::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .rpc.FightChat fighChatinfo = 2;
inline bool FightRoomChatNotify::has_fighchatinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightRoomChatNotify::set_has_fighchatinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightRoomChatNotify::clear_has_fighchatinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightRoomChatNotify::clear_fighchatinfo() {
  if (fighchatinfo_ != NULL) fighchatinfo_->::rpc::FightChat::Clear();
  clear_has_fighchatinfo();
}
inline const ::rpc::FightChat& FightRoomChatNotify::fighchatinfo() const {
  return fighchatinfo_ != NULL ? *fighchatinfo_ : *default_instance_->fighchatinfo_;
}
inline ::rpc::FightChat* FightRoomChatNotify::mutable_fighchatinfo() {
  set_has_fighchatinfo();
  if (fighchatinfo_ == NULL) fighchatinfo_ = new ::rpc::FightChat;
  return fighchatinfo_;
}
inline ::rpc::FightChat* FightRoomChatNotify::release_fighchatinfo() {
  clear_has_fighchatinfo();
  ::rpc::FightChat* temp = fighchatinfo_;
  fighchatinfo_ = NULL;
  return temp;
}

// optional bool offline = 3;
inline bool FightRoomChatNotify::has_offline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightRoomChatNotify::set_has_offline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightRoomChatNotify::clear_has_offline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightRoomChatNotify::clear_offline() {
  offline_ = false;
  clear_has_offline();
}
inline bool FightRoomChatNotify::offline() const {
  return offline_;
}
inline void FightRoomChatNotify::set_offline(bool value) {
  set_has_offline();
  offline_ = value;
}

// -------------------------------------------------------------------

// Notice

// required string content = 1;
inline bool Notice::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notice::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notice::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notice::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Notice::content() const {
  return *content_;
}
inline void Notice::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Notice::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Notice::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notice::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* Notice::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqInsurenceMoney

// required bool bWithdraw = 1;
inline bool ReqInsurenceMoney::has_bwithdraw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqInsurenceMoney::set_has_bwithdraw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqInsurenceMoney::clear_has_bwithdraw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqInsurenceMoney::clear_bwithdraw() {
  bwithdraw_ = false;
  clear_has_bwithdraw();
}
inline bool ReqInsurenceMoney::bwithdraw() const {
  return bwithdraw_;
}
inline void ReqInsurenceMoney::set_bwithdraw(bool value) {
  set_has_bwithdraw();
  bwithdraw_ = value;
}

// required int32 value = 2;
inline bool ReqInsurenceMoney::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqInsurenceMoney::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqInsurenceMoney::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqInsurenceMoney::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 ReqInsurenceMoney::value() const {
  return value_;
}
inline void ReqInsurenceMoney::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// Player

// required string name = 1;
inline bool Player::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Player::name() const {
  return *name_;
}
inline void Player::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Player::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Player::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Player::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 sex = 2;
inline bool Player::has_sex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player::set_has_sex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player::clear_has_sex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 Player::sex() const {
  return sex_;
}
inline void Player::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// required int32 level = 3;
inline bool Player::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Player::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Player::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Player::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Player::level() const {
  return level_;
}
inline void Player::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 header = 4;
inline bool Player::has_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player::set_has_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Player::clear_has_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Player::clear_header() {
  header_ = 0;
  clear_has_header();
}
inline ::google::protobuf::int32 Player::header() const {
  return header_;
}
inline void Player::set_header(::google::protobuf::int32 value) {
  set_has_header();
  header_ = value;
}

// optional int32 roleId = 5;
inline bool Player::has_roleid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Player::set_has_roleid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Player::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Player::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 Player::roleid() const {
  return roleid_;
}
inline void Player::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
}

// optional string headerUrl = 6;
inline bool Player::has_headerurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Player::set_has_headerurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Player::clear_has_headerurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Player::clear_headerurl() {
  if (headerurl_ != &::google::protobuf::internal::kEmptyString) {
    headerurl_->clear();
  }
  clear_has_headerurl();
}
inline const ::std::string& Player::headerurl() const {
  return *headerurl_;
}
inline void Player::set_headerurl(const ::std::string& value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void Player::set_headerurl(const char* value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void Player::set_headerurl(const char* value, size_t size) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player::mutable_headerurl() {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  return headerurl_;
}
inline ::std::string* Player::release_headerurl() {
  clear_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headerurl_;
    headerurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uid = 7;
inline bool Player::has_uid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Player::set_has_uid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Player::clear_has_uid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Player::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& Player::uid() const {
  return *uid_;
}
inline void Player::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Player::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Player::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* Player::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool bOnline = 8;
inline bool Player::has_bonline() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Player::set_has_bonline() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Player::clear_has_bonline() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Player::clear_bonline() {
  bonline_ = false;
  clear_has_bonline();
}
inline bool Player::bonline() const {
  return bonline_;
}
inline void Player::set_bonline(bool value) {
  set_has_bonline();
  bonline_ = value;
}

// optional int32 exp = 9;
inline bool Player::has_exp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Player::set_has_exp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Player::clear_has_exp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Player::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 Player::exp() const {
  return exp_;
}
inline void Player::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 coin = 10;
inline bool Player::has_coin() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Player::set_has_coin() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Player::clear_has_coin() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Player::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 Player::coin() const {
  return coin_;
}
inline void Player::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// repeated .rpc.Score scores = 11;
inline int Player::scores_size() const {
  return scores_.size();
}
inline void Player::clear_scores() {
  scores_.Clear();
}
inline const ::rpc::Score& Player::scores(int index) const {
  return scores_.Get(index);
}
inline ::rpc::Score* Player::mutable_scores(int index) {
  return scores_.Mutable(index);
}
inline ::rpc::Score* Player::add_scores() {
  return scores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Score >&
Player::scores() const {
  return scores_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Score >*
Player::mutable_scores() {
  return &scores_;
}

// optional int32 diamond = 12;
inline bool Player::has_diamond() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Player::set_has_diamond() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Player::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Player::clear_diamond() {
  diamond_ = 0;
  clear_has_diamond();
}
inline ::google::protobuf::int32 Player::diamond() const {
  return diamond_;
}
inline void Player::set_diamond(::google::protobuf::int32 value) {
  set_has_diamond();
  diamond_ = value;
}

// -------------------------------------------------------------------

// FriendsList

// repeated .rpc.Player friends = 1;
inline int FriendsList::friends_size() const {
  return friends_.size();
}
inline void FriendsList::clear_friends() {
  friends_.Clear();
}
inline const ::rpc::Player& FriendsList::friends(int index) const {
  return friends_.Get(index);
}
inline ::rpc::Player* FriendsList::mutable_friends(int index) {
  return friends_.Mutable(index);
}
inline ::rpc::Player* FriendsList::add_friends() {
  return friends_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Player >&
FriendsList::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Player >*
FriendsList::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// RequestFriendsList

// repeated .rpc.Player friends = 1;
inline int RequestFriendsList::friends_size() const {
  return friends_.size();
}
inline void RequestFriendsList::clear_friends() {
  friends_.Clear();
}
inline const ::rpc::Player& RequestFriendsList::friends(int index) const {
  return friends_.Get(index);
}
inline ::rpc::Player* RequestFriendsList::mutable_friends(int index) {
  return friends_.Mutable(index);
}
inline ::rpc::Player* RequestFriendsList::add_friends() {
  return friends_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Player >&
RequestFriendsList::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Player >*
RequestFriendsList::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// ReqString

// optional string id = 1;
inline bool ReqString::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqString::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqString::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqString::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ReqString::id() const {
  return *id_;
}
inline void ReqString::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ReqString::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ReqString::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqString::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ReqString::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqInt

// optional int32 id = 1;
inline bool ReqInt::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqInt::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqInt::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqInt::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ReqInt::id() const {
  return id_;
}
inline void ReqInt::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// SearchFriendNofify

// optional .rpc.Player player = 1;
inline bool SearchFriendNofify::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchFriendNofify::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchFriendNofify::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchFriendNofify::clear_player() {
  if (player_ != NULL) player_->::rpc::Player::Clear();
  clear_has_player();
}
inline const ::rpc::Player& SearchFriendNofify::player() const {
  return player_ != NULL ? *player_ : *default_instance_->player_;
}
inline ::rpc::Player* SearchFriendNofify::mutable_player() {
  set_has_player();
  if (player_ == NULL) player_ = new ::rpc::Player;
  return player_;
}
inline ::rpc::Player* SearchFriendNofify::release_player() {
  clear_has_player();
  ::rpc::Player* temp = player_;
  player_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ReqResponseAddFriend

// required string uid = 1;
inline bool ReqResponseAddFriend::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqResponseAddFriend::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqResponseAddFriend::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqResponseAddFriend::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& ReqResponseAddFriend::uid() const {
  return *uid_;
}
inline void ReqResponseAddFriend::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void ReqResponseAddFriend::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void ReqResponseAddFriend::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqResponseAddFriend::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* ReqResponseAddFriend::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool bAccept = 2;
inline bool ReqResponseAddFriend::has_baccept() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqResponseAddFriend::set_has_baccept() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqResponseAddFriend::clear_has_baccept() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqResponseAddFriend::clear_baccept() {
  baccept_ = false;
  clear_has_baccept();
}
inline bool ReqResponseAddFriend::baccept() const {
  return baccept_;
}
inline void ReqResponseAddFriend::set_baccept(bool value) {
  set_has_baccept();
  baccept_ = value;
}

// -------------------------------------------------------------------

// AddFriendNofify

// required int32 rst = 1;
inline bool AddFriendNofify::has_rst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddFriendNofify::set_has_rst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddFriendNofify::clear_has_rst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddFriendNofify::clear_rst() {
  rst_ = 0;
  clear_has_rst();
}
inline ::google::protobuf::int32 AddFriendNofify::rst() const {
  return rst_;
}
inline void AddFriendNofify::set_rst(::google::protobuf::int32 value) {
  set_has_rst();
  rst_ = value;
}

// -------------------------------------------------------------------

// DelFriendNofity

// required int32 rst = 1;
inline bool DelFriendNofity::has_rst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelFriendNofity::set_has_rst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelFriendNofity::clear_has_rst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelFriendNofity::clear_rst() {
  rst_ = 0;
  clear_has_rst();
}
inline ::google::protobuf::int32 DelFriendNofity::rst() const {
  return rst_;
}
inline void DelFriendNofity::set_rst(::google::protobuf::int32 value) {
  set_has_rst();
  rst_ = value;
}

// required string id = 2;
inline bool DelFriendNofity::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelFriendNofity::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelFriendNofity::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelFriendNofity::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& DelFriendNofity::id() const {
  return *id_;
}
inline void DelFriendNofity::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DelFriendNofity::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DelFriendNofity::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DelFriendNofity::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* DelFriendNofity::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FriendsIdList

// repeated string friends = 1;
inline int FriendsIdList::friends_size() const {
  return friends_.size();
}
inline void FriendsIdList::clear_friends() {
  friends_.Clear();
}
inline const ::std::string& FriendsIdList::friends(int index) const {
  return friends_.Get(index);
}
inline ::std::string* FriendsIdList::mutable_friends(int index) {
  return friends_.Mutable(index);
}
inline void FriendsIdList::set_friends(int index, const ::std::string& value) {
  friends_.Mutable(index)->assign(value);
}
inline void FriendsIdList::set_friends(int index, const char* value) {
  friends_.Mutable(index)->assign(value);
}
inline void FriendsIdList::set_friends(int index, const char* value, size_t size) {
  friends_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendsIdList::add_friends() {
  return friends_.Add();
}
inline void FriendsIdList::add_friends(const ::std::string& value) {
  friends_.Add()->assign(value);
}
inline void FriendsIdList::add_friends(const char* value) {
  friends_.Add()->assign(value);
}
inline void FriendsIdList::add_friends(const char* value, size_t size) {
  friends_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FriendsIdList::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FriendsIdList::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// SendFriendChat

// required string senderUid = 1;
inline bool SendFriendChat::has_senderuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendFriendChat::set_has_senderuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendFriendChat::clear_has_senderuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendFriendChat::clear_senderuid() {
  if (senderuid_ != &::google::protobuf::internal::kEmptyString) {
    senderuid_->clear();
  }
  clear_has_senderuid();
}
inline const ::std::string& SendFriendChat::senderuid() const {
  return *senderuid_;
}
inline void SendFriendChat::set_senderuid(const ::std::string& value) {
  set_has_senderuid();
  if (senderuid_ == &::google::protobuf::internal::kEmptyString) {
    senderuid_ = new ::std::string;
  }
  senderuid_->assign(value);
}
inline void SendFriendChat::set_senderuid(const char* value) {
  set_has_senderuid();
  if (senderuid_ == &::google::protobuf::internal::kEmptyString) {
    senderuid_ = new ::std::string;
  }
  senderuid_->assign(value);
}
inline void SendFriendChat::set_senderuid(const char* value, size_t size) {
  set_has_senderuid();
  if (senderuid_ == &::google::protobuf::internal::kEmptyString) {
    senderuid_ = new ::std::string;
  }
  senderuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendFriendChat::mutable_senderuid() {
  set_has_senderuid();
  if (senderuid_ == &::google::protobuf::internal::kEmptyString) {
    senderuid_ = new ::std::string;
  }
  return senderuid_;
}
inline ::std::string* SendFriendChat::release_senderuid() {
  clear_has_senderuid();
  if (senderuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = senderuid_;
    senderuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string receiverUid = 2;
inline bool SendFriendChat::has_receiveruid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendFriendChat::set_has_receiveruid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendFriendChat::clear_has_receiveruid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendFriendChat::clear_receiveruid() {
  if (receiveruid_ != &::google::protobuf::internal::kEmptyString) {
    receiveruid_->clear();
  }
  clear_has_receiveruid();
}
inline const ::std::string& SendFriendChat::receiveruid() const {
  return *receiveruid_;
}
inline void SendFriendChat::set_receiveruid(const ::std::string& value) {
  set_has_receiveruid();
  if (receiveruid_ == &::google::protobuf::internal::kEmptyString) {
    receiveruid_ = new ::std::string;
  }
  receiveruid_->assign(value);
}
inline void SendFriendChat::set_receiveruid(const char* value) {
  set_has_receiveruid();
  if (receiveruid_ == &::google::protobuf::internal::kEmptyString) {
    receiveruid_ = new ::std::string;
  }
  receiveruid_->assign(value);
}
inline void SendFriendChat::set_receiveruid(const char* value, size_t size) {
  set_has_receiveruid();
  if (receiveruid_ == &::google::protobuf::internal::kEmptyString) {
    receiveruid_ = new ::std::string;
  }
  receiveruid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendFriendChat::mutable_receiveruid() {
  set_has_receiveruid();
  if (receiveruid_ == &::google::protobuf::internal::kEmptyString) {
    receiveruid_ = new ::std::string;
  }
  return receiveruid_;
}
inline ::std::string* SendFriendChat::release_receiveruid() {
  clear_has_receiveruid();
  if (receiveruid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiveruid_;
    receiveruid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string text = 3;
inline bool SendFriendChat::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendFriendChat::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendFriendChat::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendFriendChat::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SendFriendChat::text() const {
  return *text_;
}
inline void SendFriendChat::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SendFriendChat::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SendFriendChat::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendFriendChat::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SendFriendChat::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 sendtime = 4;
inline bool SendFriendChat::has_sendtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendFriendChat::set_has_sendtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendFriendChat::clear_has_sendtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendFriendChat::clear_sendtime() {
  sendtime_ = 0;
  clear_has_sendtime();
}
inline ::google::protobuf::int32 SendFriendChat::sendtime() const {
  return sendtime_;
}
inline void SendFriendChat::set_sendtime(::google::protobuf::int32 value) {
  set_has_sendtime();
  sendtime_ = value;
}

// -------------------------------------------------------------------

// OfflineMsgNofity

// repeated .rpc.SendFriendChat chatInfo = 1;
inline int OfflineMsgNofity::chatinfo_size() const {
  return chatinfo_.size();
}
inline void OfflineMsgNofity::clear_chatinfo() {
  chatinfo_.Clear();
}
inline const ::rpc::SendFriendChat& OfflineMsgNofity::chatinfo(int index) const {
  return chatinfo_.Get(index);
}
inline ::rpc::SendFriendChat* OfflineMsgNofity::mutable_chatinfo(int index) {
  return chatinfo_.Mutable(index);
}
inline ::rpc::SendFriendChat* OfflineMsgNofity::add_chatinfo() {
  return chatinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::SendFriendChat >&
OfflineMsgNofity::chatinfo() const {
  return chatinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::SendFriendChat >*
OfflineMsgNofity::mutable_chatinfo() {
  return &chatinfo_;
}

// -------------------------------------------------------------------

// FriendStatusNofify

// required string uid = 1;
inline bool FriendStatusNofify::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendStatusNofify::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendStatusNofify::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendStatusNofify::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& FriendStatusNofify::uid() const {
  return *uid_;
}
inline void FriendStatusNofify::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void FriendStatusNofify::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void FriendStatusNofify::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendStatusNofify::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* FriendStatusNofify::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool bOnline = 2;
inline bool FriendStatusNofify::has_bonline() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendStatusNofify::set_has_bonline() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendStatusNofify::clear_has_bonline() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendStatusNofify::clear_bonline() {
  bonline_ = false;
  clear_has_bonline();
}
inline bool FriendStatusNofify::bonline() const {
  return bonline_;
}
inline void FriendStatusNofify::set_bonline(bool value) {
  set_has_bonline();
  bonline_ = value;
}

// -------------------------------------------------------------------

// ErrorCodeNofify

// optional int32 code = 1;
inline bool ErrorCodeNofify::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorCodeNofify::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorCodeNofify::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorCodeNofify::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ErrorCodeNofify::code() const {
  return code_;
}
inline void ErrorCodeNofify::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// TaskFinishNofity

// optional string taskId = 1;
inline bool TaskFinishNofity::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskFinishNofity::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskFinishNofity::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskFinishNofity::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& TaskFinishNofity::taskid() const {
  return *taskid_;
}
inline void TaskFinishNofity::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void TaskFinishNofity::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void TaskFinishNofity::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskFinishNofity::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* TaskFinishNofity::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqTaskShare

// optional bool bShare2Friend = 1;
inline bool ReqTaskShare::has_bshare2friend() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqTaskShare::set_has_bshare2friend() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqTaskShare::clear_has_bshare2friend() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqTaskShare::clear_bshare2friend() {
  bshare2friend_ = false;
  clear_has_bshare2friend();
}
inline bool ReqTaskShare::bshare2friend() const {
  return bshare2friend_;
}
inline void ReqTaskShare::set_bshare2friend(bool value) {
  set_has_bshare2friend();
  bshare2friend_ = value;
}

// -------------------------------------------------------------------

// ReqRankList

// required int32 rankType = 1;
inline bool ReqRankList::has_ranktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqRankList::set_has_ranktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqRankList::clear_has_ranktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqRankList::clear_ranktype() {
  ranktype_ = 0;
  clear_has_ranktype();
}
inline ::google::protobuf::int32 ReqRankList::ranktype() const {
  return ranktype_;
}
inline void ReqRankList::set_ranktype(::google::protobuf::int32 value) {
  set_has_ranktype();
  ranktype_ = value;
}

// -------------------------------------------------------------------

// RankInfo

// required string uid = 1;
inline bool RankInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RankInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RankInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RankInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RankInfo::uid() const {
  return *uid_;
}
inline void RankInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RankInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RankInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RankInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RankInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 roleId = 2;
inline bool RankInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankInfo::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 RankInfo::roleid() const {
  return roleid_;
}
inline void RankInfo::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
}

// required int32 sex = 3;
inline bool RankInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RankInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RankInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RankInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 RankInfo::sex() const {
  return sex_;
}
inline void RankInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// required string name = 4;
inline bool RankInfo::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RankInfo::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RankInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RankInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RankInfo::name() const {
  return *name_;
}
inline void RankInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RankInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RankInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RankInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RankInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 level = 5;
inline bool RankInfo::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RankInfo::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RankInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RankInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 RankInfo::level() const {
  return level_;
}
inline void RankInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 exp = 6;
inline bool RankInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RankInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RankInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RankInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 RankInfo::exp() const {
  return exp_;
}
inline void RankInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// required bool bVip = 7;
inline bool RankInfo::has_bvip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RankInfo::set_has_bvip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RankInfo::clear_has_bvip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RankInfo::clear_bvip() {
  bvip_ = false;
  clear_has_bvip();
}
inline bool RankInfo::bvip() const {
  return bvip_;
}
inline void RankInfo::set_bvip(bool value) {
  set_has_bvip();
  bvip_ = value;
}

// required int32 coin = 8;
inline bool RankInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RankInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RankInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RankInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 RankInfo::coin() const {
  return coin_;
}
inline void RankInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// required int32 gem = 9;
inline bool RankInfo::has_gem() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RankInfo::set_has_gem() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RankInfo::clear_has_gem() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RankInfo::clear_gem() {
  gem_ = 0;
  clear_has_gem();
}
inline ::google::protobuf::int32 RankInfo::gem() const {
  return gem_;
}
inline void RankInfo::set_gem(::google::protobuf::int32 value) {
  set_has_gem();
  gem_ = value;
}

// required string headerUrl = 10;
inline bool RankInfo::has_headerurl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RankInfo::set_has_headerurl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RankInfo::clear_has_headerurl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RankInfo::clear_headerurl() {
  if (headerurl_ != &::google::protobuf::internal::kEmptyString) {
    headerurl_->clear();
  }
  clear_has_headerurl();
}
inline const ::std::string& RankInfo::headerurl() const {
  return *headerurl_;
}
inline void RankInfo::set_headerurl(const ::std::string& value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void RankInfo::set_headerurl(const char* value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void RankInfo::set_headerurl(const char* value, size_t size) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RankInfo::mutable_headerurl() {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  return headerurl_;
}
inline ::std::string* RankInfo::release_headerurl() {
  clear_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headerurl_;
    headerurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 rankValue = 11;
inline bool RankInfo::has_rankvalue() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RankInfo::set_has_rankvalue() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RankInfo::clear_has_rankvalue() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RankInfo::clear_rankvalue() {
  rankvalue_ = GOOGLE_LONGLONG(0);
  clear_has_rankvalue();
}
inline ::google::protobuf::int64 RankInfo::rankvalue() const {
  return rankvalue_;
}
inline void RankInfo::set_rankvalue(::google::protobuf::int64 value) {
  set_has_rankvalue();
  rankvalue_ = value;
}

// optional int32 rankNum = 12;
inline bool RankInfo::has_ranknum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RankInfo::set_has_ranknum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RankInfo::clear_has_ranknum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RankInfo::clear_ranknum() {
  ranknum_ = 0;
  clear_has_ranknum();
}
inline ::google::protobuf::int32 RankInfo::ranknum() const {
  return ranknum_;
}
inline void RankInfo::set_ranknum(::google::protobuf::int32 value) {
  set_has_ranknum();
  ranknum_ = value;
}

// -------------------------------------------------------------------

// RankList

// repeated .rpc.RankInfo rankList = 1;
inline int RankList::ranklist_size() const {
  return ranklist_.size();
}
inline void RankList::clear_ranklist() {
  ranklist_.Clear();
}
inline const ::rpc::RankInfo& RankList::ranklist(int index) const {
  return ranklist_.Get(index);
}
inline ::rpc::RankInfo* RankList::mutable_ranklist(int index) {
  return ranklist_.Mutable(index);
}
inline ::rpc::RankInfo* RankList::add_ranklist() {
  return ranklist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::RankInfo >&
RankList::ranklist() const {
  return ranklist_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::RankInfo >*
RankList::mutable_ranklist() {
  return &ranklist_;
}

// required int32 rankType = 2;
inline bool RankList::has_ranktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankList::set_has_ranktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankList::clear_has_ranktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankList::clear_ranktype() {
  ranktype_ = 0;
  clear_has_ranktype();
}
inline ::google::protobuf::int32 RankList::ranktype() const {
  return ranktype_;
}
inline void RankList::set_ranktype(::google::protobuf::int32 value) {
  set_has_ranktype();
  ranktype_ = value;
}

// -------------------------------------------------------------------

// FormatedMsg

// required string code = 1;
inline bool FormatedMsg::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormatedMsg::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormatedMsg::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormatedMsg::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& FormatedMsg::code() const {
  return *code_;
}
inline void FormatedMsg::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void FormatedMsg::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void FormatedMsg::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatedMsg::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* FormatedMsg::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .rpc.MsgArg args = 2;
inline int FormatedMsg::args_size() const {
  return args_.size();
}
inline void FormatedMsg::clear_args() {
  args_.Clear();
}
inline const ::rpc::MsgArg& FormatedMsg::args(int index) const {
  return args_.Get(index);
}
inline ::rpc::MsgArg* FormatedMsg::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::rpc::MsgArg* FormatedMsg::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MsgArg >&
FormatedMsg::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MsgArg >*
FormatedMsg::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// Msg

// optional string code = 1;
inline bool Msg::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& Msg::code() const {
  return *code_;
}
inline void Msg::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Msg::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void Msg::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* Msg::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string text = 2;
inline bool Msg::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Msg::text() const {
  return *text_;
}
inline void Msg::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Msg::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Msg::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Msg::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NumberMsg

// optional int32 value = 1;
inline bool NumberMsg::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NumberMsg::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NumberMsg::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NumberMsg::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 NumberMsg::value() const {
  return value_;
}
inline void NumberMsg::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// MsgArg

// optional string s = 1;
inline bool MsgArg::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgArg::set_has_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgArg::clear_has_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgArg::clear_s() {
  if (s_ != &::google::protobuf::internal::kEmptyString) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& MsgArg::s() const {
  return *s_;
}
inline void MsgArg::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void MsgArg::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void MsgArg::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgArg::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  return s_;
}
inline ::std::string* MsgArg::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 i = 2;
inline bool MsgArg::has_i() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgArg::set_has_i() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgArg::clear_has_i() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgArg::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline ::google::protobuf::int32 MsgArg::i() const {
  return i_;
}
inline void MsgArg::set_i(::google::protobuf::int32 value) {
  set_has_i();
  i_ = value;
}

// -------------------------------------------------------------------

// GuestBindOk

// optional bool success = 1;
inline bool GuestBindOk::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuestBindOk::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuestBindOk::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuestBindOk::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool GuestBindOk::success() const {
  return success_;
}
inline void GuestBindOk::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// -------------------------------------------------------------------

// Ping

// optional int64 ClientTime = 1;
inline bool Ping::has_clienttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_clienttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_clienttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_clienttime() {
  clienttime_ = GOOGLE_LONGLONG(0);
  clear_has_clienttime();
}
inline ::google::protobuf::int64 Ping::clienttime() const {
  return clienttime_;
}
inline void Ping::set_clienttime(::google::protobuf::int64 value) {
  set_has_clienttime();
  clienttime_ = value;
}

// -------------------------------------------------------------------

// PingResult

// required int32 server_time = 1;
inline bool PingResult::has_server_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingResult::set_has_server_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingResult::clear_has_server_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingResult::clear_server_time() {
  server_time_ = 0;
  clear_has_server_time();
}
inline ::google::protobuf::int32 PingResult::server_time() const {
  return server_time_;
}
inline void PingResult::set_server_time(::google::protobuf::int32 value) {
  set_has_server_time();
  server_time_ = value;
}

// -------------------------------------------------------------------

// KickPlayerMsg

// optional int32 time = 1;
inline bool KickPlayerMsg::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickPlayerMsg::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickPlayerMsg::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickPlayerMsg::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 KickPlayerMsg::time() const {
  return time_;
}
inline void KickPlayerMsg::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// C2SChatP2P

// required string ToPlayerId = 1;
inline bool C2SChatP2P::has_toplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2SChatP2P::set_has_toplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2SChatP2P::clear_has_toplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2SChatP2P::clear_toplayerid() {
  if (toplayerid_ != &::google::protobuf::internal::kEmptyString) {
    toplayerid_->clear();
  }
  clear_has_toplayerid();
}
inline const ::std::string& C2SChatP2P::toplayerid() const {
  return *toplayerid_;
}
inline void C2SChatP2P::set_toplayerid(const ::std::string& value) {
  set_has_toplayerid();
  if (toplayerid_ == &::google::protobuf::internal::kEmptyString) {
    toplayerid_ = new ::std::string;
  }
  toplayerid_->assign(value);
}
inline void C2SChatP2P::set_toplayerid(const char* value) {
  set_has_toplayerid();
  if (toplayerid_ == &::google::protobuf::internal::kEmptyString) {
    toplayerid_ = new ::std::string;
  }
  toplayerid_->assign(value);
}
inline void C2SChatP2P::set_toplayerid(const char* value, size_t size) {
  set_has_toplayerid();
  if (toplayerid_ == &::google::protobuf::internal::kEmptyString) {
    toplayerid_ = new ::std::string;
  }
  toplayerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2SChatP2P::mutable_toplayerid() {
  set_has_toplayerid();
  if (toplayerid_ == &::google::protobuf::internal::kEmptyString) {
    toplayerid_ = new ::std::string;
  }
  return toplayerid_;
}
inline ::std::string* C2SChatP2P::release_toplayerid() {
  clear_has_toplayerid();
  if (toplayerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toplayerid_;
    toplayerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ChatContent = 2;
inline bool C2SChatP2P::has_chatcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2SChatP2P::set_has_chatcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2SChatP2P::clear_has_chatcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2SChatP2P::clear_chatcontent() {
  if (chatcontent_ != &::google::protobuf::internal::kEmptyString) {
    chatcontent_->clear();
  }
  clear_has_chatcontent();
}
inline const ::std::string& C2SChatP2P::chatcontent() const {
  return *chatcontent_;
}
inline void C2SChatP2P::set_chatcontent(const ::std::string& value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void C2SChatP2P::set_chatcontent(const char* value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void C2SChatP2P::set_chatcontent(const char* value, size_t size) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2SChatP2P::mutable_chatcontent() {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  return chatcontent_;
}
inline ::std::string* C2SChatP2P::release_chatcontent() {
  clear_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatcontent_;
    chatcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2SChatAlliance

// required string ChatContent = 1;
inline bool C2SChatAlliance::has_chatcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2SChatAlliance::set_has_chatcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2SChatAlliance::clear_has_chatcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2SChatAlliance::clear_chatcontent() {
  if (chatcontent_ != &::google::protobuf::internal::kEmptyString) {
    chatcontent_->clear();
  }
  clear_has_chatcontent();
}
inline const ::std::string& C2SChatAlliance::chatcontent() const {
  return *chatcontent_;
}
inline void C2SChatAlliance::set_chatcontent(const ::std::string& value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void C2SChatAlliance::set_chatcontent(const char* value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void C2SChatAlliance::set_chatcontent(const char* value, size_t size) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2SChatAlliance::mutable_chatcontent() {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  return chatcontent_;
}
inline ::std::string* C2SChatAlliance::release_chatcontent() {
  clear_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatcontent_;
    chatcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool useIM = 2;
inline bool C2SChatAlliance::has_useim() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2SChatAlliance::set_has_useim() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2SChatAlliance::clear_has_useim() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2SChatAlliance::clear_useim() {
  useim_ = false;
  clear_has_useim();
}
inline bool C2SChatAlliance::useim() const {
  return useim_;
}
inline void C2SChatAlliance::set_useim(bool value) {
  set_has_useim();
  useim_ = value;
}

// optional string voiceTime = 3;
inline bool C2SChatAlliance::has_voicetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2SChatAlliance::set_has_voicetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2SChatAlliance::clear_has_voicetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2SChatAlliance::clear_voicetime() {
  if (voicetime_ != &::google::protobuf::internal::kEmptyString) {
    voicetime_->clear();
  }
  clear_has_voicetime();
}
inline const ::std::string& C2SChatAlliance::voicetime() const {
  return *voicetime_;
}
inline void C2SChatAlliance::set_voicetime(const ::std::string& value) {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  voicetime_->assign(value);
}
inline void C2SChatAlliance::set_voicetime(const char* value) {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  voicetime_->assign(value);
}
inline void C2SChatAlliance::set_voicetime(const char* value, size_t size) {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  voicetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2SChatAlliance::mutable_voicetime() {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  return voicetime_;
}
inline ::std::string* C2SChatAlliance::release_voicetime() {
  clear_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = voicetime_;
    voicetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2SChatWorld

// required string ChatContent = 1;
inline bool C2SChatWorld::has_chatcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2SChatWorld::set_has_chatcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2SChatWorld::clear_has_chatcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2SChatWorld::clear_chatcontent() {
  if (chatcontent_ != &::google::protobuf::internal::kEmptyString) {
    chatcontent_->clear();
  }
  clear_has_chatcontent();
}
inline const ::std::string& C2SChatWorld::chatcontent() const {
  return *chatcontent_;
}
inline void C2SChatWorld::set_chatcontent(const ::std::string& value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void C2SChatWorld::set_chatcontent(const char* value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void C2SChatWorld::set_chatcontent(const char* value, size_t size) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2SChatWorld::mutable_chatcontent() {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  return chatcontent_;
}
inline ::std::string* C2SChatWorld::release_chatcontent() {
  clear_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatcontent_;
    chatcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool useIM = 2;
inline bool C2SChatWorld::has_useim() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2SChatWorld::set_has_useim() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2SChatWorld::clear_has_useim() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2SChatWorld::clear_useim() {
  useim_ = false;
  clear_has_useim();
}
inline bool C2SChatWorld::useim() const {
  return useim_;
}
inline void C2SChatWorld::set_useim(bool value) {
  set_has_useim();
  useim_ = value;
}

// optional string voiceTime = 3;
inline bool C2SChatWorld::has_voicetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2SChatWorld::set_has_voicetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2SChatWorld::clear_has_voicetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2SChatWorld::clear_voicetime() {
  if (voicetime_ != &::google::protobuf::internal::kEmptyString) {
    voicetime_->clear();
  }
  clear_has_voicetime();
}
inline const ::std::string& C2SChatWorld::voicetime() const {
  return *voicetime_;
}
inline void C2SChatWorld::set_voicetime(const ::std::string& value) {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  voicetime_->assign(value);
}
inline void C2SChatWorld::set_voicetime(const char* value) {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  voicetime_->assign(value);
}
inline void C2SChatWorld::set_voicetime(const char* value, size_t size) {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  voicetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2SChatWorld::mutable_voicetime() {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  return voicetime_;
}
inline ::std::string* C2SChatWorld::release_voicetime() {
  clear_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = voicetime_;
    voicetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2CChatP2P

// required string FromPlayerId = 1;
inline bool S2CChatP2P::has_fromplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2CChatP2P::set_has_fromplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2CChatP2P::clear_has_fromplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2CChatP2P::clear_fromplayerid() {
  if (fromplayerid_ != &::google::protobuf::internal::kEmptyString) {
    fromplayerid_->clear();
  }
  clear_has_fromplayerid();
}
inline const ::std::string& S2CChatP2P::fromplayerid() const {
  return *fromplayerid_;
}
inline void S2CChatP2P::set_fromplayerid(const ::std::string& value) {
  set_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    fromplayerid_ = new ::std::string;
  }
  fromplayerid_->assign(value);
}
inline void S2CChatP2P::set_fromplayerid(const char* value) {
  set_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    fromplayerid_ = new ::std::string;
  }
  fromplayerid_->assign(value);
}
inline void S2CChatP2P::set_fromplayerid(const char* value, size_t size) {
  set_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    fromplayerid_ = new ::std::string;
  }
  fromplayerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CChatP2P::mutable_fromplayerid() {
  set_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    fromplayerid_ = new ::std::string;
  }
  return fromplayerid_;
}
inline ::std::string* S2CChatP2P::release_fromplayerid() {
  clear_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromplayerid_;
    fromplayerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string FromPlayerName = 2;
inline bool S2CChatP2P::has_fromplayername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2CChatP2P::set_has_fromplayername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2CChatP2P::clear_has_fromplayername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2CChatP2P::clear_fromplayername() {
  if (fromplayername_ != &::google::protobuf::internal::kEmptyString) {
    fromplayername_->clear();
  }
  clear_has_fromplayername();
}
inline const ::std::string& S2CChatP2P::fromplayername() const {
  return *fromplayername_;
}
inline void S2CChatP2P::set_fromplayername(const ::std::string& value) {
  set_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    fromplayername_ = new ::std::string;
  }
  fromplayername_->assign(value);
}
inline void S2CChatP2P::set_fromplayername(const char* value) {
  set_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    fromplayername_ = new ::std::string;
  }
  fromplayername_->assign(value);
}
inline void S2CChatP2P::set_fromplayername(const char* value, size_t size) {
  set_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    fromplayername_ = new ::std::string;
  }
  fromplayername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CChatP2P::mutable_fromplayername() {
  set_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    fromplayername_ = new ::std::string;
  }
  return fromplayername_;
}
inline ::std::string* S2CChatP2P::release_fromplayername() {
  clear_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromplayername_;
    fromplayername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 FromPlayerLevel = 3;
inline bool S2CChatP2P::has_fromplayerlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2CChatP2P::set_has_fromplayerlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2CChatP2P::clear_has_fromplayerlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2CChatP2P::clear_fromplayerlevel() {
  fromplayerlevel_ = 0;
  clear_has_fromplayerlevel();
}
inline ::google::protobuf::int32 S2CChatP2P::fromplayerlevel() const {
  return fromplayerlevel_;
}
inline void S2CChatP2P::set_fromplayerlevel(::google::protobuf::int32 value) {
  set_has_fromplayerlevel();
  fromplayerlevel_ = value;
}

// required string ChatContent = 4;
inline bool S2CChatP2P::has_chatcontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void S2CChatP2P::set_has_chatcontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void S2CChatP2P::clear_has_chatcontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void S2CChatP2P::clear_chatcontent() {
  if (chatcontent_ != &::google::protobuf::internal::kEmptyString) {
    chatcontent_->clear();
  }
  clear_has_chatcontent();
}
inline const ::std::string& S2CChatP2P::chatcontent() const {
  return *chatcontent_;
}
inline void S2CChatP2P::set_chatcontent(const ::std::string& value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void S2CChatP2P::set_chatcontent(const char* value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void S2CChatP2P::set_chatcontent(const char* value, size_t size) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CChatP2P::mutable_chatcontent() {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  return chatcontent_;
}
inline ::std::string* S2CChatP2P::release_chatcontent() {
  clear_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatcontent_;
    chatcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2CChatWorld

// required string FromPlayerId = 1;
inline bool S2CChatWorld::has_fromplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2CChatWorld::set_has_fromplayerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2CChatWorld::clear_has_fromplayerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2CChatWorld::clear_fromplayerid() {
  if (fromplayerid_ != &::google::protobuf::internal::kEmptyString) {
    fromplayerid_->clear();
  }
  clear_has_fromplayerid();
}
inline const ::std::string& S2CChatWorld::fromplayerid() const {
  return *fromplayerid_;
}
inline void S2CChatWorld::set_fromplayerid(const ::std::string& value) {
  set_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    fromplayerid_ = new ::std::string;
  }
  fromplayerid_->assign(value);
}
inline void S2CChatWorld::set_fromplayerid(const char* value) {
  set_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    fromplayerid_ = new ::std::string;
  }
  fromplayerid_->assign(value);
}
inline void S2CChatWorld::set_fromplayerid(const char* value, size_t size) {
  set_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    fromplayerid_ = new ::std::string;
  }
  fromplayerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CChatWorld::mutable_fromplayerid() {
  set_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    fromplayerid_ = new ::std::string;
  }
  return fromplayerid_;
}
inline ::std::string* S2CChatWorld::release_fromplayerid() {
  clear_has_fromplayerid();
  if (fromplayerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromplayerid_;
    fromplayerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string FromPlayerName = 2;
inline bool S2CChatWorld::has_fromplayername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2CChatWorld::set_has_fromplayername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2CChatWorld::clear_has_fromplayername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2CChatWorld::clear_fromplayername() {
  if (fromplayername_ != &::google::protobuf::internal::kEmptyString) {
    fromplayername_->clear();
  }
  clear_has_fromplayername();
}
inline const ::std::string& S2CChatWorld::fromplayername() const {
  return *fromplayername_;
}
inline void S2CChatWorld::set_fromplayername(const ::std::string& value) {
  set_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    fromplayername_ = new ::std::string;
  }
  fromplayername_->assign(value);
}
inline void S2CChatWorld::set_fromplayername(const char* value) {
  set_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    fromplayername_ = new ::std::string;
  }
  fromplayername_->assign(value);
}
inline void S2CChatWorld::set_fromplayername(const char* value, size_t size) {
  set_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    fromplayername_ = new ::std::string;
  }
  fromplayername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CChatWorld::mutable_fromplayername() {
  set_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    fromplayername_ = new ::std::string;
  }
  return fromplayername_;
}
inline ::std::string* S2CChatWorld::release_fromplayername() {
  clear_has_fromplayername();
  if (fromplayername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromplayername_;
    fromplayername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 FromPlayerLevel = 3;
inline bool S2CChatWorld::has_fromplayerlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2CChatWorld::set_has_fromplayerlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2CChatWorld::clear_has_fromplayerlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2CChatWorld::clear_fromplayerlevel() {
  fromplayerlevel_ = 0;
  clear_has_fromplayerlevel();
}
inline ::google::protobuf::int32 S2CChatWorld::fromplayerlevel() const {
  return fromplayerlevel_;
}
inline void S2CChatWorld::set_fromplayerlevel(::google::protobuf::int32 value) {
  set_has_fromplayerlevel();
  fromplayerlevel_ = value;
}

// required int64 ChatTime = 6;
inline bool S2CChatWorld::has_chattime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void S2CChatWorld::set_has_chattime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void S2CChatWorld::clear_has_chattime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void S2CChatWorld::clear_chattime() {
  chattime_ = GOOGLE_LONGLONG(0);
  clear_has_chattime();
}
inline ::google::protobuf::int64 S2CChatWorld::chattime() const {
  return chattime_;
}
inline void S2CChatWorld::set_chattime(::google::protobuf::int64 value) {
  set_has_chattime();
  chattime_ = value;
}

// required string ChatContent = 7;
inline bool S2CChatWorld::has_chatcontent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void S2CChatWorld::set_has_chatcontent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void S2CChatWorld::clear_has_chatcontent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void S2CChatWorld::clear_chatcontent() {
  if (chatcontent_ != &::google::protobuf::internal::kEmptyString) {
    chatcontent_->clear();
  }
  clear_has_chatcontent();
}
inline const ::std::string& S2CChatWorld::chatcontent() const {
  return *chatcontent_;
}
inline void S2CChatWorld::set_chatcontent(const ::std::string& value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void S2CChatWorld::set_chatcontent(const char* value) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(value);
}
inline void S2CChatWorld::set_chatcontent(const char* value, size_t size) {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  chatcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CChatWorld::mutable_chatcontent() {
  set_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    chatcontent_ = new ::std::string;
  }
  return chatcontent_;
}
inline ::std::string* S2CChatWorld::release_chatcontent() {
  clear_has_chatcontent();
  if (chatcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatcontent_;
    chatcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool useIM = 10;
inline bool S2CChatWorld::has_useim() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void S2CChatWorld::set_has_useim() {
  _has_bits_[0] |= 0x00000020u;
}
inline void S2CChatWorld::clear_has_useim() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void S2CChatWorld::clear_useim() {
  useim_ = false;
  clear_has_useim();
}
inline bool S2CChatWorld::useim() const {
  return useim_;
}
inline void S2CChatWorld::set_useim(bool value) {
  set_has_useim();
  useim_ = value;
}

// optional string voiceTime = 11;
inline bool S2CChatWorld::has_voicetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void S2CChatWorld::set_has_voicetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void S2CChatWorld::clear_has_voicetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void S2CChatWorld::clear_voicetime() {
  if (voicetime_ != &::google::protobuf::internal::kEmptyString) {
    voicetime_->clear();
  }
  clear_has_voicetime();
}
inline const ::std::string& S2CChatWorld::voicetime() const {
  return *voicetime_;
}
inline void S2CChatWorld::set_voicetime(const ::std::string& value) {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  voicetime_->assign(value);
}
inline void S2CChatWorld::set_voicetime(const char* value) {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  voicetime_->assign(value);
}
inline void S2CChatWorld::set_voicetime(const char* value, size_t size) {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  voicetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CChatWorld::mutable_voicetime() {
  set_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    voicetime_ = new ::std::string;
  }
  return voicetime_;
}
inline ::std::string* S2CChatWorld::release_voicetime() {
  clear_has_voicetime();
  if (voicetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = voicetime_;
    voicetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 messageId = 12;
inline bool S2CChatWorld::has_messageid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void S2CChatWorld::set_has_messageid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void S2CChatWorld::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void S2CChatWorld::clear_messageid() {
  messageid_ = 0;
  clear_has_messageid();
}
inline ::google::protobuf::int32 S2CChatWorld::messageid() const {
  return messageid_;
}
inline void S2CChatWorld::set_messageid(::google::protobuf::int32 value) {
  set_has_messageid();
  messageid_ = value;
}

// -------------------------------------------------------------------

// Card

// required int32 value = 1;
inline bool Card::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Card::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Card::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Card::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Card::value() const {
  return value_;
}
inline void Card::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// required bool bBig = 2;
inline bool Card::has_bbig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Card::set_has_bbig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Card::clear_has_bbig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Card::clear_bbig() {
  bbig_ = false;
  clear_has_bbig();
}
inline bool Card::bbig() const {
  return bbig_;
}
inline void Card::set_bbig(bool value) {
  set_has_bbig();
  bbig_ = value;
}

// required bool bLock = 3;
inline bool Card::has_block() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Card::set_has_block() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Card::clear_has_block() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Card::clear_block() {
  block_ = false;
  clear_has_block();
}
inline bool Card::block() const {
  return block_;
}
inline void Card::set_block(bool value) {
  set_has_block();
  block_ = value;
}

// optional bool bChi = 4;
inline bool Card::has_bchi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Card::set_has_bchi() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Card::clear_has_bchi() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Card::clear_bchi() {
  bchi_ = false;
  clear_has_bchi();
}
inline bool Card::bchi() const {
  return bchi_;
}
inline void Card::set_bchi(bool value) {
  set_has_bchi();
  bchi_ = value;
}

// optional bool bHu = 5;
inline bool Card::has_bhu() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Card::set_has_bhu() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Card::clear_has_bhu() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Card::clear_bhu() {
  bhu_ = false;
  clear_has_bhu();
}
inline bool Card::bhu() const {
  return bhu_;
}
inline void Card::set_bhu(bool value) {
  set_has_bhu();
  bhu_ = value;
}

// -------------------------------------------------------------------

// Pattern

// optional int32 ptype = 1;
inline bool Pattern::has_ptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pattern::set_has_ptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pattern::clear_has_ptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pattern::clear_ptype() {
  ptype_ = 0;
  clear_has_ptype();
}
inline ::google::protobuf::int32 Pattern::ptype() const {
  return ptype_;
}
inline void Pattern::set_ptype(::google::protobuf::int32 value) {
  set_has_ptype();
  ptype_ = value;
}

// repeated .rpc.Card cards = 2;
inline int Pattern::cards_size() const {
  return cards_.size();
}
inline void Pattern::clear_cards() {
  cards_.Clear();
}
inline const ::rpc::Card& Pattern::cards(int index) const {
  return cards_.Get(index);
}
inline ::rpc::Card* Pattern::mutable_cards(int index) {
  return cards_.Mutable(index);
}
inline ::rpc::Card* Pattern::add_cards() {
  return cards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
Pattern::cards() const {
  return cards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
Pattern::mutable_cards() {
  return &cards_;
}

// optional int32 hu = 3;
inline bool Pattern::has_hu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pattern::set_has_hu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pattern::clear_has_hu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pattern::clear_hu() {
  hu_ = 0;
  clear_has_hu();
}
inline ::google::protobuf::int32 Pattern::hu() const {
  return hu_;
}
inline void Pattern::set_hu(::google::protobuf::int32 value) {
  set_has_hu();
  hu_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// required string playeID = 1;
inline bool UserInfo::has_playeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_playeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_playeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_playeid() {
  if (playeid_ != &::google::protobuf::internal::kEmptyString) {
    playeid_->clear();
  }
  clear_has_playeid();
}
inline const ::std::string& UserInfo::playeid() const {
  return *playeid_;
}
inline void UserInfo::set_playeid(const ::std::string& value) {
  set_has_playeid();
  if (playeid_ == &::google::protobuf::internal::kEmptyString) {
    playeid_ = new ::std::string;
  }
  playeid_->assign(value);
}
inline void UserInfo::set_playeid(const char* value) {
  set_has_playeid();
  if (playeid_ == &::google::protobuf::internal::kEmptyString) {
    playeid_ = new ::std::string;
  }
  playeid_->assign(value);
}
inline void UserInfo::set_playeid(const char* value, size_t size) {
  set_has_playeid();
  if (playeid_ == &::google::protobuf::internal::kEmptyString) {
    playeid_ = new ::std::string;
  }
  playeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_playeid() {
  set_has_playeid();
  if (playeid_ == &::google::protobuf::internal::kEmptyString) {
    playeid_ = new ::std::string;
  }
  return playeid_;
}
inline ::std::string* UserInfo::release_playeid() {
  clear_has_playeid();
  if (playeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playeid_;
    playeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool UserInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserInfo::name() const {
  return *name_;
}
inline void UserInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 coins = 3;
inline bool UserInfo::has_coins() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_coins() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_coins() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline ::google::protobuf::int32 UserInfo::coins() const {
  return coins_;
}
inline void UserInfo::set_coins(::google::protobuf::int32 value) {
  set_has_coins();
  coins_ = value;
}

// optional bool bVip = 4;
inline bool UserInfo::has_bvip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_bvip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_bvip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_bvip() {
  bvip_ = false;
  clear_has_bvip();
}
inline bool UserInfo::bvip() const {
  return bvip_;
}
inline void UserInfo::set_bvip(bool value) {
  set_has_bvip();
  bvip_ = value;
}

// required string head = 5;
inline bool UserInfo::has_head() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_head() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_head() {
  if (head_ != &::google::protobuf::internal::kEmptyString) {
    head_->clear();
  }
  clear_has_head();
}
inline const ::std::string& UserInfo::head() const {
  return *head_;
}
inline void UserInfo::set_head(const ::std::string& value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void UserInfo::set_head(const char* value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void UserInfo::set_head(const char* value, size_t size) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_head() {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  return head_;
}
inline ::std::string* UserInfo::release_head() {
  clear_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_;
    head_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 sex = 6;
inline bool UserInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 UserInfo::sex() const {
  return sex_;
}
inline void UserInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// EnterRoomREQ

// required string gameType = 1;
inline bool EnterRoomREQ::has_gametype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomREQ::set_has_gametype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomREQ::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomREQ::clear_gametype() {
  if (gametype_ != &::google::protobuf::internal::kEmptyString) {
    gametype_->clear();
  }
  clear_has_gametype();
}
inline const ::std::string& EnterRoomREQ::gametype() const {
  return *gametype_;
}
inline void EnterRoomREQ::set_gametype(const ::std::string& value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void EnterRoomREQ::set_gametype(const char* value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void EnterRoomREQ::set_gametype(const char* value, size_t size) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomREQ::mutable_gametype() {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  return gametype_;
}
inline ::std::string* EnterRoomREQ::release_gametype() {
  clear_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gametype_;
    gametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 roomType = 2;
inline bool EnterRoomREQ::has_roomtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomREQ::set_has_roomtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomREQ::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomREQ::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 EnterRoomREQ::roomtype() const {
  return roomtype_;
}
inline void EnterRoomREQ::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// -------------------------------------------------------------------

// QuickEnterRoomREQ

// -------------------------------------------------------------------

// EnterRoomACK

// optional .rpc.PlayerBaseInfo playerInfo = 1;
inline bool EnterRoomACK::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomACK::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomACK::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomACK::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::rpc::PlayerBaseInfo::Clear();
  clear_has_playerinfo();
}
inline const ::rpc::PlayerBaseInfo& EnterRoomACK::playerinfo() const {
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance_->playerinfo_;
}
inline ::rpc::PlayerBaseInfo* EnterRoomACK::mutable_playerinfo() {
  set_has_playerinfo();
  if (playerinfo_ == NULL) playerinfo_ = new ::rpc::PlayerBaseInfo;
  return playerinfo_;
}
inline ::rpc::PlayerBaseInfo* EnterRoomACK::release_playerinfo() {
  clear_has_playerinfo();
  ::rpc::PlayerBaseInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}

// optional int32 shangjiaType = 2;
inline bool EnterRoomACK::has_shangjiatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomACK::set_has_shangjiatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomACK::clear_has_shangjiatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomACK::clear_shangjiatype() {
  shangjiatype_ = 0;
  clear_has_shangjiatype();
}
inline ::google::protobuf::int32 EnterRoomACK::shangjiatype() const {
  return shangjiatype_;
}
inline void EnterRoomACK::set_shangjiatype(::google::protobuf::int32 value) {
  set_has_shangjiatype();
  shangjiatype_ = value;
}

// optional bool bReady = 3;
inline bool EnterRoomACK::has_bready() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoomACK::set_has_bready() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoomACK::clear_has_bready() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoomACK::clear_bready() {
  bready_ = false;
  clear_has_bready();
}
inline bool EnterRoomACK::bready() const {
  return bready_;
}
inline void EnterRoomACK::set_bready(bool value) {
  set_has_bready();
  bready_ = value;
}

// optional int32 code = 4;
inline bool EnterRoomACK::has_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterRoomACK::set_has_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterRoomACK::clear_has_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterRoomACK::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 EnterRoomACK::code() const {
  return code_;
}
inline void EnterRoomACK::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional int32 roomId = 5;
inline bool EnterRoomACK::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnterRoomACK::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnterRoomACK::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnterRoomACK::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 EnterRoomACK::roomid() const {
  return roomid_;
}
inline void EnterRoomACK::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional bool isNormalReqEnterRoom = 6;
inline bool EnterRoomACK::has_isnormalreqenterroom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EnterRoomACK::set_has_isnormalreqenterroom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EnterRoomACK::clear_has_isnormalreqenterroom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EnterRoomACK::clear_isnormalreqenterroom() {
  isnormalreqenterroom_ = false;
  clear_has_isnormalreqenterroom();
}
inline bool EnterRoomACK::isnormalreqenterroom() const {
  return isnormalreqenterroom_;
}
inline void EnterRoomACK::set_isnormalreqenterroom(bool value) {
  set_has_isnormalreqenterroom();
  isnormalreqenterroom_ = value;
}

// -------------------------------------------------------------------

// LeaveRoomREQ

// required string playerID = 1;
inline bool LeaveRoomREQ::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveRoomREQ::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveRoomREQ::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveRoomREQ::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& LeaveRoomREQ::playerid() const {
  return *playerid_;
}
inline void LeaveRoomREQ::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void LeaveRoomREQ::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void LeaveRoomREQ::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaveRoomREQ::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* LeaveRoomREQ::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isChangeDesk = 2;
inline bool LeaveRoomREQ::has_ischangedesk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveRoomREQ::set_has_ischangedesk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveRoomREQ::clear_has_ischangedesk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveRoomREQ::clear_ischangedesk() {
  ischangedesk_ = false;
  clear_has_ischangedesk();
}
inline bool LeaveRoomREQ::ischangedesk() const {
  return ischangedesk_;
}
inline void LeaveRoomREQ::set_ischangedesk(bool value) {
  set_has_ischangedesk();
  ischangedesk_ = value;
}

// -------------------------------------------------------------------

// LeaveRoomACK

// required string playerID = 1;
inline bool LeaveRoomACK::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveRoomACK::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveRoomACK::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveRoomACK::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& LeaveRoomACK::playerid() const {
  return *playerid_;
}
inline void LeaveRoomACK::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void LeaveRoomACK::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void LeaveRoomACK::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaveRoomACK::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* LeaveRoomACK::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isChangeDesk = 2;
inline bool LeaveRoomACK::has_ischangedesk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveRoomACK::set_has_ischangedesk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveRoomACK::clear_has_ischangedesk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveRoomACK::clear_ischangedesk() {
  ischangedesk_ = false;
  clear_has_ischangedesk();
}
inline bool LeaveRoomACK::ischangedesk() const {
  return ischangedesk_;
}
inline void LeaveRoomACK::set_ischangedesk(bool value) {
  set_has_ischangedesk();
  ischangedesk_ = value;
}

// -------------------------------------------------------------------

// CountDown

// required string playerID = 1;
inline bool CountDown::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CountDown::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CountDown::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CountDown::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& CountDown::playerid() const {
  return *playerid_;
}
inline void CountDown::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void CountDown::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void CountDown::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CountDown::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* CountDown::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 currentCountDown = 2;
inline bool CountDown::has_currentcountdown() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CountDown::set_has_currentcountdown() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CountDown::clear_has_currentcountdown() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CountDown::clear_currentcountdown() {
  currentcountdown_ = 0;
  clear_has_currentcountdown();
}
inline ::google::protobuf::int32 CountDown::currentcountdown() const {
  return currentcountdown_;
}
inline void CountDown::set_currentcountdown(::google::protobuf::int32 value) {
  set_has_currentcountdown();
  currentcountdown_ = value;
}

// -------------------------------------------------------------------

// FightPlayerInfo

// required string playerID = 1;
inline bool FightPlayerInfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightPlayerInfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightPlayerInfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightPlayerInfo::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& FightPlayerInfo::playerid() const {
  return *playerid_;
}
inline void FightPlayerInfo::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void FightPlayerInfo::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void FightPlayerInfo::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightPlayerInfo::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* FightPlayerInfo::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .rpc.Card handCards = 2;
inline int FightPlayerInfo::handcards_size() const {
  return handcards_.size();
}
inline void FightPlayerInfo::clear_handcards() {
  handcards_.Clear();
}
inline const ::rpc::Card& FightPlayerInfo::handcards(int index) const {
  return handcards_.Get(index);
}
inline ::rpc::Card* FightPlayerInfo::mutable_handcards(int index) {
  return handcards_.Mutable(index);
}
inline ::rpc::Card* FightPlayerInfo::add_handcards() {
  return handcards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
FightPlayerInfo::handcards() const {
  return handcards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
FightPlayerInfo::mutable_handcards() {
  return &handcards_;
}

// repeated .rpc.Pattern longPattern = 3;
inline int FightPlayerInfo::longpattern_size() const {
  return longpattern_.size();
}
inline void FightPlayerInfo::clear_longpattern() {
  longpattern_.Clear();
}
inline const ::rpc::Pattern& FightPlayerInfo::longpattern(int index) const {
  return longpattern_.Get(index);
}
inline ::rpc::Pattern* FightPlayerInfo::mutable_longpattern(int index) {
  return longpattern_.Mutable(index);
}
inline ::rpc::Pattern* FightPlayerInfo::add_longpattern() {
  return longpattern_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
FightPlayerInfo::longpattern() const {
  return longpattern_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
FightPlayerInfo::mutable_longpattern() {
  return &longpattern_;
}

// repeated .rpc.Pattern kanPattern = 4;
inline int FightPlayerInfo::kanpattern_size() const {
  return kanpattern_.size();
}
inline void FightPlayerInfo::clear_kanpattern() {
  kanpattern_.Clear();
}
inline const ::rpc::Pattern& FightPlayerInfo::kanpattern(int index) const {
  return kanpattern_.Get(index);
}
inline ::rpc::Pattern* FightPlayerInfo::mutable_kanpattern(int index) {
  return kanpattern_.Mutable(index);
}
inline ::rpc::Pattern* FightPlayerInfo::add_kanpattern() {
  return kanpattern_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
FightPlayerInfo::kanpattern() const {
  return kanpattern_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
FightPlayerInfo::mutable_kanpattern() {
  return &kanpattern_;
}

// repeated .rpc.Card erLongTouYi = 5;
inline int FightPlayerInfo::erlongtouyi_size() const {
  return erlongtouyi_.size();
}
inline void FightPlayerInfo::clear_erlongtouyi() {
  erlongtouyi_.Clear();
}
inline const ::rpc::Card& FightPlayerInfo::erlongtouyi(int index) const {
  return erlongtouyi_.Get(index);
}
inline ::rpc::Card* FightPlayerInfo::mutable_erlongtouyi(int index) {
  return erlongtouyi_.Mutable(index);
}
inline ::rpc::Card* FightPlayerInfo::add_erlongtouyi() {
  return erlongtouyi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
FightPlayerInfo::erlongtouyi() const {
  return erlongtouyi_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
FightPlayerInfo::mutable_erlongtouyi() {
  return &erlongtouyi_;
}

// repeated .rpc.Card chuGuoCards = 6;
inline int FightPlayerInfo::chuguocards_size() const {
  return chuguocards_.size();
}
inline void FightPlayerInfo::clear_chuguocards() {
  chuguocards_.Clear();
}
inline const ::rpc::Card& FightPlayerInfo::chuguocards(int index) const {
  return chuguocards_.Get(index);
}
inline ::rpc::Card* FightPlayerInfo::mutable_chuguocards(int index) {
  return chuguocards_.Mutable(index);
}
inline ::rpc::Card* FightPlayerInfo::add_chuguocards() {
  return chuguocards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
FightPlayerInfo::chuguocards() const {
  return chuguocards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
FightPlayerInfo::mutable_chuguocards() {
  return &chuguocards_;
}

// repeated .rpc.Pattern chiPengZhaoLongCards = 7;
inline int FightPlayerInfo::chipengzhaolongcards_size() const {
  return chipengzhaolongcards_.size();
}
inline void FightPlayerInfo::clear_chipengzhaolongcards() {
  chipengzhaolongcards_.Clear();
}
inline const ::rpc::Pattern& FightPlayerInfo::chipengzhaolongcards(int index) const {
  return chipengzhaolongcards_.Get(index);
}
inline ::rpc::Pattern* FightPlayerInfo::mutable_chipengzhaolongcards(int index) {
  return chipengzhaolongcards_.Mutable(index);
}
inline ::rpc::Pattern* FightPlayerInfo::add_chipengzhaolongcards() {
  return chipengzhaolongcards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
FightPlayerInfo::chipengzhaolongcards() const {
  return chipengzhaolongcards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
FightPlayerInfo::mutable_chipengzhaolongcards() {
  return &chipengzhaolongcards_;
}

// optional int32 currentHu = 8;
inline bool FightPlayerInfo::has_currenthu() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FightPlayerInfo::set_has_currenthu() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FightPlayerInfo::clear_has_currenthu() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FightPlayerInfo::clear_currenthu() {
  currenthu_ = 0;
  clear_has_currenthu();
}
inline ::google::protobuf::int32 FightPlayerInfo::currenthu() const {
  return currenthu_;
}
inline void FightPlayerInfo::set_currenthu(::google::protobuf::int32 value) {
  set_has_currenthu();
  currenthu_ = value;
}

// optional bool bZhuang = 9;
inline bool FightPlayerInfo::has_bzhuang() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FightPlayerInfo::set_has_bzhuang() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FightPlayerInfo::clear_has_bzhuang() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FightPlayerInfo::clear_bzhuang() {
  bzhuang_ = false;
  clear_has_bzhuang();
}
inline bool FightPlayerInfo::bzhuang() const {
  return bzhuang_;
}
inline void FightPlayerInfo::set_bzhuang(bool value) {
  set_has_bzhuang();
  bzhuang_ = value;
}

// optional bool bBao = 10;
inline bool FightPlayerInfo::has_bbao() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FightPlayerInfo::set_has_bbao() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FightPlayerInfo::clear_has_bbao() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FightPlayerInfo::clear_bbao() {
  bbao_ = false;
  clear_has_bbao();
}
inline bool FightPlayerInfo::bbao() const {
  return bbao_;
}
inline void FightPlayerInfo::set_bbao(bool value) {
  set_has_bbao();
  bbao_ = value;
}

// optional bool bTuoGuan = 11;
inline bool FightPlayerInfo::has_btuoguan() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FightPlayerInfo::set_has_btuoguan() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FightPlayerInfo::clear_has_btuoguan() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FightPlayerInfo::clear_btuoguan() {
  btuoguan_ = false;
  clear_has_btuoguan();
}
inline bool FightPlayerInfo::btuoguan() const {
  return btuoguan_;
}
inline void FightPlayerInfo::set_btuoguan(bool value) {
  set_has_btuoguan();
  btuoguan_ = value;
}

// -------------------------------------------------------------------

// FightCurrentStateInfo

// optional .rpc.Card currentDeskCard = 1;
inline bool FightCurrentStateInfo::has_currentdeskcard() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightCurrentStateInfo::set_has_currentdeskcard() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightCurrentStateInfo::clear_has_currentdeskcard() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightCurrentStateInfo::clear_currentdeskcard() {
  if (currentdeskcard_ != NULL) currentdeskcard_->::rpc::Card::Clear();
  clear_has_currentdeskcard();
}
inline const ::rpc::Card& FightCurrentStateInfo::currentdeskcard() const {
  return currentdeskcard_ != NULL ? *currentdeskcard_ : *default_instance_->currentdeskcard_;
}
inline ::rpc::Card* FightCurrentStateInfo::mutable_currentdeskcard() {
  set_has_currentdeskcard();
  if (currentdeskcard_ == NULL) currentdeskcard_ = new ::rpc::Card;
  return currentdeskcard_;
}
inline ::rpc::Card* FightCurrentStateInfo::release_currentdeskcard() {
  clear_has_currentdeskcard();
  ::rpc::Card* temp = currentdeskcard_;
  currentdeskcard_ = NULL;
  return temp;
}

// repeated .rpc.CountDown currentCountDownInfo = 2;
inline int FightCurrentStateInfo::currentcountdowninfo_size() const {
  return currentcountdowninfo_.size();
}
inline void FightCurrentStateInfo::clear_currentcountdowninfo() {
  currentcountdowninfo_.Clear();
}
inline const ::rpc::CountDown& FightCurrentStateInfo::currentcountdowninfo(int index) const {
  return currentcountdowninfo_.Get(index);
}
inline ::rpc::CountDown* FightCurrentStateInfo::mutable_currentcountdowninfo(int index) {
  return currentcountdowninfo_.Mutable(index);
}
inline ::rpc::CountDown* FightCurrentStateInfo::add_currentcountdowninfo() {
  return currentcountdowninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::CountDown >&
FightCurrentStateInfo::currentcountdowninfo() const {
  return currentcountdowninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::CountDown >*
FightCurrentStateInfo::mutable_currentcountdowninfo() {
  return &currentcountdowninfo_;
}

// optional string currentDeskCardPlayerID = 4;
inline bool FightCurrentStateInfo::has_currentdeskcardplayerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightCurrentStateInfo::set_has_currentdeskcardplayerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightCurrentStateInfo::clear_has_currentdeskcardplayerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightCurrentStateInfo::clear_currentdeskcardplayerid() {
  if (currentdeskcardplayerid_ != &::google::protobuf::internal::kEmptyString) {
    currentdeskcardplayerid_->clear();
  }
  clear_has_currentdeskcardplayerid();
}
inline const ::std::string& FightCurrentStateInfo::currentdeskcardplayerid() const {
  return *currentdeskcardplayerid_;
}
inline void FightCurrentStateInfo::set_currentdeskcardplayerid(const ::std::string& value) {
  set_has_currentdeskcardplayerid();
  if (currentdeskcardplayerid_ == &::google::protobuf::internal::kEmptyString) {
    currentdeskcardplayerid_ = new ::std::string;
  }
  currentdeskcardplayerid_->assign(value);
}
inline void FightCurrentStateInfo::set_currentdeskcardplayerid(const char* value) {
  set_has_currentdeskcardplayerid();
  if (currentdeskcardplayerid_ == &::google::protobuf::internal::kEmptyString) {
    currentdeskcardplayerid_ = new ::std::string;
  }
  currentdeskcardplayerid_->assign(value);
}
inline void FightCurrentStateInfo::set_currentdeskcardplayerid(const char* value, size_t size) {
  set_has_currentdeskcardplayerid();
  if (currentdeskcardplayerid_ == &::google::protobuf::internal::kEmptyString) {
    currentdeskcardplayerid_ = new ::std::string;
  }
  currentdeskcardplayerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightCurrentStateInfo::mutable_currentdeskcardplayerid() {
  set_has_currentdeskcardplayerid();
  if (currentdeskcardplayerid_ == &::google::protobuf::internal::kEmptyString) {
    currentdeskcardplayerid_ = new ::std::string;
  }
  return currentdeskcardplayerid_;
}
inline ::std::string* FightCurrentStateInfo::release_currentdeskcardplayerid() {
  clear_has_currentdeskcardplayerid();
  if (currentdeskcardplayerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentdeskcardplayerid_;
    currentdeskcardplayerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 currentDeskRemainCard = 5;
inline bool FightCurrentStateInfo::has_currentdeskremaincard() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightCurrentStateInfo::set_has_currentdeskremaincard() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightCurrentStateInfo::clear_has_currentdeskremaincard() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightCurrentStateInfo::clear_currentdeskremaincard() {
  currentdeskremaincard_ = 0;
  clear_has_currentdeskremaincard();
}
inline ::google::protobuf::int32 FightCurrentStateInfo::currentdeskremaincard() const {
  return currentdeskremaincard_;
}
inline void FightCurrentStateInfo::set_currentdeskremaincard(::google::protobuf::int32 value) {
  set_has_currentdeskremaincard();
  currentdeskremaincard_ = value;
}

// optional bool bCurrentDeskCardMo = 6;
inline bool FightCurrentStateInfo::has_bcurrentdeskcardmo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightCurrentStateInfo::set_has_bcurrentdeskcardmo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightCurrentStateInfo::clear_has_bcurrentdeskcardmo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightCurrentStateInfo::clear_bcurrentdeskcardmo() {
  bcurrentdeskcardmo_ = false;
  clear_has_bcurrentdeskcardmo();
}
inline bool FightCurrentStateInfo::bcurrentdeskcardmo() const {
  return bcurrentdeskcardmo_;
}
inline void FightCurrentStateInfo::set_bcurrentdeskcardmo(bool value) {
  set_has_bcurrentdeskcardmo();
  bcurrentdeskcardmo_ = value;
}

// -------------------------------------------------------------------

// GameStartACK

// repeated .rpc.FightPlayerInfo fightPlayersInfo = 1;
inline int GameStartACK::fightplayersinfo_size() const {
  return fightplayersinfo_.size();
}
inline void GameStartACK::clear_fightplayersinfo() {
  fightplayersinfo_.Clear();
}
inline const ::rpc::FightPlayerInfo& GameStartACK::fightplayersinfo(int index) const {
  return fightplayersinfo_.Get(index);
}
inline ::rpc::FightPlayerInfo* GameStartACK::mutable_fightplayersinfo(int index) {
  return fightplayersinfo_.Mutable(index);
}
inline ::rpc::FightPlayerInfo* GameStartACK::add_fightplayersinfo() {
  return fightplayersinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::FightPlayerInfo >&
GameStartACK::fightplayersinfo() const {
  return fightplayersinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::FightPlayerInfo >*
GameStartACK::mutable_fightplayersinfo() {
  return &fightplayersinfo_;
}

// optional .rpc.FightCurrentStateInfo currentFightState = 2;
inline bool GameStartACK::has_currentfightstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartACK::set_has_currentfightstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStartACK::clear_has_currentfightstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStartACK::clear_currentfightstate() {
  if (currentfightstate_ != NULL) currentfightstate_->::rpc::FightCurrentStateInfo::Clear();
  clear_has_currentfightstate();
}
inline const ::rpc::FightCurrentStateInfo& GameStartACK::currentfightstate() const {
  return currentfightstate_ != NULL ? *currentfightstate_ : *default_instance_->currentfightstate_;
}
inline ::rpc::FightCurrentStateInfo* GameStartACK::mutable_currentfightstate() {
  set_has_currentfightstate();
  if (currentfightstate_ == NULL) currentfightstate_ = new ::rpc::FightCurrentStateInfo;
  return currentfightstate_;
}
inline ::rpc::FightCurrentStateInfo* GameStartACK::release_currentfightstate() {
  clear_has_currentfightstate();
  ::rpc::FightCurrentStateInfo* temp = currentfightstate_;
  currentfightstate_ = NULL;
  return temp;
}

// optional int32 fightState = 5;
inline bool GameStartACK::has_fightstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameStartACK::set_has_fightstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameStartACK::clear_has_fightstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameStartACK::clear_fightstate() {
  fightstate_ = 0;
  clear_has_fightstate();
}
inline ::google::protobuf::int32 GameStartACK::fightstate() const {
  return fightstate_;
}
inline void GameStartACK::set_fightstate(::google::protobuf::int32 value) {
  set_has_fightstate();
  fightstate_ = value;
}

// -------------------------------------------------------------------

// ActionREQ

// required int32 action = 1;
inline bool ActionREQ::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionREQ::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionREQ::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionREQ::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 ActionREQ::action() const {
  return action_;
}
inline void ActionREQ::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// required string playerID = 2;
inline bool ActionREQ::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionREQ::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionREQ::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionREQ::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& ActionREQ::playerid() const {
  return *playerid_;
}
inline void ActionREQ::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ActionREQ::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ActionREQ::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionREQ::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* ActionREQ::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .rpc.Pattern chiCards = 3;
inline bool ActionREQ::has_chicards() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActionREQ::set_has_chicards() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActionREQ::clear_has_chicards() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActionREQ::clear_chicards() {
  if (chicards_ != NULL) chicards_->::rpc::Pattern::Clear();
  clear_has_chicards();
}
inline const ::rpc::Pattern& ActionREQ::chicards() const {
  return chicards_ != NULL ? *chicards_ : *default_instance_->chicards_;
}
inline ::rpc::Pattern* ActionREQ::mutable_chicards() {
  set_has_chicards();
  if (chicards_ == NULL) chicards_ = new ::rpc::Pattern;
  return chicards_;
}
inline ::rpc::Pattern* ActionREQ::release_chicards() {
  clear_has_chicards();
  ::rpc::Pattern* temp = chicards_;
  chicards_ = NULL;
  return temp;
}

// optional .rpc.Pattern biCards = 4;
inline bool ActionREQ::has_bicards() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActionREQ::set_has_bicards() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActionREQ::clear_has_bicards() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActionREQ::clear_bicards() {
  if (bicards_ != NULL) bicards_->::rpc::Pattern::Clear();
  clear_has_bicards();
}
inline const ::rpc::Pattern& ActionREQ::bicards() const {
  return bicards_ != NULL ? *bicards_ : *default_instance_->bicards_;
}
inline ::rpc::Pattern* ActionREQ::mutable_bicards() {
  set_has_bicards();
  if (bicards_ == NULL) bicards_ = new ::rpc::Pattern;
  return bicards_;
}
inline ::rpc::Pattern* ActionREQ::release_bicards() {
  clear_has_bicards();
  ::rpc::Pattern* temp = bicards_;
  bicards_ = NULL;
  return temp;
}

// optional .rpc.Card chuPai = 5;
inline bool ActionREQ::has_chupai() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActionREQ::set_has_chupai() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActionREQ::clear_has_chupai() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActionREQ::clear_chupai() {
  if (chupai_ != NULL) chupai_->::rpc::Card::Clear();
  clear_has_chupai();
}
inline const ::rpc::Card& ActionREQ::chupai() const {
  return chupai_ != NULL ? *chupai_ : *default_instance_->chupai_;
}
inline ::rpc::Card* ActionREQ::mutable_chupai() {
  set_has_chupai();
  if (chupai_ == NULL) chupai_ = new ::rpc::Card;
  return chupai_;
}
inline ::rpc::Card* ActionREQ::release_chupai() {
  clear_has_chupai();
  ::rpc::Card* temp = chupai_;
  chupai_ = NULL;
  return temp;
}

// optional .rpc.MJCard cardArgs = 10;
inline bool ActionREQ::has_cardargs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActionREQ::set_has_cardargs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActionREQ::clear_has_cardargs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActionREQ::clear_cardargs() {
  if (cardargs_ != NULL) cardargs_->::rpc::MJCard::Clear();
  clear_has_cardargs();
}
inline const ::rpc::MJCard& ActionREQ::cardargs() const {
  return cardargs_ != NULL ? *cardargs_ : *default_instance_->cardargs_;
}
inline ::rpc::MJCard* ActionREQ::mutable_cardargs() {
  set_has_cardargs();
  if (cardargs_ == NULL) cardargs_ = new ::rpc::MJCard;
  return cardargs_;
}
inline ::rpc::MJCard* ActionREQ::release_cardargs() {
  clear_has_cardargs();
  ::rpc::MJCard* temp = cardargs_;
  cardargs_ = NULL;
  return temp;
}

// required int32 sysType = 6;
inline bool ActionREQ::has_systype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActionREQ::set_has_systype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActionREQ::clear_has_systype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActionREQ::clear_systype() {
  systype_ = 0;
  clear_has_systype();
}
inline ::google::protobuf::int32 ActionREQ::systype() const {
  return systype_;
}
inline void ActionREQ::set_systype(::google::protobuf::int32 value) {
  set_has_systype();
  systype_ = value;
}

// -------------------------------------------------------------------

// ChiAtionArgs

// optional .rpc.Pattern canChiCards = 1;
inline bool ChiAtionArgs::has_canchicards() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChiAtionArgs::set_has_canchicards() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChiAtionArgs::clear_has_canchicards() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChiAtionArgs::clear_canchicards() {
  if (canchicards_ != NULL) canchicards_->::rpc::Pattern::Clear();
  clear_has_canchicards();
}
inline const ::rpc::Pattern& ChiAtionArgs::canchicards() const {
  return canchicards_ != NULL ? *canchicards_ : *default_instance_->canchicards_;
}
inline ::rpc::Pattern* ChiAtionArgs::mutable_canchicards() {
  set_has_canchicards();
  if (canchicards_ == NULL) canchicards_ = new ::rpc::Pattern;
  return canchicards_;
}
inline ::rpc::Pattern* ChiAtionArgs::release_canchicards() {
  clear_has_canchicards();
  ::rpc::Pattern* temp = canchicards_;
  canchicards_ = NULL;
  return temp;
}

// repeated .rpc.Pattern needBiCards = 2;
inline int ChiAtionArgs::needbicards_size() const {
  return needbicards_.size();
}
inline void ChiAtionArgs::clear_needbicards() {
  needbicards_.Clear();
}
inline const ::rpc::Pattern& ChiAtionArgs::needbicards(int index) const {
  return needbicards_.Get(index);
}
inline ::rpc::Pattern* ChiAtionArgs::mutable_needbicards(int index) {
  return needbicards_.Mutable(index);
}
inline ::rpc::Pattern* ChiAtionArgs::add_needbicards() {
  return needbicards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
ChiAtionArgs::needbicards() const {
  return needbicards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
ChiAtionArgs::mutable_needbicards() {
  return &needbicards_;
}

// optional .rpc.Card cardArgs = 3;
inline bool ChiAtionArgs::has_cardargs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChiAtionArgs::set_has_cardargs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChiAtionArgs::clear_has_cardargs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChiAtionArgs::clear_cardargs() {
  if (cardargs_ != NULL) cardargs_->::rpc::Card::Clear();
  clear_has_cardargs();
}
inline const ::rpc::Card& ChiAtionArgs::cardargs() const {
  return cardargs_ != NULL ? *cardargs_ : *default_instance_->cardargs_;
}
inline ::rpc::Card* ChiAtionArgs::mutable_cardargs() {
  set_has_cardargs();
  if (cardargs_ == NULL) cardargs_ = new ::rpc::Card;
  return cardargs_;
}
inline ::rpc::Card* ChiAtionArgs::release_cardargs() {
  clear_has_cardargs();
  ::rpc::Card* temp = cardargs_;
  cardargs_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ActionACK

// required int32 action = 1;
inline bool ActionACK::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionACK::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionACK::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionACK::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 ActionACK::action() const {
  return action_;
}
inline void ActionACK::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// optional string playerID = 2;
inline bool ActionACK::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionACK::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionACK::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionACK::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& ActionACK::playerid() const {
  return *playerid_;
}
inline void ActionACK::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ActionACK::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ActionACK::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionACK::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* ActionACK::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .rpc.Card cardArgs = 4;
inline bool ActionACK::has_cardargs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActionACK::set_has_cardargs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActionACK::clear_has_cardargs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActionACK::clear_cardargs() {
  if (cardargs_ != NULL) cardargs_->::rpc::Card::Clear();
  clear_has_cardargs();
}
inline const ::rpc::Card& ActionACK::cardargs() const {
  return cardargs_ != NULL ? *cardargs_ : *default_instance_->cardargs_;
}
inline ::rpc::Card* ActionACK::mutable_cardargs() {
  set_has_cardargs();
  if (cardargs_ == NULL) cardargs_ = new ::rpc::Card;
  return cardargs_;
}
inline ::rpc::Card* ActionACK::release_cardargs() {
  clear_has_cardargs();
  ::rpc::Card* temp = cardargs_;
  cardargs_ = NULL;
  return temp;
}

// repeated .rpc.Pattern chiPengZhaoLongCards = 6;
inline int ActionACK::chipengzhaolongcards_size() const {
  return chipengzhaolongcards_.size();
}
inline void ActionACK::clear_chipengzhaolongcards() {
  chipengzhaolongcards_.Clear();
}
inline const ::rpc::Pattern& ActionACK::chipengzhaolongcards(int index) const {
  return chipengzhaolongcards_.Get(index);
}
inline ::rpc::Pattern* ActionACK::mutable_chipengzhaolongcards(int index) {
  return chipengzhaolongcards_.Mutable(index);
}
inline ::rpc::Pattern* ActionACK::add_chipengzhaolongcards() {
  return chipengzhaolongcards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
ActionACK::chipengzhaolongcards() const {
  return chipengzhaolongcards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
ActionACK::mutable_chipengzhaolongcards() {
  return &chipengzhaolongcards_;
}

// optional int32 updateHu = 7;
inline bool ActionACK::has_updatehu() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActionACK::set_has_updatehu() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActionACK::clear_has_updatehu() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActionACK::clear_updatehu() {
  updatehu_ = 0;
  clear_has_updatehu();
}
inline ::google::protobuf::int32 ActionACK::updatehu() const {
  return updatehu_;
}
inline void ActionACK::set_updatehu(::google::protobuf::int32 value) {
  set_has_updatehu();
  updatehu_ = value;
}

// optional int32 currenDeskRemianCard = 8;
inline bool ActionACK::has_currendeskremiancard() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActionACK::set_has_currendeskremiancard() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActionACK::clear_has_currendeskremiancard() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActionACK::clear_currendeskremiancard() {
  currendeskremiancard_ = 0;
  clear_has_currendeskremiancard();
}
inline ::google::protobuf::int32 ActionACK::currendeskremiancard() const {
  return currendeskremiancard_;
}
inline void ActionACK::set_currendeskremiancard(::google::protobuf::int32 value) {
  set_has_currendeskremiancard();
  currendeskremiancard_ = value;
}

// required int32 result = 9;
inline bool ActionACK::has_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActionACK::set_has_result() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActionACK::clear_has_result() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActionACK::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActionACK::result() const {
  return result_;
}
inline void ActionACK::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ActionNotifyACK

// required int32 action = 1;
inline bool ActionNotifyACK::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionNotifyACK::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionNotifyACK::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionNotifyACK::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 ActionNotifyACK::action() const {
  return action_;
}
inline void ActionNotifyACK::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// repeated .rpc.ChiAtionArgs chiAtionArgs = 3;
inline int ActionNotifyACK::chiationargs_size() const {
  return chiationargs_.size();
}
inline void ActionNotifyACK::clear_chiationargs() {
  chiationargs_.Clear();
}
inline const ::rpc::ChiAtionArgs& ActionNotifyACK::chiationargs(int index) const {
  return chiationargs_.Get(index);
}
inline ::rpc::ChiAtionArgs* ActionNotifyACK::mutable_chiationargs(int index) {
  return chiationargs_.Mutable(index);
}
inline ::rpc::ChiAtionArgs* ActionNotifyACK::add_chiationargs() {
  return chiationargs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::ChiAtionArgs >&
ActionNotifyACK::chiationargs() const {
  return chiationargs_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::ChiAtionArgs >*
ActionNotifyACK::mutable_chiationargs() {
  return &chiationargs_;
}

// -------------------------------------------------------------------

// CountdownNotifyACK

// required .rpc.CountDown countDown = 1;
inline bool CountdownNotifyACK::has_countdown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CountdownNotifyACK::set_has_countdown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CountdownNotifyACK::clear_has_countdown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CountdownNotifyACK::clear_countdown() {
  if (countdown_ != NULL) countdown_->::rpc::CountDown::Clear();
  clear_has_countdown();
}
inline const ::rpc::CountDown& CountdownNotifyACK::countdown() const {
  return countdown_ != NULL ? *countdown_ : *default_instance_->countdown_;
}
inline ::rpc::CountDown* CountdownNotifyACK::mutable_countdown() {
  set_has_countdown();
  if (countdown_ == NULL) countdown_ = new ::rpc::CountDown;
  return countdown_;
}
inline ::rpc::CountDown* CountdownNotifyACK::release_countdown() {
  clear_has_countdown();
  ::rpc::CountDown* temp = countdown_;
  countdown_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PassCardNotifyACK

// required string playerID = 1;
inline bool PassCardNotifyACK::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PassCardNotifyACK::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PassCardNotifyACK::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PassCardNotifyACK::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PassCardNotifyACK::playerid() const {
  return *playerid_;
}
inline void PassCardNotifyACK::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PassCardNotifyACK::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PassCardNotifyACK::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PassCardNotifyACK::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PassCardNotifyACK::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .rpc.Card card = 2;
inline bool PassCardNotifyACK::has_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PassCardNotifyACK::set_has_card() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PassCardNotifyACK::clear_has_card() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PassCardNotifyACK::clear_card() {
  if (card_ != NULL) card_->::rpc::Card::Clear();
  clear_has_card();
}
inline const ::rpc::Card& PassCardNotifyACK::card() const {
  return card_ != NULL ? *card_ : *default_instance_->card_;
}
inline ::rpc::Card* PassCardNotifyACK::mutable_card() {
  set_has_card();
  if (card_ == NULL) card_ = new ::rpc::Card;
  return card_;
}
inline ::rpc::Card* PassCardNotifyACK::release_card() {
  clear_has_card();
  ::rpc::Card* temp = card_;
  card_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PassedNotifyACK

// required .rpc.Card card = 1;
inline bool PassedNotifyACK::has_card() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PassedNotifyACK::set_has_card() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PassedNotifyACK::clear_has_card() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PassedNotifyACK::clear_card() {
  if (card_ != NULL) card_->::rpc::Card::Clear();
  clear_has_card();
}
inline const ::rpc::Card& PassedNotifyACK::card() const {
  return card_ != NULL ? *card_ : *default_instance_->card_;
}
inline ::rpc::Card* PassedNotifyACK::mutable_card() {
  set_has_card();
  if (card_ == NULL) card_ = new ::rpc::Card;
  return card_;
}
inline ::rpc::Card* PassedNotifyACK::release_card() {
  clear_has_card();
  ::rpc::Card* temp = card_;
  card_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// MingTang

// required int32 mingTang = 1;
inline bool MingTang::has_mingtang() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MingTang::set_has_mingtang() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MingTang::clear_has_mingtang() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MingTang::clear_mingtang() {
  mingtang_ = 0;
  clear_has_mingtang();
}
inline ::google::protobuf::int32 MingTang::mingtang() const {
  return mingtang_;
}
inline void MingTang::set_mingtang(::google::protobuf::int32 value) {
  set_has_mingtang();
  mingtang_ = value;
}

// required int32 value = 2;
inline bool MingTang::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MingTang::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MingTang::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MingTang::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 MingTang::value() const {
  return value_;
}
inline void MingTang::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// JieSuanCoin

// required string playerID = 1;
inline bool JieSuanCoin::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JieSuanCoin::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JieSuanCoin::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JieSuanCoin::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& JieSuanCoin::playerid() const {
  return *playerid_;
}
inline void JieSuanCoin::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void JieSuanCoin::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void JieSuanCoin::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JieSuanCoin::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* JieSuanCoin::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 coin = 2;
inline bool JieSuanCoin::has_coin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JieSuanCoin::set_has_coin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JieSuanCoin::clear_has_coin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JieSuanCoin::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 JieSuanCoin::coin() const {
  return coin_;
}
inline void JieSuanCoin::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 tag = 3;
inline bool JieSuanCoin::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JieSuanCoin::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JieSuanCoin::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JieSuanCoin::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 JieSuanCoin::tag() const {
  return tag_;
}
inline void JieSuanCoin::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// -------------------------------------------------------------------

// DaerPlayerJieSuanPattern

// required string playerID = 1;
inline bool DaerPlayerJieSuanPattern::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DaerPlayerJieSuanPattern::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DaerPlayerJieSuanPattern::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DaerPlayerJieSuanPattern::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& DaerPlayerJieSuanPattern::playerid() const {
  return *playerid_;
}
inline void DaerPlayerJieSuanPattern::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void DaerPlayerJieSuanPattern::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void DaerPlayerJieSuanPattern::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DaerPlayerJieSuanPattern::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* DaerPlayerJieSuanPattern::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 hu = 3;
inline bool DaerPlayerJieSuanPattern::has_hu() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DaerPlayerJieSuanPattern::set_has_hu() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DaerPlayerJieSuanPattern::clear_has_hu() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DaerPlayerJieSuanPattern::clear_hu() {
  hu_ = 0;
  clear_has_hu();
}
inline ::google::protobuf::int32 DaerPlayerJieSuanPattern::hu() const {
  return hu_;
}
inline void DaerPlayerJieSuanPattern::set_hu(::google::protobuf::int32 value) {
  set_has_hu();
  hu_ = value;
}

// optional int32 score = 5;
inline bool DaerPlayerJieSuanPattern::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DaerPlayerJieSuanPattern::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DaerPlayerJieSuanPattern::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DaerPlayerJieSuanPattern::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 DaerPlayerJieSuanPattern::score() const {
  return score_;
}
inline void DaerPlayerJieSuanPattern::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// repeated .rpc.Pattern patterns = 7;
inline int DaerPlayerJieSuanPattern::patterns_size() const {
  return patterns_.size();
}
inline void DaerPlayerJieSuanPattern::clear_patterns() {
  patterns_.Clear();
}
inline const ::rpc::Pattern& DaerPlayerJieSuanPattern::patterns(int index) const {
  return patterns_.Get(index);
}
inline ::rpc::Pattern* DaerPlayerJieSuanPattern::mutable_patterns(int index) {
  return patterns_.Mutable(index);
}
inline ::rpc::Pattern* DaerPlayerJieSuanPattern::add_patterns() {
  return patterns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >&
DaerPlayerJieSuanPattern::patterns() const {
  return patterns_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pattern >*
DaerPlayerJieSuanPattern::mutable_patterns() {
  return &patterns_;
}

// repeated .rpc.MingTang mingTang = 9;
inline int DaerPlayerJieSuanPattern::mingtang_size() const {
  return mingtang_.size();
}
inline void DaerPlayerJieSuanPattern::clear_mingtang() {
  mingtang_.Clear();
}
inline const ::rpc::MingTang& DaerPlayerJieSuanPattern::mingtang(int index) const {
  return mingtang_.Get(index);
}
inline ::rpc::MingTang* DaerPlayerJieSuanPattern::mutable_mingtang(int index) {
  return mingtang_.Mutable(index);
}
inline ::rpc::MingTang* DaerPlayerJieSuanPattern::add_mingtang() {
  return mingtang_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MingTang >&
DaerPlayerJieSuanPattern::mingtang() const {
  return mingtang_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MingTang >*
DaerPlayerJieSuanPattern::mutable_mingtang() {
  return &mingtang_;
}

// required int32 coin = 11;
inline bool DaerPlayerJieSuanPattern::has_coin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DaerPlayerJieSuanPattern::set_has_coin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DaerPlayerJieSuanPattern::clear_has_coin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DaerPlayerJieSuanPattern::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 DaerPlayerJieSuanPattern::coin() const {
  return coin_;
}
inline void DaerPlayerJieSuanPattern::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// required int32 tag = 13;
inline bool DaerPlayerJieSuanPattern::has_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DaerPlayerJieSuanPattern::set_has_tag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DaerPlayerJieSuanPattern::clear_has_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DaerPlayerJieSuanPattern::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 DaerPlayerJieSuanPattern::tag() const {
  return tag_;
}
inline void DaerPlayerJieSuanPattern::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// -------------------------------------------------------------------

// JieSuanNotifyACK

// repeated .rpc.DaerPlayerJieSuanPattern daerPlayerJieSuanPattern = 1;
inline int JieSuanNotifyACK::daerplayerjiesuanpattern_size() const {
  return daerplayerjiesuanpattern_.size();
}
inline void JieSuanNotifyACK::clear_daerplayerjiesuanpattern() {
  daerplayerjiesuanpattern_.Clear();
}
inline const ::rpc::DaerPlayerJieSuanPattern& JieSuanNotifyACK::daerplayerjiesuanpattern(int index) const {
  return daerplayerjiesuanpattern_.Get(index);
}
inline ::rpc::DaerPlayerJieSuanPattern* JieSuanNotifyACK::mutable_daerplayerjiesuanpattern(int index) {
  return daerplayerjiesuanpattern_.Mutable(index);
}
inline ::rpc::DaerPlayerJieSuanPattern* JieSuanNotifyACK::add_daerplayerjiesuanpattern() {
  return daerplayerjiesuanpattern_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::DaerPlayerJieSuanPattern >&
JieSuanNotifyACK::daerplayerjiesuanpattern() const {
  return daerplayerjiesuanpattern_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::DaerPlayerJieSuanPattern >*
JieSuanNotifyACK::mutable_daerplayerjiesuanpattern() {
  return &daerplayerjiesuanpattern_;
}

// repeated .rpc.Card diCards = 7;
inline int JieSuanNotifyACK::dicards_size() const {
  return dicards_.size();
}
inline void JieSuanNotifyACK::clear_dicards() {
  dicards_.Clear();
}
inline const ::rpc::Card& JieSuanNotifyACK::dicards(int index) const {
  return dicards_.Get(index);
}
inline ::rpc::Card* JieSuanNotifyACK::mutable_dicards(int index) {
  return dicards_.Mutable(index);
}
inline ::rpc::Card* JieSuanNotifyACK::add_dicards() {
  return dicards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Card >&
JieSuanNotifyACK::dicards() const {
  return dicards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Card >*
JieSuanNotifyACK::mutable_dicards() {
  return &dicards_;
}

// optional bool huangZhuang = 9;
inline bool JieSuanNotifyACK::has_huangzhuang() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JieSuanNotifyACK::set_has_huangzhuang() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JieSuanNotifyACK::clear_has_huangzhuang() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JieSuanNotifyACK::clear_huangzhuang() {
  huangzhuang_ = false;
  clear_has_huangzhuang();
}
inline bool JieSuanNotifyACK::huangzhuang() const {
  return huangzhuang_;
}
inline void JieSuanNotifyACK::set_huangzhuang(bool value) {
  set_has_huangzhuang();
  huangzhuang_ = value;
}

// optional .rpc.JieSuanAdditionData addi = 11;
inline bool JieSuanNotifyACK::has_addi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JieSuanNotifyACK::set_has_addi() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JieSuanNotifyACK::clear_has_addi() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JieSuanNotifyACK::clear_addi() {
  if (addi_ != NULL) addi_->::rpc::JieSuanAdditionData::Clear();
  clear_has_addi();
}
inline const ::rpc::JieSuanAdditionData& JieSuanNotifyACK::addi() const {
  return addi_ != NULL ? *addi_ : *default_instance_->addi_;
}
inline ::rpc::JieSuanAdditionData* JieSuanNotifyACK::mutable_addi() {
  set_has_addi();
  if (addi_ == NULL) addi_ = new ::rpc::JieSuanAdditionData;
  return addi_;
}
inline ::rpc::JieSuanAdditionData* JieSuanNotifyACK::release_addi() {
  clear_has_addi();
  ::rpc::JieSuanAdditionData* temp = addi_;
  addi_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// JieSuanAdditionData

// optional int32 sysType = 1;
inline bool JieSuanAdditionData::has_systype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JieSuanAdditionData::set_has_systype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JieSuanAdditionData::clear_has_systype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JieSuanAdditionData::clear_systype() {
  systype_ = 0;
  clear_has_systype();
}
inline ::google::protobuf::int32 JieSuanAdditionData::systype() const {
  return systype_;
}
inline void JieSuanAdditionData::set_systype(::google::protobuf::int32 value) {
  set_has_systype();
  systype_ = value;
}

// optional bool stageEnd = 2;
inline bool JieSuanAdditionData::has_stageend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JieSuanAdditionData::set_has_stageend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JieSuanAdditionData::clear_has_stageend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JieSuanAdditionData::clear_stageend() {
  stageend_ = false;
  clear_has_stageend();
}
inline bool JieSuanAdditionData::stageend() const {
  return stageend_;
}
inline void JieSuanAdditionData::set_stageend(bool value) {
  set_has_stageend();
  stageend_ = value;
}

// optional bool success = 3;
inline bool JieSuanAdditionData::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JieSuanAdditionData::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JieSuanAdditionData::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JieSuanAdditionData::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool JieSuanAdditionData::success() const {
  return success_;
}
inline void JieSuanAdditionData::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// repeated .rpc.JieSuanCoin coin = 4;
inline int JieSuanAdditionData::coin_size() const {
  return coin_.size();
}
inline void JieSuanAdditionData::clear_coin() {
  coin_.Clear();
}
inline const ::rpc::JieSuanCoin& JieSuanAdditionData::coin(int index) const {
  return coin_.Get(index);
}
inline ::rpc::JieSuanCoin* JieSuanAdditionData::mutable_coin(int index) {
  return coin_.Mutable(index);
}
inline ::rpc::JieSuanCoin* JieSuanAdditionData::add_coin() {
  return coin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::JieSuanCoin >&
JieSuanAdditionData::coin() const {
  return coin_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::JieSuanCoin >*
JieSuanAdditionData::mutable_coin() {
  return &coin_;
}

// optional int64 jieSuanTime = 5;
inline bool JieSuanAdditionData::has_jiesuantime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JieSuanAdditionData::set_has_jiesuantime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JieSuanAdditionData::clear_has_jiesuantime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JieSuanAdditionData::clear_jiesuantime() {
  jiesuantime_ = GOOGLE_LONGLONG(0);
  clear_has_jiesuantime();
}
inline ::google::protobuf::int64 JieSuanAdditionData::jiesuantime() const {
  return jiesuantime_;
}
inline void JieSuanAdditionData::set_jiesuantime(::google::protobuf::int64 value) {
  set_has_jiesuantime();
  jiesuantime_ = value;
}

// optional int32 curTimes = 6;
inline bool JieSuanAdditionData::has_curtimes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JieSuanAdditionData::set_has_curtimes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JieSuanAdditionData::clear_has_curtimes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JieSuanAdditionData::clear_curtimes() {
  curtimes_ = 0;
  clear_has_curtimes();
}
inline ::google::protobuf::int32 JieSuanAdditionData::curtimes() const {
  return curtimes_;
}
inline void JieSuanAdditionData::set_curtimes(::google::protobuf::int32 value) {
  set_has_curtimes();
  curtimes_ = value;
}

// optional int32 continueTime = 7;
inline bool JieSuanAdditionData::has_continuetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void JieSuanAdditionData::set_has_continuetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void JieSuanAdditionData::clear_has_continuetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void JieSuanAdditionData::clear_continuetime() {
  continuetime_ = 0;
  clear_has_continuetime();
}
inline ::google::protobuf::int32 JieSuanAdditionData::continuetime() const {
  return continuetime_;
}
inline void JieSuanAdditionData::set_continuetime(::google::protobuf::int32 value) {
  set_has_continuetime();
  continuetime_ = value;
}

// -------------------------------------------------------------------

// FinalJieSuanNotifyACK

// required .rpc.JieSuanAdditionData jieSuanInfo = 1;
inline bool FinalJieSuanNotifyACK::has_jiesuaninfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinalJieSuanNotifyACK::set_has_jiesuaninfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinalJieSuanNotifyACK::clear_has_jiesuaninfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinalJieSuanNotifyACK::clear_jiesuaninfo() {
  if (jiesuaninfo_ != NULL) jiesuaninfo_->::rpc::JieSuanAdditionData::Clear();
  clear_has_jiesuaninfo();
}
inline const ::rpc::JieSuanAdditionData& FinalJieSuanNotifyACK::jiesuaninfo() const {
  return jiesuaninfo_ != NULL ? *jiesuaninfo_ : *default_instance_->jiesuaninfo_;
}
inline ::rpc::JieSuanAdditionData* FinalJieSuanNotifyACK::mutable_jiesuaninfo() {
  set_has_jiesuaninfo();
  if (jiesuaninfo_ == NULL) jiesuaninfo_ = new ::rpc::JieSuanAdditionData;
  return jiesuaninfo_;
}
inline ::rpc::JieSuanAdditionData* FinalJieSuanNotifyACK::release_jiesuaninfo() {
  clear_has_jiesuaninfo();
  ::rpc::JieSuanAdditionData* temp = jiesuaninfo_;
  jiesuaninfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// MJCard

// required int32 value = 1;
inline bool MJCard::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJCard::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJCard::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJCard::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 MJCard::value() const {
  return value_;
}
inline void MJCard::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// required int32 cType = 2;
inline bool MJCard::has_ctype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJCard::set_has_ctype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJCard::clear_has_ctype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJCard::clear_ctype() {
  ctype_ = 0;
  clear_has_ctype();
}
inline ::google::protobuf::int32 MJCard::ctype() const {
  return ctype_;
}
inline void MJCard::set_ctype(::google::protobuf::int32 value) {
  set_has_ctype();
  ctype_ = value;
}

// required int32 rcType = 3;
inline bool MJCard::has_rctype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJCard::set_has_rctype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJCard::clear_has_rctype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJCard::clear_rctype() {
  rctype_ = 0;
  clear_has_rctype();
}
inline ::google::protobuf::int32 MJCard::rctype() const {
  return rctype_;
}
inline void MJCard::set_rctype(::google::protobuf::int32 value) {
  set_has_rctype();
  rctype_ = value;
}

// optional int32 flag = 4;
inline bool MJCard::has_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MJCard::set_has_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MJCard::clear_has_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MJCard::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 MJCard::flag() const {
  return flag_;
}
inline void MJCard::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// MJPattern

// required int32 ptype = 1;
inline bool MJPattern::has_ptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJPattern::set_has_ptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJPattern::clear_has_ptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJPattern::clear_ptype() {
  ptype_ = 0;
  clear_has_ptype();
}
inline ::google::protobuf::int32 MJPattern::ptype() const {
  return ptype_;
}
inline void MJPattern::set_ptype(::google::protobuf::int32 value) {
  set_has_ptype();
  ptype_ = value;
}

// required int32 cType = 2;
inline bool MJPattern::has_ctype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJPattern::set_has_ctype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJPattern::clear_has_ctype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJPattern::clear_ctype() {
  ctype_ = 0;
  clear_has_ctype();
}
inline ::google::protobuf::int32 MJPattern::ctype() const {
  return ctype_;
}
inline void MJPattern::set_ctype(::google::protobuf::int32 value) {
  set_has_ctype();
  ctype_ = value;
}

// repeated .rpc.MJCard cards = 3;
inline int MJPattern::cards_size() const {
  return cards_.size();
}
inline void MJPattern::clear_cards() {
  cards_.Clear();
}
inline const ::rpc::MJCard& MJPattern::cards(int index) const {
  return cards_.Get(index);
}
inline ::rpc::MJCard* MJPattern::mutable_cards(int index) {
  return cards_.Mutable(index);
}
inline ::rpc::MJCard* MJPattern::add_cards() {
  return cards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >&
MJPattern::cards() const {
  return cards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >*
MJPattern::mutable_cards() {
  return &cards_;
}

// optional bool isShow = 4;
inline bool MJPattern::has_isshow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MJPattern::set_has_isshow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MJPattern::clear_has_isshow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MJPattern::clear_isshow() {
  isshow_ = false;
  clear_has_isshow();
}
inline bool MJPattern::isshow() const {
  return isshow_;
}
inline void MJPattern::set_isshow(bool value) {
  set_has_isshow();
  isshow_ = value;
}

// -------------------------------------------------------------------

// MJQuickEnterRoomREQ

// -------------------------------------------------------------------

// MJEnterRoomACK

// optional .rpc.PlayerBaseInfo playerInfo = 1;
inline bool MJEnterRoomACK::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJEnterRoomACK::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJEnterRoomACK::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJEnterRoomACK::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::rpc::PlayerBaseInfo::Clear();
  clear_has_playerinfo();
}
inline const ::rpc::PlayerBaseInfo& MJEnterRoomACK::playerinfo() const {
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance_->playerinfo_;
}
inline ::rpc::PlayerBaseInfo* MJEnterRoomACK::mutable_playerinfo() {
  set_has_playerinfo();
  if (playerinfo_ == NULL) playerinfo_ = new ::rpc::PlayerBaseInfo;
  return playerinfo_;
}
inline ::rpc::PlayerBaseInfo* MJEnterRoomACK::release_playerinfo() {
  clear_has_playerinfo();
  ::rpc::PlayerBaseInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}

// optional int32 location = 2;
inline bool MJEnterRoomACK::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJEnterRoomACK::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJEnterRoomACK::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJEnterRoomACK::clear_location() {
  location_ = 0;
  clear_has_location();
}
inline ::google::protobuf::int32 MJEnterRoomACK::location() const {
  return location_;
}
inline void MJEnterRoomACK::set_location(::google::protobuf::int32 value) {
  set_has_location();
  location_ = value;
}

// optional bool bReady = 3;
inline bool MJEnterRoomACK::has_bready() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJEnterRoomACK::set_has_bready() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJEnterRoomACK::clear_has_bready() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJEnterRoomACK::clear_bready() {
  bready_ = false;
  clear_has_bready();
}
inline bool MJEnterRoomACK::bready() const {
  return bready_;
}
inline void MJEnterRoomACK::set_bready(bool value) {
  set_has_bready();
  bready_ = value;
}

// optional int32 code = 4;
inline bool MJEnterRoomACK::has_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MJEnterRoomACK::set_has_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MJEnterRoomACK::clear_has_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MJEnterRoomACK::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 MJEnterRoomACK::code() const {
  return code_;
}
inline void MJEnterRoomACK::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional int32 roomId = 5;
inline bool MJEnterRoomACK::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MJEnterRoomACK::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MJEnterRoomACK::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MJEnterRoomACK::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 MJEnterRoomACK::roomid() const {
  return roomid_;
}
inline void MJEnterRoomACK::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional bool isNormalReqEnterRoom = 6;
inline bool MJEnterRoomACK::has_isnormalreqenterroom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MJEnterRoomACK::set_has_isnormalreqenterroom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MJEnterRoomACK::clear_has_isnormalreqenterroom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MJEnterRoomACK::clear_isnormalreqenterroom() {
  isnormalreqenterroom_ = false;
  clear_has_isnormalreqenterroom();
}
inline bool MJEnterRoomACK::isnormalreqenterroom() const {
  return isnormalreqenterroom_;
}
inline void MJEnterRoomACK::set_isnormalreqenterroom(bool value) {
  set_has_isnormalreqenterroom();
  isnormalreqenterroom_ = value;
}

// -------------------------------------------------------------------

// MJLeaveRoomREQ

// required string playerID = 1;
inline bool MJLeaveRoomREQ::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJLeaveRoomREQ::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJLeaveRoomREQ::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJLeaveRoomREQ::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& MJLeaveRoomREQ::playerid() const {
  return *playerid_;
}
inline void MJLeaveRoomREQ::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJLeaveRoomREQ::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJLeaveRoomREQ::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJLeaveRoomREQ::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* MJLeaveRoomREQ::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isChangeDesk = 2;
inline bool MJLeaveRoomREQ::has_ischangedesk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJLeaveRoomREQ::set_has_ischangedesk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJLeaveRoomREQ::clear_has_ischangedesk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJLeaveRoomREQ::clear_ischangedesk() {
  ischangedesk_ = false;
  clear_has_ischangedesk();
}
inline bool MJLeaveRoomREQ::ischangedesk() const {
  return ischangedesk_;
}
inline void MJLeaveRoomREQ::set_ischangedesk(bool value) {
  set_has_ischangedesk();
  ischangedesk_ = value;
}

// -------------------------------------------------------------------

// MJLeaveRoomACK

// required string playerID = 1;
inline bool MJLeaveRoomACK::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJLeaveRoomACK::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJLeaveRoomACK::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJLeaveRoomACK::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& MJLeaveRoomACK::playerid() const {
  return *playerid_;
}
inline void MJLeaveRoomACK::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJLeaveRoomACK::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJLeaveRoomACK::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJLeaveRoomACK::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* MJLeaveRoomACK::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isChangeDesk = 2;
inline bool MJLeaveRoomACK::has_ischangedesk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJLeaveRoomACK::set_has_ischangedesk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJLeaveRoomACK::clear_has_ischangedesk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJLeaveRoomACK::clear_ischangedesk() {
  ischangedesk_ = false;
  clear_has_ischangedesk();
}
inline bool MJLeaveRoomACK::ischangedesk() const {
  return ischangedesk_;
}
inline void MJLeaveRoomACK::set_ischangedesk(bool value) {
  set_has_ischangedesk();
  ischangedesk_ = value;
}

// -------------------------------------------------------------------

// MJCountDown

// required string playerID = 1;
inline bool MJCountDown::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJCountDown::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJCountDown::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJCountDown::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& MJCountDown::playerid() const {
  return *playerid_;
}
inline void MJCountDown::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJCountDown::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJCountDown::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJCountDown::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* MJCountDown::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 currentCountDown = 2;
inline bool MJCountDown::has_currentcountdown() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJCountDown::set_has_currentcountdown() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJCountDown::clear_has_currentcountdown() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJCountDown::clear_currentcountdown() {
  currentcountdown_ = 0;
  clear_has_currentcountdown();
}
inline ::google::protobuf::int32 MJCountDown::currentcountdown() const {
  return currentcountdown_;
}
inline void MJCountDown::set_currentcountdown(::google::protobuf::int32 value) {
  set_has_currentcountdown();
  currentcountdown_ = value;
}

// -------------------------------------------------------------------

// MJFightPlayerInfo

// required string playerID = 1;
inline bool MJFightPlayerInfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJFightPlayerInfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJFightPlayerInfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJFightPlayerInfo::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& MJFightPlayerInfo::playerid() const {
  return *playerid_;
}
inline void MJFightPlayerInfo::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJFightPlayerInfo::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJFightPlayerInfo::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJFightPlayerInfo::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* MJFightPlayerInfo::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .rpc.MJCard handCards = 2;
inline int MJFightPlayerInfo::handcards_size() const {
  return handcards_.size();
}
inline void MJFightPlayerInfo::clear_handcards() {
  handcards_.Clear();
}
inline const ::rpc::MJCard& MJFightPlayerInfo::handcards(int index) const {
  return handcards_.Get(index);
}
inline ::rpc::MJCard* MJFightPlayerInfo::mutable_handcards(int index) {
  return handcards_.Mutable(index);
}
inline ::rpc::MJCard* MJFightPlayerInfo::add_handcards() {
  return handcards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >&
MJFightPlayerInfo::handcards() const {
  return handcards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >*
MJFightPlayerInfo::mutable_handcards() {
  return &handcards_;
}

// repeated .rpc.MJPattern showPatterns = 4;
inline int MJFightPlayerInfo::showpatterns_size() const {
  return showpatterns_.size();
}
inline void MJFightPlayerInfo::clear_showpatterns() {
  showpatterns_.Clear();
}
inline const ::rpc::MJPattern& MJFightPlayerInfo::showpatterns(int index) const {
  return showpatterns_.Get(index);
}
inline ::rpc::MJPattern* MJFightPlayerInfo::mutable_showpatterns(int index) {
  return showpatterns_.Mutable(index);
}
inline ::rpc::MJPattern* MJFightPlayerInfo::add_showpatterns() {
  return showpatterns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >&
MJFightPlayerInfo::showpatterns() const {
  return showpatterns_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >*
MJFightPlayerInfo::mutable_showpatterns() {
  return &showpatterns_;
}

// repeated .rpc.MJCard chuCards = 6;
inline int MJFightPlayerInfo::chucards_size() const {
  return chucards_.size();
}
inline void MJFightPlayerInfo::clear_chucards() {
  chucards_.Clear();
}
inline const ::rpc::MJCard& MJFightPlayerInfo::chucards(int index) const {
  return chucards_.Get(index);
}
inline ::rpc::MJCard* MJFightPlayerInfo::mutable_chucards(int index) {
  return chucards_.Mutable(index);
}
inline ::rpc::MJCard* MJFightPlayerInfo::add_chucards() {
  return chucards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >&
MJFightPlayerInfo::chucards() const {
  return chucards_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >*
MJFightPlayerInfo::mutable_chucards() {
  return &chucards_;
}

// optional bool bZhuang = 9;
inline bool MJFightPlayerInfo::has_bzhuang() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MJFightPlayerInfo::set_has_bzhuang() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MJFightPlayerInfo::clear_has_bzhuang() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MJFightPlayerInfo::clear_bzhuang() {
  bzhuang_ = false;
  clear_has_bzhuang();
}
inline bool MJFightPlayerInfo::bzhuang() const {
  return bzhuang_;
}
inline void MJFightPlayerInfo::set_bzhuang(bool value) {
  set_has_bzhuang();
  bzhuang_ = value;
}

// optional bool bBao = 10;
inline bool MJFightPlayerInfo::has_bbao() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MJFightPlayerInfo::set_has_bbao() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MJFightPlayerInfo::clear_has_bbao() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MJFightPlayerInfo::clear_bbao() {
  bbao_ = false;
  clear_has_bbao();
}
inline bool MJFightPlayerInfo::bbao() const {
  return bbao_;
}
inline void MJFightPlayerInfo::set_bbao(bool value) {
  set_has_bbao();
  bbao_ = value;
}

// optional bool bTuoGuan = 11;
inline bool MJFightPlayerInfo::has_btuoguan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MJFightPlayerInfo::set_has_btuoguan() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MJFightPlayerInfo::clear_has_btuoguan() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MJFightPlayerInfo::clear_btuoguan() {
  btuoguan_ = false;
  clear_has_btuoguan();
}
inline bool MJFightPlayerInfo::btuoguan() const {
  return btuoguan_;
}
inline void MJFightPlayerInfo::set_btuoguan(bool value) {
  set_has_btuoguan();
  btuoguan_ = value;
}

// optional int32 handCardCount = 12;
inline bool MJFightPlayerInfo::has_handcardcount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MJFightPlayerInfo::set_has_handcardcount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MJFightPlayerInfo::clear_has_handcardcount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MJFightPlayerInfo::clear_handcardcount() {
  handcardcount_ = 0;
  clear_has_handcardcount();
}
inline ::google::protobuf::int32 MJFightPlayerInfo::handcardcount() const {
  return handcardcount_;
}
inline void MJFightPlayerInfo::set_handcardcount(::google::protobuf::int32 value) {
  set_has_handcardcount();
  handcardcount_ = value;
}

// optional .rpc.MJCard alreadyCardArg = 13;
inline bool MJFightPlayerInfo::has_alreadycardarg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MJFightPlayerInfo::set_has_alreadycardarg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MJFightPlayerInfo::clear_has_alreadycardarg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MJFightPlayerInfo::clear_alreadycardarg() {
  if (alreadycardarg_ != NULL) alreadycardarg_->::rpc::MJCard::Clear();
  clear_has_alreadycardarg();
}
inline const ::rpc::MJCard& MJFightPlayerInfo::alreadycardarg() const {
  return alreadycardarg_ != NULL ? *alreadycardarg_ : *default_instance_->alreadycardarg_;
}
inline ::rpc::MJCard* MJFightPlayerInfo::mutable_alreadycardarg() {
  set_has_alreadycardarg();
  if (alreadycardarg_ == NULL) alreadycardarg_ = new ::rpc::MJCard;
  return alreadycardarg_;
}
inline ::rpc::MJCard* MJFightPlayerInfo::release_alreadycardarg() {
  clear_has_alreadycardarg();
  ::rpc::MJCard* temp = alreadycardarg_;
  alreadycardarg_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// MJFightCurrentStateInfo

// required int32 currentCountDown = 2;
inline bool MJFightCurrentStateInfo::has_currentcountdown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJFightCurrentStateInfo::set_has_currentcountdown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJFightCurrentStateInfo::clear_has_currentcountdown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJFightCurrentStateInfo::clear_currentcountdown() {
  currentcountdown_ = 0;
  clear_has_currentcountdown();
}
inline ::google::protobuf::int32 MJFightCurrentStateInfo::currentcountdown() const {
  return currentcountdown_;
}
inline void MJFightCurrentStateInfo::set_currentcountdown(::google::protobuf::int32 value) {
  set_has_currentcountdown();
  currentcountdown_ = value;
}

// required string activePlayerID = 3;
inline bool MJFightCurrentStateInfo::has_activeplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJFightCurrentStateInfo::set_has_activeplayerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJFightCurrentStateInfo::clear_has_activeplayerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJFightCurrentStateInfo::clear_activeplayerid() {
  if (activeplayerid_ != &::google::protobuf::internal::kEmptyString) {
    activeplayerid_->clear();
  }
  clear_has_activeplayerid();
}
inline const ::std::string& MJFightCurrentStateInfo::activeplayerid() const {
  return *activeplayerid_;
}
inline void MJFightCurrentStateInfo::set_activeplayerid(const ::std::string& value) {
  set_has_activeplayerid();
  if (activeplayerid_ == &::google::protobuf::internal::kEmptyString) {
    activeplayerid_ = new ::std::string;
  }
  activeplayerid_->assign(value);
}
inline void MJFightCurrentStateInfo::set_activeplayerid(const char* value) {
  set_has_activeplayerid();
  if (activeplayerid_ == &::google::protobuf::internal::kEmptyString) {
    activeplayerid_ = new ::std::string;
  }
  activeplayerid_->assign(value);
}
inline void MJFightCurrentStateInfo::set_activeplayerid(const char* value, size_t size) {
  set_has_activeplayerid();
  if (activeplayerid_ == &::google::protobuf::internal::kEmptyString) {
    activeplayerid_ = new ::std::string;
  }
  activeplayerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJFightCurrentStateInfo::mutable_activeplayerid() {
  set_has_activeplayerid();
  if (activeplayerid_ == &::google::protobuf::internal::kEmptyString) {
    activeplayerid_ = new ::std::string;
  }
  return activeplayerid_;
}
inline ::std::string* MJFightCurrentStateInfo::release_activeplayerid() {
  clear_has_activeplayerid();
  if (activeplayerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = activeplayerid_;
    activeplayerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string lastActivePlayerID = 4;
inline bool MJFightCurrentStateInfo::has_lastactiveplayerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJFightCurrentStateInfo::set_has_lastactiveplayerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJFightCurrentStateInfo::clear_has_lastactiveplayerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJFightCurrentStateInfo::clear_lastactiveplayerid() {
  if (lastactiveplayerid_ != &::google::protobuf::internal::kEmptyString) {
    lastactiveplayerid_->clear();
  }
  clear_has_lastactiveplayerid();
}
inline const ::std::string& MJFightCurrentStateInfo::lastactiveplayerid() const {
  return *lastactiveplayerid_;
}
inline void MJFightCurrentStateInfo::set_lastactiveplayerid(const ::std::string& value) {
  set_has_lastactiveplayerid();
  if (lastactiveplayerid_ == &::google::protobuf::internal::kEmptyString) {
    lastactiveplayerid_ = new ::std::string;
  }
  lastactiveplayerid_->assign(value);
}
inline void MJFightCurrentStateInfo::set_lastactiveplayerid(const char* value) {
  set_has_lastactiveplayerid();
  if (lastactiveplayerid_ == &::google::protobuf::internal::kEmptyString) {
    lastactiveplayerid_ = new ::std::string;
  }
  lastactiveplayerid_->assign(value);
}
inline void MJFightCurrentStateInfo::set_lastactiveplayerid(const char* value, size_t size) {
  set_has_lastactiveplayerid();
  if (lastactiveplayerid_ == &::google::protobuf::internal::kEmptyString) {
    lastactiveplayerid_ = new ::std::string;
  }
  lastactiveplayerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJFightCurrentStateInfo::mutable_lastactiveplayerid() {
  set_has_lastactiveplayerid();
  if (lastactiveplayerid_ == &::google::protobuf::internal::kEmptyString) {
    lastactiveplayerid_ = new ::std::string;
  }
  return lastactiveplayerid_;
}
inline ::std::string* MJFightCurrentStateInfo::release_lastactiveplayerid() {
  clear_has_lastactiveplayerid();
  if (lastactiveplayerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lastactiveplayerid_;
    lastactiveplayerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 currentDeskRemainCard = 5;
inline bool MJFightCurrentStateInfo::has_currentdeskremaincard() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MJFightCurrentStateInfo::set_has_currentdeskremaincard() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MJFightCurrentStateInfo::clear_has_currentdeskremaincard() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MJFightCurrentStateInfo::clear_currentdeskremaincard() {
  currentdeskremaincard_ = 0;
  clear_has_currentdeskremaincard();
}
inline ::google::protobuf::int32 MJFightCurrentStateInfo::currentdeskremaincard() const {
  return currentdeskremaincard_;
}
inline void MJFightCurrentStateInfo::set_currentdeskremaincard(::google::protobuf::int32 value) {
  set_has_currentdeskremaincard();
  currentdeskremaincard_ = value;
}

// -------------------------------------------------------------------

// MJGameStartACK

// repeated .rpc.MJFightPlayerInfo fightPlayersInfo = 1;
inline int MJGameStartACK::fightplayersinfo_size() const {
  return fightplayersinfo_.size();
}
inline void MJGameStartACK::clear_fightplayersinfo() {
  fightplayersinfo_.Clear();
}
inline const ::rpc::MJFightPlayerInfo& MJGameStartACK::fightplayersinfo(int index) const {
  return fightplayersinfo_.Get(index);
}
inline ::rpc::MJFightPlayerInfo* MJGameStartACK::mutable_fightplayersinfo(int index) {
  return fightplayersinfo_.Mutable(index);
}
inline ::rpc::MJFightPlayerInfo* MJGameStartACK::add_fightplayersinfo() {
  return fightplayersinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJFightPlayerInfo >&
MJGameStartACK::fightplayersinfo() const {
  return fightplayersinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJFightPlayerInfo >*
MJGameStartACK::mutable_fightplayersinfo() {
  return &fightplayersinfo_;
}

// optional .rpc.MJFightCurrentStateInfo currentFightState = 2;
inline bool MJGameStartACK::has_currentfightstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJGameStartACK::set_has_currentfightstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJGameStartACK::clear_has_currentfightstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJGameStartACK::clear_currentfightstate() {
  if (currentfightstate_ != NULL) currentfightstate_->::rpc::MJFightCurrentStateInfo::Clear();
  clear_has_currentfightstate();
}
inline const ::rpc::MJFightCurrentStateInfo& MJGameStartACK::currentfightstate() const {
  return currentfightstate_ != NULL ? *currentfightstate_ : *default_instance_->currentfightstate_;
}
inline ::rpc::MJFightCurrentStateInfo* MJGameStartACK::mutable_currentfightstate() {
  set_has_currentfightstate();
  if (currentfightstate_ == NULL) currentfightstate_ = new ::rpc::MJFightCurrentStateInfo;
  return currentfightstate_;
}
inline ::rpc::MJFightCurrentStateInfo* MJGameStartACK::release_currentfightstate() {
  clear_has_currentfightstate();
  ::rpc::MJFightCurrentStateInfo* temp = currentfightstate_;
  currentfightstate_ = NULL;
  return temp;
}

// optional int32 fightState = 5;
inline bool MJGameStartACK::has_fightstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJGameStartACK::set_has_fightstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJGameStartACK::clear_has_fightstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJGameStartACK::clear_fightstate() {
  fightstate_ = 0;
  clear_has_fightstate();
}
inline ::google::protobuf::int32 MJGameStartACK::fightstate() const {
  return fightstate_;
}
inline void MJGameStartACK::set_fightstate(::google::protobuf::int32 value) {
  set_has_fightstate();
  fightstate_ = value;
}

// -------------------------------------------------------------------

// MJActionACK

// required int32 action = 1;
inline bool MJActionACK::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJActionACK::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJActionACK::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJActionACK::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 MJActionACK::action() const {
  return action_;
}
inline void MJActionACK::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// optional string playerID = 2;
inline bool MJActionACK::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJActionACK::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJActionACK::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJActionACK::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& MJActionACK::playerid() const {
  return *playerid_;
}
inline void MJActionACK::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJActionACK::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJActionACK::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJActionACK::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* MJActionACK::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .rpc.MJCard cardArgs = 4;
inline bool MJActionACK::has_cardargs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJActionACK::set_has_cardargs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJActionACK::clear_has_cardargs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJActionACK::clear_cardargs() {
  if (cardargs_ != NULL) cardargs_->::rpc::MJCard::Clear();
  clear_has_cardargs();
}
inline const ::rpc::MJCard& MJActionACK::cardargs() const {
  return cardargs_ != NULL ? *cardargs_ : *default_instance_->cardargs_;
}
inline ::rpc::MJCard* MJActionACK::mutable_cardargs() {
  set_has_cardargs();
  if (cardargs_ == NULL) cardargs_ = new ::rpc::MJCard;
  return cardargs_;
}
inline ::rpc::MJCard* MJActionACK::release_cardargs() {
  clear_has_cardargs();
  ::rpc::MJCard* temp = cardargs_;
  cardargs_ = NULL;
  return temp;
}

// repeated .rpc.MJPattern pengGangPattern = 6;
inline int MJActionACK::penggangpattern_size() const {
  return penggangpattern_.size();
}
inline void MJActionACK::clear_penggangpattern() {
  penggangpattern_.Clear();
}
inline const ::rpc::MJPattern& MJActionACK::penggangpattern(int index) const {
  return penggangpattern_.Get(index);
}
inline ::rpc::MJPattern* MJActionACK::mutable_penggangpattern(int index) {
  return penggangpattern_.Mutable(index);
}
inline ::rpc::MJPattern* MJActionACK::add_penggangpattern() {
  return penggangpattern_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >&
MJActionACK::penggangpattern() const {
  return penggangpattern_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >*
MJActionACK::mutable_penggangpattern() {
  return &penggangpattern_;
}

// optional int32 currenDeskRemianCard = 8;
inline bool MJActionACK::has_currendeskremiancard() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MJActionACK::set_has_currendeskremiancard() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MJActionACK::clear_has_currendeskremiancard() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MJActionACK::clear_currendeskremiancard() {
  currendeskremiancard_ = 0;
  clear_has_currendeskremiancard();
}
inline ::google::protobuf::int32 MJActionACK::currendeskremiancard() const {
  return currendeskremiancard_;
}
inline void MJActionACK::set_currendeskremiancard(::google::protobuf::int32 value) {
  set_has_currendeskremiancard();
  currendeskremiancard_ = value;
}

// required int32 result = 9;
inline bool MJActionACK::has_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MJActionACK::set_has_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MJActionACK::clear_has_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MJActionACK::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 MJActionACK::result() const {
  return result_;
}
inline void MJActionACK::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// MJActionArgs

// required int32 action = 1;
inline bool MJActionArgs::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJActionArgs::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJActionArgs::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJActionArgs::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 MJActionArgs::action() const {
  return action_;
}
inline void MJActionArgs::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// repeated .rpc.MJCard cardsArgs = 3;
inline int MJActionArgs::cardsargs_size() const {
  return cardsargs_.size();
}
inline void MJActionArgs::clear_cardsargs() {
  cardsargs_.Clear();
}
inline const ::rpc::MJCard& MJActionArgs::cardsargs(int index) const {
  return cardsargs_.Get(index);
}
inline ::rpc::MJCard* MJActionArgs::mutable_cardsargs(int index) {
  return cardsargs_.Mutable(index);
}
inline ::rpc::MJCard* MJActionArgs::add_cardsargs() {
  return cardsargs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >&
MJActionArgs::cardsargs() const {
  return cardsargs_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJCard >*
MJActionArgs::mutable_cardsargs() {
  return &cardsargs_;
}

// -------------------------------------------------------------------

// MJActionNotifyACK

// repeated .rpc.MJActionArgs actions = 1;
inline int MJActionNotifyACK::actions_size() const {
  return actions_.size();
}
inline void MJActionNotifyACK::clear_actions() {
  actions_.Clear();
}
inline const ::rpc::MJActionArgs& MJActionNotifyACK::actions(int index) const {
  return actions_.Get(index);
}
inline ::rpc::MJActionArgs* MJActionNotifyACK::mutable_actions(int index) {
  return actions_.Mutable(index);
}
inline ::rpc::MJActionArgs* MJActionNotifyACK::add_actions() {
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJActionArgs >&
MJActionNotifyACK::actions() const {
  return actions_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJActionArgs >*
MJActionNotifyACK::mutable_actions() {
  return &actions_;
}

// -------------------------------------------------------------------

// MJCountdownNotifyACK

// required .rpc.MJCountDown countDown = 1;
inline bool MJCountdownNotifyACK::has_countdown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJCountdownNotifyACK::set_has_countdown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJCountdownNotifyACK::clear_has_countdown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJCountdownNotifyACK::clear_countdown() {
  if (countdown_ != NULL) countdown_->::rpc::MJCountDown::Clear();
  clear_has_countdown();
}
inline const ::rpc::MJCountDown& MJCountdownNotifyACK::countdown() const {
  return countdown_ != NULL ? *countdown_ : *default_instance_->countdown_;
}
inline ::rpc::MJCountDown* MJCountdownNotifyACK::mutable_countdown() {
  set_has_countdown();
  if (countdown_ == NULL) countdown_ = new ::rpc::MJCountDown;
  return countdown_;
}
inline ::rpc::MJCountDown* MJCountdownNotifyACK::release_countdown() {
  clear_has_countdown();
  ::rpc::MJCountDown* temp = countdown_;
  countdown_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// MJRemoveCardNotifyACK

// required string playerID = 1;
inline bool MJRemoveCardNotifyACK::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJRemoveCardNotifyACK::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJRemoveCardNotifyACK::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJRemoveCardNotifyACK::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& MJRemoveCardNotifyACK::playerid() const {
  return *playerid_;
}
inline void MJRemoveCardNotifyACK::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJRemoveCardNotifyACK::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJRemoveCardNotifyACK::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJRemoveCardNotifyACK::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* MJRemoveCardNotifyACK::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isRemoveHandCard = 2;
inline bool MJRemoveCardNotifyACK::has_isremovehandcard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJRemoveCardNotifyACK::set_has_isremovehandcard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJRemoveCardNotifyACK::clear_has_isremovehandcard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJRemoveCardNotifyACK::clear_isremovehandcard() {
  isremovehandcard_ = false;
  clear_has_isremovehandcard();
}
inline bool MJRemoveCardNotifyACK::isremovehandcard() const {
  return isremovehandcard_;
}
inline void MJRemoveCardNotifyACK::set_isremovehandcard(bool value) {
  set_has_isremovehandcard();
  isremovehandcard_ = value;
}

// required .rpc.MJCard card = 3;
inline bool MJRemoveCardNotifyACK::has_card() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJRemoveCardNotifyACK::set_has_card() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJRemoveCardNotifyACK::clear_has_card() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJRemoveCardNotifyACK::clear_card() {
  if (card_ != NULL) card_->::rpc::MJCard::Clear();
  clear_has_card();
}
inline const ::rpc::MJCard& MJRemoveCardNotifyACK::card() const {
  return card_ != NULL ? *card_ : *default_instance_->card_;
}
inline ::rpc::MJCard* MJRemoveCardNotifyACK::mutable_card() {
  set_has_card();
  if (card_ == NULL) card_ = new ::rpc::MJCard;
  return card_;
}
inline ::rpc::MJCard* MJRemoveCardNotifyACK::release_card() {
  clear_has_card();
  ::rpc::MJCard* temp = card_;
  card_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// MJTieGuiREQ

// required bool bTieGui = 1;
inline bool MJTieGuiREQ::has_btiegui() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJTieGuiREQ::set_has_btiegui() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJTieGuiREQ::clear_has_btiegui() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJTieGuiREQ::clear_btiegui() {
  btiegui_ = false;
  clear_has_btiegui();
}
inline bool MJTieGuiREQ::btiegui() const {
  return btiegui_;
}
inline void MJTieGuiREQ::set_btiegui(bool value) {
  set_has_btiegui();
  btiegui_ = value;
}

// required string playerID = 2;
inline bool MJTieGuiREQ::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJTieGuiREQ::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJTieGuiREQ::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJTieGuiREQ::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& MJTieGuiREQ::playerid() const {
  return *playerid_;
}
inline void MJTieGuiREQ::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJTieGuiREQ::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJTieGuiREQ::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJTieGuiREQ::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* MJTieGuiREQ::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 sysType = 6;
inline bool MJTieGuiREQ::has_systype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJTieGuiREQ::set_has_systype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJTieGuiREQ::clear_has_systype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJTieGuiREQ::clear_systype() {
  systype_ = 0;
  clear_has_systype();
}
inline ::google::protobuf::int32 MJTieGuiREQ::systype() const {
  return systype_;
}
inline void MJTieGuiREQ::set_systype(::google::protobuf::int32 value) {
  set_has_systype();
  systype_ = value;
}

// -------------------------------------------------------------------

// MJMingTang

// required int32 mingTang = 1;
inline bool MJMingTang::has_mingtang() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJMingTang::set_has_mingtang() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJMingTang::clear_has_mingtang() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJMingTang::clear_mingtang() {
  mingtang_ = 0;
  clear_has_mingtang();
}
inline ::google::protobuf::int32 MJMingTang::mingtang() const {
  return mingtang_;
}
inline void MJMingTang::set_mingtang(::google::protobuf::int32 value) {
  set_has_mingtang();
  mingtang_ = value;
}

// required int32 value = 2;
inline bool MJMingTang::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJMingTang::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJMingTang::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJMingTang::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 MJMingTang::value() const {
  return value_;
}
inline void MJMingTang::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// MJPlayerJieSuanInfo

// required string playerID = 1;
inline bool MJPlayerJieSuanInfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJPlayerJieSuanInfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJPlayerJieSuanInfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJPlayerJieSuanInfo::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& MJPlayerJieSuanInfo::playerid() const {
  return *playerid_;
}
inline void MJPlayerJieSuanInfo::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJPlayerJieSuanInfo::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void MJPlayerJieSuanInfo::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MJPlayerJieSuanInfo::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* MJPlayerJieSuanInfo::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 coin = 2;
inline bool MJPlayerJieSuanInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJPlayerJieSuanInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJPlayerJieSuanInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJPlayerJieSuanInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 MJPlayerJieSuanInfo::coin() const {
  return coin_;
}
inline void MJPlayerJieSuanInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// repeated .rpc.MJPattern patterns = 6;
inline int MJPlayerJieSuanInfo::patterns_size() const {
  return patterns_.size();
}
inline void MJPlayerJieSuanInfo::clear_patterns() {
  patterns_.Clear();
}
inline const ::rpc::MJPattern& MJPlayerJieSuanInfo::patterns(int index) const {
  return patterns_.Get(index);
}
inline ::rpc::MJPattern* MJPlayerJieSuanInfo::mutable_patterns(int index) {
  return patterns_.Mutable(index);
}
inline ::rpc::MJPattern* MJPlayerJieSuanInfo::add_patterns() {
  return patterns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >&
MJPlayerJieSuanInfo::patterns() const {
  return patterns_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJPattern >*
MJPlayerJieSuanInfo::mutable_patterns() {
  return &patterns_;
}

// repeated .rpc.MJMingTang mingTang = 10;
inline int MJPlayerJieSuanInfo::mingtang_size() const {
  return mingtang_.size();
}
inline void MJPlayerJieSuanInfo::clear_mingtang() {
  mingtang_.Clear();
}
inline const ::rpc::MJMingTang& MJPlayerJieSuanInfo::mingtang(int index) const {
  return mingtang_.Get(index);
}
inline ::rpc::MJMingTang* MJPlayerJieSuanInfo::mutable_mingtang(int index) {
  return mingtang_.Mutable(index);
}
inline ::rpc::MJMingTang* MJPlayerJieSuanInfo::add_mingtang() {
  return mingtang_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJMingTang >&
MJPlayerJieSuanInfo::mingtang() const {
  return mingtang_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJMingTang >*
MJPlayerJieSuanInfo::mutable_mingtang() {
  return &mingtang_;
}

// optional int32 tag = 3;
inline bool MJPlayerJieSuanInfo::has_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MJPlayerJieSuanInfo::set_has_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MJPlayerJieSuanInfo::clear_has_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MJPlayerJieSuanInfo::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 MJPlayerJieSuanInfo::tag() const {
  return tag_;
}
inline void MJPlayerJieSuanInfo::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// -------------------------------------------------------------------

// MJJieSuanNotifyACK

// repeated .rpc.MJPlayerJieSuanInfo playerJieSuanInfo = 3;
inline int MJJieSuanNotifyACK::playerjiesuaninfo_size() const {
  return playerjiesuaninfo_.size();
}
inline void MJJieSuanNotifyACK::clear_playerjiesuaninfo() {
  playerjiesuaninfo_.Clear();
}
inline const ::rpc::MJPlayerJieSuanInfo& MJJieSuanNotifyACK::playerjiesuaninfo(int index) const {
  return playerjiesuaninfo_.Get(index);
}
inline ::rpc::MJPlayerJieSuanInfo* MJJieSuanNotifyACK::mutable_playerjiesuaninfo(int index) {
  return playerjiesuaninfo_.Mutable(index);
}
inline ::rpc::MJPlayerJieSuanInfo* MJJieSuanNotifyACK::add_playerjiesuaninfo() {
  return playerjiesuaninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::MJPlayerJieSuanInfo >&
MJJieSuanNotifyACK::playerjiesuaninfo() const {
  return playerjiesuaninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::MJPlayerJieSuanInfo >*
MJJieSuanNotifyACK::mutable_playerjiesuaninfo() {
  return &playerjiesuaninfo_;
}

// optional bool huangZhuang = 9;
inline bool MJJieSuanNotifyACK::has_huangzhuang() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJJieSuanNotifyACK::set_has_huangzhuang() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJJieSuanNotifyACK::clear_has_huangzhuang() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJJieSuanNotifyACK::clear_huangzhuang() {
  huangzhuang_ = false;
  clear_has_huangzhuang();
}
inline bool MJJieSuanNotifyACK::huangzhuang() const {
  return huangzhuang_;
}
inline void MJJieSuanNotifyACK::set_huangzhuang(bool value) {
  set_has_huangzhuang();
  huangzhuang_ = value;
}

// optional .rpc.JieSuanAdditionData addi = 11;
inline bool MJJieSuanNotifyACK::has_addi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJJieSuanNotifyACK::set_has_addi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJJieSuanNotifyACK::clear_has_addi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJJieSuanNotifyACK::clear_addi() {
  if (addi_ != NULL) addi_->::rpc::JieSuanAdditionData::Clear();
  clear_has_addi();
}
inline const ::rpc::JieSuanAdditionData& MJJieSuanNotifyACK::addi() const {
  return addi_ != NULL ? *addi_ : *default_instance_->addi_;
}
inline ::rpc::JieSuanAdditionData* MJJieSuanNotifyACK::mutable_addi() {
  set_has_addi();
  if (addi_ == NULL) addi_ = new ::rpc::JieSuanAdditionData;
  return addi_;
}
inline ::rpc::JieSuanAdditionData* MJJieSuanNotifyACK::release_addi() {
  clear_has_addi();
  ::rpc::JieSuanAdditionData* temp = addi_;
  addi_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CreateRoomREQ

// required int32 currencyType = 1;
inline bool CreateRoomREQ::has_currencytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomREQ::set_has_currencytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomREQ::clear_has_currencytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomREQ::clear_currencytype() {
  currencytype_ = 0;
  clear_has_currencytype();
}
inline ::google::protobuf::int32 CreateRoomREQ::currencytype() const {
  return currencytype_;
}
inline void CreateRoomREQ::set_currencytype(::google::protobuf::int32 value) {
  set_has_currencytype();
  currencytype_ = value;
}

// required int32 gameType = 2;
inline bool CreateRoomREQ::has_gametype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomREQ::set_has_gametype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomREQ::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomREQ::clear_gametype() {
  gametype_ = 0;
  clear_has_gametype();
}
inline ::google::protobuf::int32 CreateRoomREQ::gametype() const {
  return gametype_;
}
inline void CreateRoomREQ::set_gametype(::google::protobuf::int32 value) {
  set_has_gametype();
  gametype_ = value;
}

// optional int32 difen = 4;
inline bool CreateRoomREQ::has_difen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomREQ::set_has_difen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomREQ::clear_has_difen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomREQ::clear_difen() {
  difen_ = 0;
  clear_has_difen();
}
inline ::google::protobuf::int32 CreateRoomREQ::difen() const {
  return difen_;
}
inline void CreateRoomREQ::set_difen(::google::protobuf::int32 value) {
  set_has_difen();
  difen_ = value;
}

// optional int32 limitCoin = 5;
inline bool CreateRoomREQ::has_limitcoin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateRoomREQ::set_has_limitcoin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateRoomREQ::clear_has_limitcoin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateRoomREQ::clear_limitcoin() {
  limitcoin_ = 0;
  clear_has_limitcoin();
}
inline ::google::protobuf::int32 CreateRoomREQ::limitcoin() const {
  return limitcoin_;
}
inline void CreateRoomREQ::set_limitcoin(::google::protobuf::int32 value) {
  set_has_limitcoin();
  limitcoin_ = value;
}

// optional int32 times = 6;
inline bool CreateRoomREQ::has_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateRoomREQ::set_has_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateRoomREQ::clear_has_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateRoomREQ::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 CreateRoomREQ::times() const {
  return times_;
}
inline void CreateRoomREQ::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// required int32 maxMultiple = 7;
inline bool CreateRoomREQ::has_maxmultiple() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateRoomREQ::set_has_maxmultiple() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateRoomREQ::clear_has_maxmultiple() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateRoomREQ::clear_maxmultiple() {
  maxmultiple_ = 0;
  clear_has_maxmultiple();
}
inline ::google::protobuf::int32 CreateRoomREQ::maxmultiple() const {
  return maxmultiple_;
}
inline void CreateRoomREQ::set_maxmultiple(::google::protobuf::int32 value) {
  set_has_maxmultiple();
  maxmultiple_ = value;
}

// optional bool isDaiGui = 8;
inline bool CreateRoomREQ::has_isdaigui() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateRoomREQ::set_has_isdaigui() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateRoomREQ::clear_has_isdaigui() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateRoomREQ::clear_isdaigui() {
  isdaigui_ = false;
  clear_has_isdaigui();
}
inline bool CreateRoomREQ::isdaigui() const {
  return isdaigui_;
}
inline void CreateRoomREQ::set_isdaigui(bool value) {
  set_has_isdaigui();
  isdaigui_ = value;
}

// optional int32 tiYongAmount = 9;
inline bool CreateRoomREQ::has_tiyongamount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateRoomREQ::set_has_tiyongamount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateRoomREQ::clear_has_tiyongamount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateRoomREQ::clear_tiyongamount() {
  tiyongamount_ = 0;
  clear_has_tiyongamount();
}
inline ::google::protobuf::int32 CreateRoomREQ::tiyongamount() const {
  return tiyongamount_;
}
inline void CreateRoomREQ::set_tiyongamount(::google::protobuf::int32 value) {
  set_has_tiyongamount();
  tiyongamount_ = value;
}

// optional int32 qiHuKeAmount = 10;
inline bool CreateRoomREQ::has_qihukeamount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreateRoomREQ::set_has_qihukeamount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreateRoomREQ::clear_has_qihukeamount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreateRoomREQ::clear_qihukeamount() {
  qihukeamount_ = 0;
  clear_has_qihukeamount();
}
inline ::google::protobuf::int32 CreateRoomREQ::qihukeamount() const {
  return qihukeamount_;
}
inline void CreateRoomREQ::set_qihukeamount(::google::protobuf::int32 value) {
  set_has_qihukeamount();
  qihukeamount_ = value;
}

// -------------------------------------------------------------------

// RoomInfo

// required int32 id = 1;
inline bool RoomInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RoomInfo::id() const {
  return id_;
}
inline void RoomInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 currencyType = 2;
inline bool RoomInfo::has_currencytype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_currencytype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_currencytype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_currencytype() {
  currencytype_ = 0;
  clear_has_currencytype();
}
inline ::google::protobuf::int32 RoomInfo::currencytype() const {
  return currencytype_;
}
inline void RoomInfo::set_currencytype(::google::protobuf::int32 value) {
  set_has_currencytype();
  currencytype_ = value;
}

// required int32 gameType = 3;
inline bool RoomInfo::has_gametype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInfo::set_has_gametype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInfo::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInfo::clear_gametype() {
  gametype_ = 0;
  clear_has_gametype();
}
inline ::google::protobuf::int32 RoomInfo::gametype() const {
  return gametype_;
}
inline void RoomInfo::set_gametype(::google::protobuf::int32 value) {
  set_has_gametype();
  gametype_ = value;
}

// required int32 difen = 4;
inline bool RoomInfo::has_difen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomInfo::set_has_difen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomInfo::clear_has_difen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomInfo::clear_difen() {
  difen_ = 0;
  clear_has_difen();
}
inline ::google::protobuf::int32 RoomInfo::difen() const {
  return difen_;
}
inline void RoomInfo::set_difen(::google::protobuf::int32 value) {
  set_has_difen();
  difen_ = value;
}

// required int32 limitCoin = 5;
inline bool RoomInfo::has_limitcoin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomInfo::set_has_limitcoin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomInfo::clear_has_limitcoin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomInfo::clear_limitcoin() {
  limitcoin_ = 0;
  clear_has_limitcoin();
}
inline ::google::protobuf::int32 RoomInfo::limitcoin() const {
  return limitcoin_;
}
inline void RoomInfo::set_limitcoin(::google::protobuf::int32 value) {
  set_has_limitcoin();
  limitcoin_ = value;
}

// required int32 times = 6;
inline bool RoomInfo::has_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomInfo::set_has_times() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomInfo::clear_has_times() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomInfo::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 RoomInfo::times() const {
  return times_;
}
inline void RoomInfo::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// required int32 maxMultiple = 7;
inline bool RoomInfo::has_maxmultiple() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomInfo::set_has_maxmultiple() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomInfo::clear_has_maxmultiple() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomInfo::clear_maxmultiple() {
  maxmultiple_ = 0;
  clear_has_maxmultiple();
}
inline ::google::protobuf::int32 RoomInfo::maxmultiple() const {
  return maxmultiple_;
}
inline void RoomInfo::set_maxmultiple(::google::protobuf::int32 value) {
  set_has_maxmultiple();
  maxmultiple_ = value;
}

// optional bool isDaiGui = 8;
inline bool RoomInfo::has_isdaigui() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomInfo::set_has_isdaigui() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomInfo::clear_has_isdaigui() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomInfo::clear_isdaigui() {
  isdaigui_ = false;
  clear_has_isdaigui();
}
inline bool RoomInfo::isdaigui() const {
  return isdaigui_;
}
inline void RoomInfo::set_isdaigui(bool value) {
  set_has_isdaigui();
  isdaigui_ = value;
}

// optional int32 tiYongAmount = 9;
inline bool RoomInfo::has_tiyongamount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomInfo::set_has_tiyongamount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomInfo::clear_has_tiyongamount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomInfo::clear_tiyongamount() {
  tiyongamount_ = 0;
  clear_has_tiyongamount();
}
inline ::google::protobuf::int32 RoomInfo::tiyongamount() const {
  return tiyongamount_;
}
inline void RoomInfo::set_tiyongamount(::google::protobuf::int32 value) {
  set_has_tiyongamount();
  tiyongamount_ = value;
}

// optional int32 qiHuKeAmount = 10;
inline bool RoomInfo::has_qihukeamount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoomInfo::set_has_qihukeamount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoomInfo::clear_has_qihukeamount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoomInfo::clear_qihukeamount() {
  qihukeamount_ = 0;
  clear_has_qihukeamount();
}
inline ::google::protobuf::int32 RoomInfo::qihukeamount() const {
  return qihukeamount_;
}
inline void RoomInfo::set_qihukeamount(::google::protobuf::int32 value) {
  set_has_qihukeamount();
  qihukeamount_ = value;
}

// -------------------------------------------------------------------

// CreateRoomACK

// optional .rpc.RoomInfo room = 1;
inline bool CreateRoomACK::has_room() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomACK::set_has_room() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomACK::clear_has_room() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomACK::clear_room() {
  if (room_ != NULL) room_->::rpc::RoomInfo::Clear();
  clear_has_room();
}
inline const ::rpc::RoomInfo& CreateRoomACK::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::rpc::RoomInfo* CreateRoomACK::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::rpc::RoomInfo;
  return room_;
}
inline ::rpc::RoomInfo* CreateRoomACK::release_room() {
  clear_has_room();
  ::rpc::RoomInfo* temp = room_;
  room_ = NULL;
  return temp;
}

// required int32 code = 2;
inline bool CreateRoomACK::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomACK::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomACK::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomACK::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 CreateRoomACK::code() const {
  return code_;
}
inline void CreateRoomACK::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// RoomListREQ

// -------------------------------------------------------------------

// RoomListACK

// repeated .rpc.RoomInfo roomList = 1;
inline int RoomListACK::roomlist_size() const {
  return roomlist_.size();
}
inline void RoomListACK::clear_roomlist() {
  roomlist_.Clear();
}
inline const ::rpc::RoomInfo& RoomListACK::roomlist(int index) const {
  return roomlist_.Get(index);
}
inline ::rpc::RoomInfo* RoomListACK::mutable_roomlist(int index) {
  return roomlist_.Mutable(index);
}
inline ::rpc::RoomInfo* RoomListACK::add_roomlist() {
  return roomlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::RoomInfo >&
RoomListACK::roomlist() const {
  return roomlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::RoomInfo >*
RoomListACK::mutable_roomlist() {
  return &roomlist_;
}

// -------------------------------------------------------------------

// JieSanRoomREQ

// required int32 operatorStatus = 3;
inline bool JieSanRoomREQ::has_operatorstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JieSanRoomREQ::set_has_operatorstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JieSanRoomREQ::clear_has_operatorstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JieSanRoomREQ::clear_operatorstatus() {
  operatorstatus_ = 0;
  clear_has_operatorstatus();
}
inline ::google::protobuf::int32 JieSanRoomREQ::operatorstatus() const {
  return operatorstatus_;
}
inline void JieSanRoomREQ::set_operatorstatus(::google::protobuf::int32 value) {
  set_has_operatorstatus();
  operatorstatus_ = value;
}

// -------------------------------------------------------------------

// JieSanPlayerInfo

// required string playerID = 1;
inline bool JieSanPlayerInfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JieSanPlayerInfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JieSanPlayerInfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JieSanPlayerInfo::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& JieSanPlayerInfo::playerid() const {
  return *playerid_;
}
inline void JieSanPlayerInfo::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void JieSanPlayerInfo::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void JieSanPlayerInfo::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JieSanPlayerInfo::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* JieSanPlayerInfo::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 status = 3;
inline bool JieSanPlayerInfo::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JieSanPlayerInfo::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JieSanPlayerInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JieSanPlayerInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 JieSanPlayerInfo::status() const {
  return status_;
}
inline void JieSanPlayerInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// JieSanRoomNotify

// repeated .rpc.JieSanPlayerInfo jieSanPlayerInfo = 1;
inline int JieSanRoomNotify::jiesanplayerinfo_size() const {
  return jiesanplayerinfo_.size();
}
inline void JieSanRoomNotify::clear_jiesanplayerinfo() {
  jiesanplayerinfo_.Clear();
}
inline const ::rpc::JieSanPlayerInfo& JieSanRoomNotify::jiesanplayerinfo(int index) const {
  return jiesanplayerinfo_.Get(index);
}
inline ::rpc::JieSanPlayerInfo* JieSanRoomNotify::mutable_jiesanplayerinfo(int index) {
  return jiesanplayerinfo_.Mutable(index);
}
inline ::rpc::JieSanPlayerInfo* JieSanRoomNotify::add_jiesanplayerinfo() {
  return jiesanplayerinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::JieSanPlayerInfo >&
JieSanRoomNotify::jiesanplayerinfo() const {
  return jiesanplayerinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::JieSanPlayerInfo >*
JieSanRoomNotify::mutable_jiesanplayerinfo() {
  return &jiesanplayerinfo_;
}

// required int32 remainTime = 3;
inline bool JieSanRoomNotify::has_remaintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JieSanRoomNotify::set_has_remaintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JieSanRoomNotify::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JieSanRoomNotify::clear_remaintime() {
  remaintime_ = 0;
  clear_has_remaintime();
}
inline ::google::protobuf::int32 JieSanRoomNotify::remaintime() const {
  return remaintime_;
}
inline void JieSanRoomNotify::set_remaintime(::google::protobuf::int32 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// -------------------------------------------------------------------

// JieSanRoomUpdateStatusNotify

// required .rpc.JieSanPlayerInfo jieSanPlayerInfo = 1;
inline bool JieSanRoomUpdateStatusNotify::has_jiesanplayerinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JieSanRoomUpdateStatusNotify::set_has_jiesanplayerinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JieSanRoomUpdateStatusNotify::clear_has_jiesanplayerinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JieSanRoomUpdateStatusNotify::clear_jiesanplayerinfo() {
  if (jiesanplayerinfo_ != NULL) jiesanplayerinfo_->::rpc::JieSanPlayerInfo::Clear();
  clear_has_jiesanplayerinfo();
}
inline const ::rpc::JieSanPlayerInfo& JieSanRoomUpdateStatusNotify::jiesanplayerinfo() const {
  return jiesanplayerinfo_ != NULL ? *jiesanplayerinfo_ : *default_instance_->jiesanplayerinfo_;
}
inline ::rpc::JieSanPlayerInfo* JieSanRoomUpdateStatusNotify::mutable_jiesanplayerinfo() {
  set_has_jiesanplayerinfo();
  if (jiesanplayerinfo_ == NULL) jiesanplayerinfo_ = new ::rpc::JieSanPlayerInfo;
  return jiesanplayerinfo_;
}
inline ::rpc::JieSanPlayerInfo* JieSanRoomUpdateStatusNotify::release_jiesanplayerinfo() {
  clear_has_jiesanplayerinfo();
  ::rpc::JieSanPlayerInfo* temp = jiesanplayerinfo_;
  jiesanplayerinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// EnterCustomRoomREQ

// required string gameType = 1;
inline bool EnterCustomRoomREQ::has_gametype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterCustomRoomREQ::set_has_gametype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterCustomRoomREQ::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterCustomRoomREQ::clear_gametype() {
  if (gametype_ != &::google::protobuf::internal::kEmptyString) {
    gametype_->clear();
  }
  clear_has_gametype();
}
inline const ::std::string& EnterCustomRoomREQ::gametype() const {
  return *gametype_;
}
inline void EnterCustomRoomREQ::set_gametype(const ::std::string& value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void EnterCustomRoomREQ::set_gametype(const char* value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void EnterCustomRoomREQ::set_gametype(const char* value, size_t size) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterCustomRoomREQ::mutable_gametype() {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  return gametype_;
}
inline ::std::string* EnterCustomRoomREQ::release_gametype() {
  clear_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gametype_;
    gametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 id = 3;
inline bool EnterCustomRoomREQ::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterCustomRoomREQ::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterCustomRoomREQ::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterCustomRoomREQ::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 EnterCustomRoomREQ::id() const {
  return id_;
}
inline void EnterCustomRoomREQ::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string pwd = 4;
inline bool EnterCustomRoomREQ::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterCustomRoomREQ::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterCustomRoomREQ::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterCustomRoomREQ::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& EnterCustomRoomREQ::pwd() const {
  return *pwd_;
}
inline void EnterCustomRoomREQ::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void EnterCustomRoomREQ::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void EnterCustomRoomREQ::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterCustomRoomREQ::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* EnterCustomRoomREQ::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// EnterCustomRoomACK

// optional .rpc.PlayerBaseInfo playerInfo = 1;
inline bool EnterCustomRoomACK::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterCustomRoomACK::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterCustomRoomACK::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterCustomRoomACK::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::rpc::PlayerBaseInfo::Clear();
  clear_has_playerinfo();
}
inline const ::rpc::PlayerBaseInfo& EnterCustomRoomACK::playerinfo() const {
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance_->playerinfo_;
}
inline ::rpc::PlayerBaseInfo* EnterCustomRoomACK::mutable_playerinfo() {
  set_has_playerinfo();
  if (playerinfo_ == NULL) playerinfo_ = new ::rpc::PlayerBaseInfo;
  return playerinfo_;
}
inline ::rpc::PlayerBaseInfo* EnterCustomRoomACK::release_playerinfo() {
  clear_has_playerinfo();
  ::rpc::PlayerBaseInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}

// optional int32 shangjiaType = 2;
inline bool EnterCustomRoomACK::has_shangjiatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterCustomRoomACK::set_has_shangjiatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterCustomRoomACK::clear_has_shangjiatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterCustomRoomACK::clear_shangjiatype() {
  shangjiatype_ = 0;
  clear_has_shangjiatype();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::shangjiatype() const {
  return shangjiatype_;
}
inline void EnterCustomRoomACK::set_shangjiatype(::google::protobuf::int32 value) {
  set_has_shangjiatype();
  shangjiatype_ = value;
}

// optional int32 location = 20;
inline bool EnterCustomRoomACK::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterCustomRoomACK::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterCustomRoomACK::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterCustomRoomACK::clear_location() {
  location_ = 0;
  clear_has_location();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::location() const {
  return location_;
}
inline void EnterCustomRoomACK::set_location(::google::protobuf::int32 value) {
  set_has_location();
  location_ = value;
}

// optional bool bReady = 3;
inline bool EnterCustomRoomACK::has_bready() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterCustomRoomACK::set_has_bready() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterCustomRoomACK::clear_has_bready() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterCustomRoomACK::clear_bready() {
  bready_ = false;
  clear_has_bready();
}
inline bool EnterCustomRoomACK::bready() const {
  return bready_;
}
inline void EnterCustomRoomACK::set_bready(bool value) {
  set_has_bready();
  bready_ = value;
}

// optional int32 code = 4;
inline bool EnterCustomRoomACK::has_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnterCustomRoomACK::set_has_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnterCustomRoomACK::clear_has_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnterCustomRoomACK::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::code() const {
  return code_;
}
inline void EnterCustomRoomACK::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional int32 roomId = 5;
inline bool EnterCustomRoomACK::has_roomid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EnterCustomRoomACK::set_has_roomid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EnterCustomRoomACK::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EnterCustomRoomACK::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::roomid() const {
  return roomid_;
}
inline void EnterCustomRoomACK::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional int32 gameType = 6;
inline bool EnterCustomRoomACK::has_gametype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EnterCustomRoomACK::set_has_gametype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EnterCustomRoomACK::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EnterCustomRoomACK::clear_gametype() {
  gametype_ = 0;
  clear_has_gametype();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::gametype() const {
  return gametype_;
}
inline void EnterCustomRoomACK::set_gametype(::google::protobuf::int32 value) {
  set_has_gametype();
  gametype_ = value;
}

// optional int32 times = 7;
inline bool EnterCustomRoomACK::has_times() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EnterCustomRoomACK::set_has_times() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EnterCustomRoomACK::clear_has_times() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EnterCustomRoomACK::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::times() const {
  return times_;
}
inline void EnterCustomRoomACK::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional int32 curTimes = 8;
inline bool EnterCustomRoomACK::has_curtimes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EnterCustomRoomACK::set_has_curtimes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EnterCustomRoomACK::clear_has_curtimes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EnterCustomRoomACK::clear_curtimes() {
  curtimes_ = 0;
  clear_has_curtimes();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::curtimes() const {
  return curtimes_;
}
inline void EnterCustomRoomACK::set_curtimes(::google::protobuf::int32 value) {
  set_has_curtimes();
  curtimes_ = value;
}

// optional bool isOwner = 9;
inline bool EnterCustomRoomACK::has_isowner() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EnterCustomRoomACK::set_has_isowner() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EnterCustomRoomACK::clear_has_isowner() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EnterCustomRoomACK::clear_isowner() {
  isowner_ = false;
  clear_has_isowner();
}
inline bool EnterCustomRoomACK::isowner() const {
  return isowner_;
}
inline void EnterCustomRoomACK::set_isowner(bool value) {
  set_has_isowner();
  isowner_ = value;
}

// optional int32 currencyType = 10;
inline bool EnterCustomRoomACK::has_currencytype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EnterCustomRoomACK::set_has_currencytype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EnterCustomRoomACK::clear_has_currencytype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EnterCustomRoomACK::clear_currencytype() {
  currencytype_ = 0;
  clear_has_currencytype();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::currencytype() const {
  return currencytype_;
}
inline void EnterCustomRoomACK::set_currencytype(::google::protobuf::int32 value) {
  set_has_currencytype();
  currencytype_ = value;
}

// optional int32 difen = 11;
inline bool EnterCustomRoomACK::has_difen() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EnterCustomRoomACK::set_has_difen() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EnterCustomRoomACK::clear_has_difen() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EnterCustomRoomACK::clear_difen() {
  difen_ = 0;
  clear_has_difen();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::difen() const {
  return difen_;
}
inline void EnterCustomRoomACK::set_difen(::google::protobuf::int32 value) {
  set_has_difen();
  difen_ = value;
}

// optional int32 qiHuKeAmount = 12;
inline bool EnterCustomRoomACK::has_qihukeamount() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EnterCustomRoomACK::set_has_qihukeamount() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EnterCustomRoomACK::clear_has_qihukeamount() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EnterCustomRoomACK::clear_qihukeamount() {
  qihukeamount_ = 0;
  clear_has_qihukeamount();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::qihukeamount() const {
  return qihukeamount_;
}
inline void EnterCustomRoomACK::set_qihukeamount(::google::protobuf::int32 value) {
  set_has_qihukeamount();
  qihukeamount_ = value;
}

// optional int32 tiYongAmount = 13;
inline bool EnterCustomRoomACK::has_tiyongamount() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EnterCustomRoomACK::set_has_tiyongamount() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EnterCustomRoomACK::clear_has_tiyongamount() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EnterCustomRoomACK::clear_tiyongamount() {
  tiyongamount_ = 0;
  clear_has_tiyongamount();
}
inline ::google::protobuf::int32 EnterCustomRoomACK::tiyongamount() const {
  return tiyongamount_;
}
inline void EnterCustomRoomACK::set_tiyongamount(::google::protobuf::int32 value) {
  set_has_tiyongamount();
  tiyongamount_ = value;
}

// -------------------------------------------------------------------

// LeaveCustomRoomREQ

// required string playerID = 1;
inline bool LeaveCustomRoomREQ::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveCustomRoomREQ::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveCustomRoomREQ::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveCustomRoomREQ::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& LeaveCustomRoomREQ::playerid() const {
  return *playerid_;
}
inline void LeaveCustomRoomREQ::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void LeaveCustomRoomREQ::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void LeaveCustomRoomREQ::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaveCustomRoomREQ::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* LeaveCustomRoomREQ::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LeaveCustomRoomACK

// required string playerID = 1;
inline bool LeaveCustomRoomACK::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveCustomRoomACK::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveCustomRoomACK::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveCustomRoomACK::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& LeaveCustomRoomACK::playerid() const {
  return *playerid_;
}
inline void LeaveCustomRoomACK::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void LeaveCustomRoomACK::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void LeaveCustomRoomACK::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaveCustomRoomACK::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* LeaveCustomRoomACK::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FindRoomREQ

// optional int32 id = 1;
inline bool FindRoomREQ::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindRoomREQ::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindRoomREQ::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindRoomREQ::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 FindRoomREQ::id() const {
  return id_;
}
inline void FindRoomREQ::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool FindRoomREQ::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindRoomREQ::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindRoomREQ::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindRoomREQ::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FindRoomREQ::name() const {
  return *name_;
}
inline void FindRoomREQ::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FindRoomREQ::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FindRoomREQ::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindRoomREQ::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FindRoomREQ::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FindRoomACK

// optional .rpc.RoomInfo room = 1;
inline bool FindRoomACK::has_room() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindRoomACK::set_has_room() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindRoomACK::clear_has_room() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindRoomACK::clear_room() {
  if (room_ != NULL) room_->::rpc::RoomInfo::Clear();
  clear_has_room();
}
inline const ::rpc::RoomInfo& FindRoomACK::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::rpc::RoomInfo* FindRoomACK::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::rpc::RoomInfo;
  return room_;
}
inline ::rpc::RoomInfo* FindRoomACK::release_room() {
  clear_has_room();
  ::rpc::RoomInfo* temp = room_;
  room_ = NULL;
  return temp;
}

// required int32 code = 2;
inline bool FindRoomACK::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindRoomACK::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindRoomACK::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindRoomACK::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 FindRoomACK::code() const {
  return code_;
}
inline void FindRoomACK::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// ForceLeaveRoomREQ

// required string id = 1;
inline bool ForceLeaveRoomREQ::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForceLeaveRoomREQ::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForceLeaveRoomREQ::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForceLeaveRoomREQ::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ForceLeaveRoomREQ::id() const {
  return *id_;
}
inline void ForceLeaveRoomREQ::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ForceLeaveRoomREQ::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ForceLeaveRoomREQ::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForceLeaveRoomREQ::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ForceLeaveRoomREQ::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 sysType = 2;
inline bool ForceLeaveRoomREQ::has_systype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForceLeaveRoomREQ::set_has_systype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForceLeaveRoomREQ::clear_has_systype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForceLeaveRoomREQ::clear_systype() {
  systype_ = 0;
  clear_has_systype();
}
inline ::google::protobuf::int32 ForceLeaveRoomREQ::systype() const {
  return systype_;
}
inline void ForceLeaveRoomREQ::set_systype(::google::protobuf::int32 value) {
  set_has_systype();
  systype_ = value;
}

// required int32 gameType = 3;
inline bool ForceLeaveRoomREQ::has_gametype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ForceLeaveRoomREQ::set_has_gametype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ForceLeaveRoomREQ::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ForceLeaveRoomREQ::clear_gametype() {
  gametype_ = 0;
  clear_has_gametype();
}
inline ::google::protobuf::int32 ForceLeaveRoomREQ::gametype() const {
  return gametype_;
}
inline void ForceLeaveRoomREQ::set_gametype(::google::protobuf::int32 value) {
  set_has_gametype();
  gametype_ = value;
}

// -------------------------------------------------------------------

// InviteFirendsJionCustomRoomREQ

// repeated string playerID = 1;
inline int InviteFirendsJionCustomRoomREQ::playerid_size() const {
  return playerid_.size();
}
inline void InviteFirendsJionCustomRoomREQ::clear_playerid() {
  playerid_.Clear();
}
inline const ::std::string& InviteFirendsJionCustomRoomREQ::playerid(int index) const {
  return playerid_.Get(index);
}
inline ::std::string* InviteFirendsJionCustomRoomREQ::mutable_playerid(int index) {
  return playerid_.Mutable(index);
}
inline void InviteFirendsJionCustomRoomREQ::set_playerid(int index, const ::std::string& value) {
  playerid_.Mutable(index)->assign(value);
}
inline void InviteFirendsJionCustomRoomREQ::set_playerid(int index, const char* value) {
  playerid_.Mutable(index)->assign(value);
}
inline void InviteFirendsJionCustomRoomREQ::set_playerid(int index, const char* value, size_t size) {
  playerid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteFirendsJionCustomRoomREQ::add_playerid() {
  return playerid_.Add();
}
inline void InviteFirendsJionCustomRoomREQ::add_playerid(const ::std::string& value) {
  playerid_.Add()->assign(value);
}
inline void InviteFirendsJionCustomRoomREQ::add_playerid(const char* value) {
  playerid_.Add()->assign(value);
}
inline void InviteFirendsJionCustomRoomREQ::add_playerid(const char* value, size_t size) {
  playerid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InviteFirendsJionCustomRoomREQ::playerid() const {
  return playerid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InviteFirendsJionCustomRoomREQ::mutable_playerid() {
  return &playerid_;
}

// optional int32 currencyType = 2;
inline bool InviteFirendsJionCustomRoomREQ::has_currencytype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteFirendsJionCustomRoomREQ::set_has_currencytype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteFirendsJionCustomRoomREQ::clear_has_currencytype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteFirendsJionCustomRoomREQ::clear_currencytype() {
  currencytype_ = 0;
  clear_has_currencytype();
}
inline ::google::protobuf::int32 InviteFirendsJionCustomRoomREQ::currencytype() const {
  return currencytype_;
}
inline void InviteFirendsJionCustomRoomREQ::set_currencytype(::google::protobuf::int32 value) {
  set_has_currencytype();
  currencytype_ = value;
}

// -------------------------------------------------------------------

// InviteFirendsJionCustomRoomNotify

// optional int32 code = 1;
inline bool InviteFirendsJionCustomRoomNotify::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteFirendsJionCustomRoomNotify::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 InviteFirendsJionCustomRoomNotify::code() const {
  return code_;
}
inline void InviteFirendsJionCustomRoomNotify::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string gameType = 2;
inline bool InviteFirendsJionCustomRoomNotify::has_gametype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteFirendsJionCustomRoomNotify::set_has_gametype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_has_gametype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_gametype() {
  if (gametype_ != &::google::protobuf::internal::kEmptyString) {
    gametype_->clear();
  }
  clear_has_gametype();
}
inline const ::std::string& InviteFirendsJionCustomRoomNotify::gametype() const {
  return *gametype_;
}
inline void InviteFirendsJionCustomRoomNotify::set_gametype(const ::std::string& value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void InviteFirendsJionCustomRoomNotify::set_gametype(const char* value) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(value);
}
inline void InviteFirendsJionCustomRoomNotify::set_gametype(const char* value, size_t size) {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  gametype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteFirendsJionCustomRoomNotify::mutable_gametype() {
  set_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    gametype_ = new ::std::string;
  }
  return gametype_;
}
inline ::std::string* InviteFirendsJionCustomRoomNotify::release_gametype() {
  clear_has_gametype();
  if (gametype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gametype_;
    gametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 roomID = 3;
inline bool InviteFirendsJionCustomRoomNotify::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteFirendsJionCustomRoomNotify::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 InviteFirendsJionCustomRoomNotify::roomid() const {
  return roomid_;
}
inline void InviteFirendsJionCustomRoomNotify::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional string invitePlayerName = 4;
inline bool InviteFirendsJionCustomRoomNotify::has_inviteplayername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InviteFirendsJionCustomRoomNotify::set_has_inviteplayername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_has_inviteplayername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_inviteplayername() {
  if (inviteplayername_ != &::google::protobuf::internal::kEmptyString) {
    inviteplayername_->clear();
  }
  clear_has_inviteplayername();
}
inline const ::std::string& InviteFirendsJionCustomRoomNotify::inviteplayername() const {
  return *inviteplayername_;
}
inline void InviteFirendsJionCustomRoomNotify::set_inviteplayername(const ::std::string& value) {
  set_has_inviteplayername();
  if (inviteplayername_ == &::google::protobuf::internal::kEmptyString) {
    inviteplayername_ = new ::std::string;
  }
  inviteplayername_->assign(value);
}
inline void InviteFirendsJionCustomRoomNotify::set_inviteplayername(const char* value) {
  set_has_inviteplayername();
  if (inviteplayername_ == &::google::protobuf::internal::kEmptyString) {
    inviteplayername_ = new ::std::string;
  }
  inviteplayername_->assign(value);
}
inline void InviteFirendsJionCustomRoomNotify::set_inviteplayername(const char* value, size_t size) {
  set_has_inviteplayername();
  if (inviteplayername_ == &::google::protobuf::internal::kEmptyString) {
    inviteplayername_ = new ::std::string;
  }
  inviteplayername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteFirendsJionCustomRoomNotify::mutable_inviteplayername() {
  set_has_inviteplayername();
  if (inviteplayername_ == &::google::protobuf::internal::kEmptyString) {
    inviteplayername_ = new ::std::string;
  }
  return inviteplayername_;
}
inline ::std::string* InviteFirendsJionCustomRoomNotify::release_inviteplayername() {
  clear_has_inviteplayername();
  if (inviteplayername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inviteplayername_;
    inviteplayername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 currencyType = 5;
inline bool InviteFirendsJionCustomRoomNotify::has_currencytype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InviteFirendsJionCustomRoomNotify::set_has_currencytype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_has_currencytype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InviteFirendsJionCustomRoomNotify::clear_currencytype() {
  currencytype_ = 0;
  clear_has_currencytype();
}
inline ::google::protobuf::int32 InviteFirendsJionCustomRoomNotify::currencytype() const {
  return currencytype_;
}
inline void InviteFirendsJionCustomRoomNotify::set_currencytype(::google::protobuf::int32 value) {
  set_has_currencytype();
  currencytype_ = value;
}

// -------------------------------------------------------------------

// OtherPlayerInfo

// required int32 userID = 1;
inline bool OtherPlayerInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtherPlayerInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtherPlayerInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtherPlayerInfo::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 OtherPlayerInfo::userid() const {
  return userid_;
}
inline void OtherPlayerInfo::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// required int32 userName = 2;
inline bool OtherPlayerInfo::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtherPlayerInfo::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtherPlayerInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtherPlayerInfo::clear_username() {
  username_ = 0;
  clear_has_username();
}
inline ::google::protobuf::int32 OtherPlayerInfo::username() const {
  return username_;
}
inline void OtherPlayerInfo::set_username(::google::protobuf::int32 value) {
  set_has_username();
  username_ = value;
}

// optional int32 userHeadID = 3;
inline bool OtherPlayerInfo::has_userheadid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OtherPlayerInfo::set_has_userheadid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OtherPlayerInfo::clear_has_userheadid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OtherPlayerInfo::clear_userheadid() {
  userheadid_ = 0;
  clear_has_userheadid();
}
inline ::google::protobuf::int32 OtherPlayerInfo::userheadid() const {
  return userheadid_;
}
inline void OtherPlayerInfo::set_userheadid(::google::protobuf::int32 value) {
  set_has_userheadid();
  userheadid_ = value;
}

// optional int32 userwechatHeadURL = 4;
inline bool OtherPlayerInfo::has_userwechatheadurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OtherPlayerInfo::set_has_userwechatheadurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OtherPlayerInfo::clear_has_userwechatheadurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OtherPlayerInfo::clear_userwechatheadurl() {
  userwechatheadurl_ = 0;
  clear_has_userwechatheadurl();
}
inline ::google::protobuf::int32 OtherPlayerInfo::userwechatheadurl() const {
  return userwechatheadurl_;
}
inline void OtherPlayerInfo::set_userwechatheadurl(::google::protobuf::int32 value) {
  set_has_userwechatheadurl();
  userwechatheadurl_ = value;
}

// optional int32 winNum = 5;
inline bool OtherPlayerInfo::has_winnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OtherPlayerInfo::set_has_winnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OtherPlayerInfo::clear_has_winnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OtherPlayerInfo::clear_winnum() {
  winnum_ = 0;
  clear_has_winnum();
}
inline ::google::protobuf::int32 OtherPlayerInfo::winnum() const {
  return winnum_;
}
inline void OtherPlayerInfo::set_winnum(::google::protobuf::int32 value) {
  set_has_winnum();
  winnum_ = value;
}

// optional int32 loseNum = 6;
inline bool OtherPlayerInfo::has_losenum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OtherPlayerInfo::set_has_losenum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OtherPlayerInfo::clear_has_losenum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OtherPlayerInfo::clear_losenum() {
  losenum_ = 0;
  clear_has_losenum();
}
inline ::google::protobuf::int32 OtherPlayerInfo::losenum() const {
  return losenum_;
}
inline void OtherPlayerInfo::set_losenum(::google::protobuf::int32 value) {
  set_has_losenum();
  losenum_ = value;
}

// optional int32 lv = 7;
inline bool OtherPlayerInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OtherPlayerInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OtherPlayerInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OtherPlayerInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 OtherPlayerInfo::lv() const {
  return lv_;
}
inline void OtherPlayerInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 coin = 8;
inline bool OtherPlayerInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OtherPlayerInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OtherPlayerInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OtherPlayerInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 OtherPlayerInfo::coin() const {
  return coin_;
}
inline void OtherPlayerInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// -------------------------------------------------------------------

// OtherPlayerInfoREQ

// required string playerID = 1;
inline bool OtherPlayerInfoREQ::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtherPlayerInfoREQ::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtherPlayerInfoREQ::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtherPlayerInfoREQ::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& OtherPlayerInfoREQ::playerid() const {
  return *playerid_;
}
inline void OtherPlayerInfoREQ::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OtherPlayerInfoREQ::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OtherPlayerInfoREQ::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OtherPlayerInfoREQ::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* OtherPlayerInfoREQ::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MatchListREQ

// -------------------------------------------------------------------

// MatchListACK

// repeated .rpc.Match matches = 1;
inline int MatchListACK::matches_size() const {
  return matches_.size();
}
inline void MatchListACK::clear_matches() {
  matches_.Clear();
}
inline const ::rpc::Match& MatchListACK::matches(int index) const {
  return matches_.Get(index);
}
inline ::rpc::Match* MatchListACK::mutable_matches(int index) {
  return matches_.Mutable(index);
}
inline ::rpc::Match* MatchListACK::add_matches() {
  return matches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Match >&
MatchListACK::matches() const {
  return matches_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Match >*
MatchListACK::mutable_matches() {
  return &matches_;
}

// -------------------------------------------------------------------

// Match

// required int32 id = 1;
inline bool Match::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Match::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Match::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Match::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Match::id() const {
  return id_;
}
inline void Match::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 enrollAmount = 2;
inline bool Match::has_enrollamount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Match::set_has_enrollamount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Match::clear_has_enrollamount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Match::clear_enrollamount() {
  enrollamount_ = 0;
  clear_has_enrollamount();
}
inline ::google::protobuf::int32 Match::enrollamount() const {
  return enrollamount_;
}
inline void Match::set_enrollamount(::google::protobuf::int32 value) {
  set_has_enrollamount();
  enrollamount_ = value;
}

// optional int64 countdown = 3;
inline bool Match::has_countdown() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Match::set_has_countdown() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Match::clear_has_countdown() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Match::clear_countdown() {
  countdown_ = GOOGLE_LONGLONG(0);
  clear_has_countdown();
}
inline ::google::protobuf::int64 Match::countdown() const {
  return countdown_;
}
inline void Match::set_countdown(::google::protobuf::int64 value) {
  set_has_countdown();
  countdown_ = value;
}

// -------------------------------------------------------------------

// EnrollREQ

// required int32 id = 1;
inline bool EnrollREQ::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnrollREQ::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnrollREQ::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnrollREQ::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 EnrollREQ::id() const {
  return id_;
}
inline void EnrollREQ::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// EnrollACK

// required int32 result = 1;
inline bool EnrollACK::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnrollACK::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnrollACK::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnrollACK::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 EnrollACK::result() const {
  return result_;
}
inline void EnrollACK::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// WithdrawREQ

// required int32 id = 1;
inline bool WithdrawREQ::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WithdrawREQ::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WithdrawREQ::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WithdrawREQ::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 WithdrawREQ::id() const {
  return id_;
}
inline void WithdrawREQ::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// WithdrawACK

// required int32 result = 1;
inline bool WithdrawACK::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WithdrawACK::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WithdrawACK::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WithdrawACK::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 WithdrawACK::result() const {
  return result_;
}
inline void WithdrawACK::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// AmountChangeNotifyACK

// repeated .rpc.Match matches = 1;
inline int AmountChangeNotifyACK::matches_size() const {
  return matches_.size();
}
inline void AmountChangeNotifyACK::clear_matches() {
  matches_.Clear();
}
inline const ::rpc::Match& AmountChangeNotifyACK::matches(int index) const {
  return matches_.Get(index);
}
inline ::rpc::Match* AmountChangeNotifyACK::mutable_matches(int index) {
  return matches_.Mutable(index);
}
inline ::rpc::Match* AmountChangeNotifyACK::add_matches() {
  return matches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Match >&
AmountChangeNotifyACK::matches() const {
  return matches_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Match >*
AmountChangeNotifyACK::mutable_matches() {
  return &matches_;
}

// -------------------------------------------------------------------

// StartEntranceACK

// required .rpc.Match match = 1;
inline bool StartEntranceACK::has_match() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartEntranceACK::set_has_match() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartEntranceACK::clear_has_match() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartEntranceACK::clear_match() {
  if (match_ != NULL) match_->::rpc::Match::Clear();
  clear_has_match();
}
inline const ::rpc::Match& StartEntranceACK::match() const {
  return match_ != NULL ? *match_ : *default_instance_->match_;
}
inline ::rpc::Match* StartEntranceACK::mutable_match() {
  set_has_match();
  if (match_ == NULL) match_ = new ::rpc::Match;
  return match_;
}
inline ::rpc::Match* StartEntranceACK::release_match() {
  clear_has_match();
  ::rpc::Match* temp = match_;
  match_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// OrderInfoNofity

// optional string partnerId = 1;
inline bool OrderInfoNofity::has_partnerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderInfoNofity::set_has_partnerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderInfoNofity::clear_has_partnerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderInfoNofity::clear_partnerid() {
  if (partnerid_ != &::google::protobuf::internal::kEmptyString) {
    partnerid_->clear();
  }
  clear_has_partnerid();
}
inline const ::std::string& OrderInfoNofity::partnerid() const {
  return *partnerid_;
}
inline void OrderInfoNofity::set_partnerid(const ::std::string& value) {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  partnerid_->assign(value);
}
inline void OrderInfoNofity::set_partnerid(const char* value) {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  partnerid_->assign(value);
}
inline void OrderInfoNofity::set_partnerid(const char* value, size_t size) {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  partnerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderInfoNofity::mutable_partnerid() {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  return partnerid_;
}
inline ::std::string* OrderInfoNofity::release_partnerid() {
  clear_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partnerid_;
    partnerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string prepayId = 2;
inline bool OrderInfoNofity::has_prepayid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderInfoNofity::set_has_prepayid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderInfoNofity::clear_has_prepayid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderInfoNofity::clear_prepayid() {
  if (prepayid_ != &::google::protobuf::internal::kEmptyString) {
    prepayid_->clear();
  }
  clear_has_prepayid();
}
inline const ::std::string& OrderInfoNofity::prepayid() const {
  return *prepayid_;
}
inline void OrderInfoNofity::set_prepayid(const ::std::string& value) {
  set_has_prepayid();
  if (prepayid_ == &::google::protobuf::internal::kEmptyString) {
    prepayid_ = new ::std::string;
  }
  prepayid_->assign(value);
}
inline void OrderInfoNofity::set_prepayid(const char* value) {
  set_has_prepayid();
  if (prepayid_ == &::google::protobuf::internal::kEmptyString) {
    prepayid_ = new ::std::string;
  }
  prepayid_->assign(value);
}
inline void OrderInfoNofity::set_prepayid(const char* value, size_t size) {
  set_has_prepayid();
  if (prepayid_ == &::google::protobuf::internal::kEmptyString) {
    prepayid_ = new ::std::string;
  }
  prepayid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderInfoNofity::mutable_prepayid() {
  set_has_prepayid();
  if (prepayid_ == &::google::protobuf::internal::kEmptyString) {
    prepayid_ = new ::std::string;
  }
  return prepayid_;
}
inline ::std::string* OrderInfoNofity::release_prepayid() {
  clear_has_prepayid();
  if (prepayid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prepayid_;
    prepayid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string package = 3;
inline bool OrderInfoNofity::has_package() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderInfoNofity::set_has_package() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderInfoNofity::clear_has_package() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderInfoNofity::clear_package() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& OrderInfoNofity::package() const {
  return *package_;
}
inline void OrderInfoNofity::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void OrderInfoNofity::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void OrderInfoNofity::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderInfoNofity::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* OrderInfoNofity::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nonceStr = 4;
inline bool OrderInfoNofity::has_noncestr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderInfoNofity::set_has_noncestr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderInfoNofity::clear_has_noncestr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderInfoNofity::clear_noncestr() {
  if (noncestr_ != &::google::protobuf::internal::kEmptyString) {
    noncestr_->clear();
  }
  clear_has_noncestr();
}
inline const ::std::string& OrderInfoNofity::noncestr() const {
  return *noncestr_;
}
inline void OrderInfoNofity::set_noncestr(const ::std::string& value) {
  set_has_noncestr();
  if (noncestr_ == &::google::protobuf::internal::kEmptyString) {
    noncestr_ = new ::std::string;
  }
  noncestr_->assign(value);
}
inline void OrderInfoNofity::set_noncestr(const char* value) {
  set_has_noncestr();
  if (noncestr_ == &::google::protobuf::internal::kEmptyString) {
    noncestr_ = new ::std::string;
  }
  noncestr_->assign(value);
}
inline void OrderInfoNofity::set_noncestr(const char* value, size_t size) {
  set_has_noncestr();
  if (noncestr_ == &::google::protobuf::internal::kEmptyString) {
    noncestr_ = new ::std::string;
  }
  noncestr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderInfoNofity::mutable_noncestr() {
  set_has_noncestr();
  if (noncestr_ == &::google::protobuf::internal::kEmptyString) {
    noncestr_ = new ::std::string;
  }
  return noncestr_;
}
inline ::std::string* OrderInfoNofity::release_noncestr() {
  clear_has_noncestr();
  if (noncestr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = noncestr_;
    noncestr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 timeStamp = 5;
inline bool OrderInfoNofity::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderInfoNofity::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderInfoNofity::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderInfoNofity::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 OrderInfoNofity::timestamp() const {
  return timestamp_;
}
inline void OrderInfoNofity::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string sign = 6;
inline bool OrderInfoNofity::has_sign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderInfoNofity::set_has_sign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderInfoNofity::clear_has_sign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderInfoNofity::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& OrderInfoNofity::sign() const {
  return *sign_;
}
inline void OrderInfoNofity::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void OrderInfoNofity::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void OrderInfoNofity::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderInfoNofity::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* OrderInfoNofity::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string appId = 7;
inline bool OrderInfoNofity::has_appid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderInfoNofity::set_has_appid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderInfoNofity::clear_has_appid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderInfoNofity::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& OrderInfoNofity::appid() const {
  return *appid_;
}
inline void OrderInfoNofity::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void OrderInfoNofity::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void OrderInfoNofity::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderInfoNofity::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* OrderInfoNofity::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PayResultNotify

// optional string partnerId = 1;
inline bool PayResultNotify::has_partnerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayResultNotify::set_has_partnerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayResultNotify::clear_has_partnerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayResultNotify::clear_partnerid() {
  if (partnerid_ != &::google::protobuf::internal::kEmptyString) {
    partnerid_->clear();
  }
  clear_has_partnerid();
}
inline const ::std::string& PayResultNotify::partnerid() const {
  return *partnerid_;
}
inline void PayResultNotify::set_partnerid(const ::std::string& value) {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  partnerid_->assign(value);
}
inline void PayResultNotify::set_partnerid(const char* value) {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  partnerid_->assign(value);
}
inline void PayResultNotify::set_partnerid(const char* value, size_t size) {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  partnerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayResultNotify::mutable_partnerid() {
  set_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    partnerid_ = new ::std::string;
  }
  return partnerid_;
}
inline ::std::string* PayResultNotify::release_partnerid() {
  clear_has_partnerid();
  if (partnerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partnerid_;
    partnerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool result = 2;
inline bool PayResultNotify::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayResultNotify::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayResultNotify::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayResultNotify::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool PayResultNotify::result() const {
  return result_;
}
inline void PayResultNotify::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional string error_desc = 3;
inline bool PayResultNotify::has_error_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayResultNotify::set_has_error_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayResultNotify::clear_has_error_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayResultNotify::clear_error_desc() {
  if (error_desc_ != &::google::protobuf::internal::kEmptyString) {
    error_desc_->clear();
  }
  clear_has_error_desc();
}
inline const ::std::string& PayResultNotify::error_desc() const {
  return *error_desc_;
}
inline void PayResultNotify::set_error_desc(const ::std::string& value) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(value);
}
inline void PayResultNotify::set_error_desc(const char* value) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(value);
}
inline void PayResultNotify::set_error_desc(const char* value, size_t size) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayResultNotify::mutable_error_desc() {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  return error_desc_;
}
inline ::std::string* PayResultNotify::release_error_desc() {
  clear_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_desc_;
    error_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 vipDay = 4;
inline bool PayResultNotify::has_vipday() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayResultNotify::set_has_vipday() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayResultNotify::clear_has_vipday() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayResultNotify::clear_vipday() {
  vipday_ = 0;
  clear_has_vipday();
}
inline ::google::protobuf::int32 PayResultNotify::vipday() const {
  return vipday_;
}
inline void PayResultNotify::set_vipday(::google::protobuf::int32 value) {
  set_has_vipday();
  vipday_ = value;
}

// -------------------------------------------------------------------

// PokerQuickEnterRoomREQ

// -------------------------------------------------------------------

// CreatePockerRoomReq

// optional string uid = 1;
inline bool CreatePockerRoomReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePockerRoomReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePockerRoomReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePockerRoomReq::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CreatePockerRoomReq::uid() const {
  return *uid_;
}
inline void CreatePockerRoomReq::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CreatePockerRoomReq::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CreatePockerRoomReq::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreatePockerRoomReq::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CreatePockerRoomReq::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 BlindId = 2;
inline bool CreatePockerRoomReq::has_blindid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreatePockerRoomReq::set_has_blindid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreatePockerRoomReq::clear_has_blindid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreatePockerRoomReq::clear_blindid() {
  blindid_ = 0;
  clear_has_blindid();
}
inline ::google::protobuf::int32 CreatePockerRoomReq::blindid() const {
  return blindid_;
}
inline void CreatePockerRoomReq::set_blindid(::google::protobuf::int32 value) {
  set_has_blindid();
  blindid_ = value;
}

// optional int32 LimId = 3;
inline bool CreatePockerRoomReq::has_limid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreatePockerRoomReq::set_has_limid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreatePockerRoomReq::clear_has_limid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreatePockerRoomReq::clear_limid() {
  limid_ = 0;
  clear_has_limid();
}
inline ::google::protobuf::int32 CreatePockerRoomReq::limid() const {
  return limid_;
}
inline void CreatePockerRoomReq::set_limid(::google::protobuf::int32 value) {
  set_has_limid();
  limid_ = value;
}

// -------------------------------------------------------------------

// CreatePockerRoomAck

// optional int32 roomNo = 1;
inline bool CreatePockerRoomAck::has_roomno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePockerRoomAck::set_has_roomno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePockerRoomAck::clear_has_roomno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePockerRoomAck::clear_roomno() {
  roomno_ = 0;
  clear_has_roomno();
}
inline ::google::protobuf::int32 CreatePockerRoomAck::roomno() const {
  return roomno_;
}
inline void CreatePockerRoomAck::set_roomno(::google::protobuf::int32 value) {
  set_has_roomno();
  roomno_ = value;
}

// -------------------------------------------------------------------

// C2SAction

// optional int32 act = 1;
inline bool C2SAction::has_act() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2SAction::set_has_act() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2SAction::clear_has_act() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2SAction::clear_act() {
  act_ = 0;
  clear_has_act();
}
inline ::google::protobuf::int32 C2SAction::act() const {
  return act_;
}
inline void C2SAction::set_act(::google::protobuf::int32 value) {
  set_has_act();
  act_ = value;
}

// optional string uid = 2;
inline bool C2SAction::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2SAction::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2SAction::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2SAction::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& C2SAction::uid() const {
  return *uid_;
}
inline void C2SAction::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void C2SAction::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void C2SAction::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2SAction::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* C2SAction::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 raise = 3;
inline bool C2SAction::has_raise() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2SAction::set_has_raise() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2SAction::clear_has_raise() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2SAction::clear_raise() {
  raise_ = 0;
  clear_has_raise();
}
inline ::google::protobuf::int32 C2SAction::raise() const {
  return raise_;
}
inline void C2SAction::set_raise(::google::protobuf::int32 value) {
  set_has_raise();
  raise_ = value;
}

// optional .rpc.PlayerBaseInfo base = 4;
inline bool C2SAction::has_base() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void C2SAction::set_has_base() {
  _has_bits_[0] |= 0x00000008u;
}
inline void C2SAction::clear_has_base() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void C2SAction::clear_base() {
  if (base_ != NULL) base_->::rpc::PlayerBaseInfo::Clear();
  clear_has_base();
}
inline const ::rpc::PlayerBaseInfo& C2SAction::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::rpc::PlayerBaseInfo* C2SAction::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::rpc::PlayerBaseInfo;
  return base_;
}
inline ::rpc::PlayerBaseInfo* C2SAction::release_base() {
  clear_has_base();
  ::rpc::PlayerBaseInfo* temp = base_;
  base_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// S2CAction

// optional string operater = 1;
inline bool S2CAction::has_operater() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2CAction::set_has_operater() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2CAction::clear_has_operater() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2CAction::clear_operater() {
  if (operater_ != &::google::protobuf::internal::kEmptyString) {
    operater_->clear();
  }
  clear_has_operater();
}
inline const ::std::string& S2CAction::operater() const {
  return *operater_;
}
inline void S2CAction::set_operater(const ::std::string& value) {
  set_has_operater();
  if (operater_ == &::google::protobuf::internal::kEmptyString) {
    operater_ = new ::std::string;
  }
  operater_->assign(value);
}
inline void S2CAction::set_operater(const char* value) {
  set_has_operater();
  if (operater_ == &::google::protobuf::internal::kEmptyString) {
    operater_ = new ::std::string;
  }
  operater_->assign(value);
}
inline void S2CAction::set_operater(const char* value, size_t size) {
  set_has_operater();
  if (operater_ == &::google::protobuf::internal::kEmptyString) {
    operater_ = new ::std::string;
  }
  operater_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CAction::mutable_operater() {
  set_has_operater();
  if (operater_ == &::google::protobuf::internal::kEmptyString) {
    operater_ = new ::std::string;
  }
  return operater_;
}
inline ::std::string* S2CAction::release_operater() {
  clear_has_operater();
  if (operater_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operater_;
    operater_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 act = 2;
inline bool S2CAction::has_act() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2CAction::set_has_act() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2CAction::clear_has_act() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2CAction::clear_act() {
  act_ = 0;
  clear_has_act();
}
inline ::google::protobuf::int32 S2CAction::act() const {
  return act_;
}
inline void S2CAction::set_act(::google::protobuf::int32 value) {
  set_has_act();
  act_ = value;
}

// optional int32 raise = 3;
inline bool S2CAction::has_raise() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2CAction::set_has_raise() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2CAction::clear_has_raise() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2CAction::clear_raise() {
  raise_ = 0;
  clear_has_raise();
}
inline ::google::protobuf::int32 S2CAction::raise() const {
  return raise_;
}
inline void S2CAction::set_raise(::google::protobuf::int32 value) {
  set_has_raise();
  raise_ = value;
}

// repeated .rpc.Pocker pockers = 4;
inline int S2CAction::pockers_size() const {
  return pockers_.size();
}
inline void S2CAction::clear_pockers() {
  pockers_.Clear();
}
inline const ::rpc::Pocker& S2CAction::pockers(int index) const {
  return pockers_.Get(index);
}
inline ::rpc::Pocker* S2CAction::mutable_pockers(int index) {
  return pockers_.Mutable(index);
}
inline ::rpc::Pocker* S2CAction::add_pockers() {
  return pockers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
S2CAction::pockers() const {
  return pockers_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
S2CAction::mutable_pockers() {
  return &pockers_;
}

// optional int32 combineNum = 5;
inline bool S2CAction::has_combinenum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void S2CAction::set_has_combinenum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void S2CAction::clear_has_combinenum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void S2CAction::clear_combinenum() {
  combinenum_ = 0;
  clear_has_combinenum();
}
inline ::google::protobuf::int32 S2CAction::combinenum() const {
  return combinenum_;
}
inline void S2CAction::set_combinenum(::google::protobuf::int32 value) {
  set_has_combinenum();
  combinenum_ = value;
}

// optional int32 countdownEnd = 6;
inline bool S2CAction::has_countdownend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void S2CAction::set_has_countdownend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void S2CAction::clear_has_countdownend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void S2CAction::clear_countdownend() {
  countdownend_ = 0;
  clear_has_countdownend();
}
inline ::google::protobuf::int32 S2CAction::countdownend() const {
  return countdownend_;
}
inline void S2CAction::set_countdownend(::google::protobuf::int32 value) {
  set_has_countdownend();
  countdownend_ = value;
}

// repeated int32 pots = 7;
inline int S2CAction::pots_size() const {
  return pots_.size();
}
inline void S2CAction::clear_pots() {
  pots_.Clear();
}
inline ::google::protobuf::int32 S2CAction::pots(int index) const {
  return pots_.Get(index);
}
inline void S2CAction::set_pots(int index, ::google::protobuf::int32 value) {
  pots_.Set(index, value);
}
inline void S2CAction::add_pots(::google::protobuf::int32 value) {
  pots_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
S2CAction::pots() const {
  return pots_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
S2CAction::mutable_pots() {
  return &pots_;
}

// repeated string winners = 8;
inline int S2CAction::winners_size() const {
  return winners_.size();
}
inline void S2CAction::clear_winners() {
  winners_.Clear();
}
inline const ::std::string& S2CAction::winners(int index) const {
  return winners_.Get(index);
}
inline ::std::string* S2CAction::mutable_winners(int index) {
  return winners_.Mutable(index);
}
inline void S2CAction::set_winners(int index, const ::std::string& value) {
  winners_.Mutable(index)->assign(value);
}
inline void S2CAction::set_winners(int index, const char* value) {
  winners_.Mutable(index)->assign(value);
}
inline void S2CAction::set_winners(int index, const char* value, size_t size) {
  winners_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CAction::add_winners() {
  return winners_.Add();
}
inline void S2CAction::add_winners(const ::std::string& value) {
  winners_.Add()->assign(value);
}
inline void S2CAction::add_winners(const char* value) {
  winners_.Add()->assign(value);
}
inline void S2CAction::add_winners(const char* value, size_t size) {
  winners_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
S2CAction::winners() const {
  return winners_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
S2CAction::mutable_winners() {
  return &winners_;
}

// repeated .rpc.PockerManBase infos = 9;
inline int S2CAction::infos_size() const {
  return infos_.size();
}
inline void S2CAction::clear_infos() {
  infos_.Clear();
}
inline const ::rpc::PockerManBase& S2CAction::infos(int index) const {
  return infos_.Get(index);
}
inline ::rpc::PockerManBase* S2CAction::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::rpc::PockerManBase* S2CAction::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase >&
S2CAction::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase >*
S2CAction::mutable_infos() {
  return &infos_;
}

// optional .rpc.PockerBegin beginInfo = 10;
inline bool S2CAction::has_begininfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void S2CAction::set_has_begininfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void S2CAction::clear_has_begininfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void S2CAction::clear_begininfo() {
  if (begininfo_ != NULL) begininfo_->::rpc::PockerBegin::Clear();
  clear_has_begininfo();
}
inline const ::rpc::PockerBegin& S2CAction::begininfo() const {
  return begininfo_ != NULL ? *begininfo_ : *default_instance_->begininfo_;
}
inline ::rpc::PockerBegin* S2CAction::mutable_begininfo() {
  set_has_begininfo();
  if (begininfo_ == NULL) begininfo_ = new ::rpc::PockerBegin;
  return begininfo_;
}
inline ::rpc::PockerBegin* S2CAction::release_begininfo() {
  clear_has_begininfo();
  ::rpc::PockerBegin* temp = begininfo_;
  begininfo_ = NULL;
  return temp;
}

// repeated .rpc.ComparePokerPlayer comparePlayers = 11;
inline int S2CAction::compareplayers_size() const {
  return compareplayers_.size();
}
inline void S2CAction::clear_compareplayers() {
  compareplayers_.Clear();
}
inline const ::rpc::ComparePokerPlayer& S2CAction::compareplayers(int index) const {
  return compareplayers_.Get(index);
}
inline ::rpc::ComparePokerPlayer* S2CAction::mutable_compareplayers(int index) {
  return compareplayers_.Mutable(index);
}
inline ::rpc::ComparePokerPlayer* S2CAction::add_compareplayers() {
  return compareplayers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::ComparePokerPlayer >&
S2CAction::compareplayers() const {
  return compareplayers_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::ComparePokerPlayer >*
S2CAction::mutable_compareplayers() {
  return &compareplayers_;
}

// -------------------------------------------------------------------

// ComparePokerPlayer

// required string uid = 1;
inline bool ComparePokerPlayer::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComparePokerPlayer::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComparePokerPlayer::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComparePokerPlayer::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& ComparePokerPlayer::uid() const {
  return *uid_;
}
inline void ComparePokerPlayer::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void ComparePokerPlayer::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void ComparePokerPlayer::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComparePokerPlayer::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* ComparePokerPlayer::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .rpc.Pocker pockers = 2;
inline int ComparePokerPlayer::pockers_size() const {
  return pockers_.size();
}
inline void ComparePokerPlayer::clear_pockers() {
  pockers_.Clear();
}
inline const ::rpc::Pocker& ComparePokerPlayer::pockers(int index) const {
  return pockers_.Get(index);
}
inline ::rpc::Pocker* ComparePokerPlayer::mutable_pockers(int index) {
  return pockers_.Mutable(index);
}
inline ::rpc::Pocker* ComparePokerPlayer::add_pockers() {
  return pockers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
ComparePokerPlayer::pockers() const {
  return pockers_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
ComparePokerPlayer::mutable_pockers() {
  return &pockers_;
}

// repeated .rpc.Pocker combinePockers = 3;
inline int ComparePokerPlayer::combinepockers_size() const {
  return combinepockers_.size();
}
inline void ComparePokerPlayer::clear_combinepockers() {
  combinepockers_.Clear();
}
inline const ::rpc::Pocker& ComparePokerPlayer::combinepockers(int index) const {
  return combinepockers_.Get(index);
}
inline ::rpc::Pocker* ComparePokerPlayer::mutable_combinepockers(int index) {
  return combinepockers_.Mutable(index);
}
inline ::rpc::Pocker* ComparePokerPlayer::add_combinepockers() {
  return combinepockers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
ComparePokerPlayer::combinepockers() const {
  return combinepockers_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
ComparePokerPlayer::mutable_combinepockers() {
  return &combinepockers_;
}

// optional int32 combineNum = 4;
inline bool ComparePokerPlayer::has_combinenum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComparePokerPlayer::set_has_combinenum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComparePokerPlayer::clear_has_combinenum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComparePokerPlayer::clear_combinenum() {
  combinenum_ = 0;
  clear_has_combinenum();
}
inline ::google::protobuf::int32 ComparePokerPlayer::combinenum() const {
  return combinenum_;
}
inline void ComparePokerPlayer::set_combinenum(::google::protobuf::int32 value) {
  set_has_combinenum();
  combinenum_ = value;
}

// -------------------------------------------------------------------

// PockerBegin

// optional string dealerUid = 1;
inline bool PockerBegin::has_dealeruid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PockerBegin::set_has_dealeruid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PockerBegin::clear_has_dealeruid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PockerBegin::clear_dealeruid() {
  if (dealeruid_ != &::google::protobuf::internal::kEmptyString) {
    dealeruid_->clear();
  }
  clear_has_dealeruid();
}
inline const ::std::string& PockerBegin::dealeruid() const {
  return *dealeruid_;
}
inline void PockerBegin::set_dealeruid(const ::std::string& value) {
  set_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    dealeruid_ = new ::std::string;
  }
  dealeruid_->assign(value);
}
inline void PockerBegin::set_dealeruid(const char* value) {
  set_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    dealeruid_ = new ::std::string;
  }
  dealeruid_->assign(value);
}
inline void PockerBegin::set_dealeruid(const char* value, size_t size) {
  set_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    dealeruid_ = new ::std::string;
  }
  dealeruid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PockerBegin::mutable_dealeruid() {
  set_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    dealeruid_ = new ::std::string;
  }
  return dealeruid_;
}
inline ::std::string* PockerBegin::release_dealeruid() {
  clear_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dealeruid_;
    dealeruid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string smBlindUid = 2;
inline bool PockerBegin::has_smblinduid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PockerBegin::set_has_smblinduid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PockerBegin::clear_has_smblinduid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PockerBegin::clear_smblinduid() {
  if (smblinduid_ != &::google::protobuf::internal::kEmptyString) {
    smblinduid_->clear();
  }
  clear_has_smblinduid();
}
inline const ::std::string& PockerBegin::smblinduid() const {
  return *smblinduid_;
}
inline void PockerBegin::set_smblinduid(const ::std::string& value) {
  set_has_smblinduid();
  if (smblinduid_ == &::google::protobuf::internal::kEmptyString) {
    smblinduid_ = new ::std::string;
  }
  smblinduid_->assign(value);
}
inline void PockerBegin::set_smblinduid(const char* value) {
  set_has_smblinduid();
  if (smblinduid_ == &::google::protobuf::internal::kEmptyString) {
    smblinduid_ = new ::std::string;
  }
  smblinduid_->assign(value);
}
inline void PockerBegin::set_smblinduid(const char* value, size_t size) {
  set_has_smblinduid();
  if (smblinduid_ == &::google::protobuf::internal::kEmptyString) {
    smblinduid_ = new ::std::string;
  }
  smblinduid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PockerBegin::mutable_smblinduid() {
  set_has_smblinduid();
  if (smblinduid_ == &::google::protobuf::internal::kEmptyString) {
    smblinduid_ = new ::std::string;
  }
  return smblinduid_;
}
inline ::std::string* PockerBegin::release_smblinduid() {
  clear_has_smblinduid();
  if (smblinduid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = smblinduid_;
    smblinduid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string bigBlindUid = 3;
inline bool PockerBegin::has_bigblinduid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PockerBegin::set_has_bigblinduid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PockerBegin::clear_has_bigblinduid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PockerBegin::clear_bigblinduid() {
  if (bigblinduid_ != &::google::protobuf::internal::kEmptyString) {
    bigblinduid_->clear();
  }
  clear_has_bigblinduid();
}
inline const ::std::string& PockerBegin::bigblinduid() const {
  return *bigblinduid_;
}
inline void PockerBegin::set_bigblinduid(const ::std::string& value) {
  set_has_bigblinduid();
  if (bigblinduid_ == &::google::protobuf::internal::kEmptyString) {
    bigblinduid_ = new ::std::string;
  }
  bigblinduid_->assign(value);
}
inline void PockerBegin::set_bigblinduid(const char* value) {
  set_has_bigblinduid();
  if (bigblinduid_ == &::google::protobuf::internal::kEmptyString) {
    bigblinduid_ = new ::std::string;
  }
  bigblinduid_->assign(value);
}
inline void PockerBegin::set_bigblinduid(const char* value, size_t size) {
  set_has_bigblinduid();
  if (bigblinduid_ == &::google::protobuf::internal::kEmptyString) {
    bigblinduid_ = new ::std::string;
  }
  bigblinduid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PockerBegin::mutable_bigblinduid() {
  set_has_bigblinduid();
  if (bigblinduid_ == &::google::protobuf::internal::kEmptyString) {
    bigblinduid_ = new ::std::string;
  }
  return bigblinduid_;
}
inline ::std::string* PockerBegin::release_bigblinduid() {
  clear_has_bigblinduid();
  if (bigblinduid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bigblinduid_;
    bigblinduid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string attendUids = 4;
inline int PockerBegin::attenduids_size() const {
  return attenduids_.size();
}
inline void PockerBegin::clear_attenduids() {
  attenduids_.Clear();
}
inline const ::std::string& PockerBegin::attenduids(int index) const {
  return attenduids_.Get(index);
}
inline ::std::string* PockerBegin::mutable_attenduids(int index) {
  return attenduids_.Mutable(index);
}
inline void PockerBegin::set_attenduids(int index, const ::std::string& value) {
  attenduids_.Mutable(index)->assign(value);
}
inline void PockerBegin::set_attenduids(int index, const char* value) {
  attenduids_.Mutable(index)->assign(value);
}
inline void PockerBegin::set_attenduids(int index, const char* value, size_t size) {
  attenduids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PockerBegin::add_attenduids() {
  return attenduids_.Add();
}
inline void PockerBegin::add_attenduids(const ::std::string& value) {
  attenduids_.Add()->assign(value);
}
inline void PockerBegin::add_attenduids(const char* value) {
  attenduids_.Add()->assign(value);
}
inline void PockerBegin::add_attenduids(const char* value, size_t size) {
  attenduids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PockerBegin::attenduids() const {
  return attenduids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PockerBegin::mutable_attenduids() {
  return &attenduids_;
}

// -------------------------------------------------------------------

// S2CPockerManInfo

// optional string headerUrl = 1;
inline bool S2CPockerManInfo::has_headerurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2CPockerManInfo::set_has_headerurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2CPockerManInfo::clear_has_headerurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2CPockerManInfo::clear_headerurl() {
  if (headerurl_ != &::google::protobuf::internal::kEmptyString) {
    headerurl_->clear();
  }
  clear_has_headerurl();
}
inline const ::std::string& S2CPockerManInfo::headerurl() const {
  return *headerurl_;
}
inline void S2CPockerManInfo::set_headerurl(const ::std::string& value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void S2CPockerManInfo::set_headerurl(const char* value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void S2CPockerManInfo::set_headerurl(const char* value, size_t size) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CPockerManInfo::mutable_headerurl() {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  return headerurl_;
}
inline ::std::string* S2CPockerManInfo::release_headerurl() {
  clear_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headerurl_;
    headerurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 2;
inline bool S2CPockerManInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2CPockerManInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2CPockerManInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2CPockerManInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& S2CPockerManInfo::name() const {
  return *name_;
}
inline void S2CPockerManInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void S2CPockerManInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void S2CPockerManInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CPockerManInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* S2CPockerManInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 sex = 3;
inline bool S2CPockerManInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2CPockerManInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2CPockerManInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2CPockerManInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 S2CPockerManInfo::sex() const {
  return sex_;
}
inline void S2CPockerManInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 coin = 4;
inline bool S2CPockerManInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void S2CPockerManInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void S2CPockerManInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void S2CPockerManInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 S2CPockerManInfo::coin() const {
  return coin_;
}
inline void S2CPockerManInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 gem = 5;
inline bool S2CPockerManInfo::has_gem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void S2CPockerManInfo::set_has_gem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void S2CPockerManInfo::clear_has_gem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void S2CPockerManInfo::clear_gem() {
  gem_ = 0;
  clear_has_gem();
}
inline ::google::protobuf::int32 S2CPockerManInfo::gem() const {
  return gem_;
}
inline void S2CPockerManInfo::set_gem(::google::protobuf::int32 value) {
  set_has_gem();
  gem_ = value;
}

// optional int32 roleId = 6;
inline bool S2CPockerManInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void S2CPockerManInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void S2CPockerManInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void S2CPockerManInfo::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 S2CPockerManInfo::roleid() const {
  return roleid_;
}
inline void S2CPockerManInfo::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
}

// optional int32 bestPocker = 7;
inline bool S2CPockerManInfo::has_bestpocker() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void S2CPockerManInfo::set_has_bestpocker() {
  _has_bits_[0] |= 0x00000040u;
}
inline void S2CPockerManInfo::clear_has_bestpocker() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void S2CPockerManInfo::clear_bestpocker() {
  bestpocker_ = 0;
  clear_has_bestpocker();
}
inline ::google::protobuf::int32 S2CPockerManInfo::bestpocker() const {
  return bestpocker_;
}
inline void S2CPockerManInfo::set_bestpocker(::google::protobuf::int32 value) {
  set_has_bestpocker();
  bestpocker_ = value;
}

// optional int32 lv = 8;
inline bool S2CPockerManInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void S2CPockerManInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000080u;
}
inline void S2CPockerManInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void S2CPockerManInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 S2CPockerManInfo::lv() const {
  return lv_;
}
inline void S2CPockerManInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// -------------------------------------------------------------------

// PockerManBase

// optional string uid = 1;
inline bool PockerManBase::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PockerManBase::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PockerManBase::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PockerManBase::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& PockerManBase::uid() const {
  return *uid_;
}
inline void PockerManBase::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void PockerManBase::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void PockerManBase::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PockerManBase::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* PockerManBase::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string headerUrl = 2;
inline bool PockerManBase::has_headerurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PockerManBase::set_has_headerurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PockerManBase::clear_has_headerurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PockerManBase::clear_headerurl() {
  if (headerurl_ != &::google::protobuf::internal::kEmptyString) {
    headerurl_->clear();
  }
  clear_has_headerurl();
}
inline const ::std::string& PockerManBase::headerurl() const {
  return *headerurl_;
}
inline void PockerManBase::set_headerurl(const ::std::string& value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void PockerManBase::set_headerurl(const char* value) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(value);
}
inline void PockerManBase::set_headerurl(const char* value, size_t size) {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  headerurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PockerManBase::mutable_headerurl() {
  set_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    headerurl_ = new ::std::string;
  }
  return headerurl_;
}
inline ::std::string* PockerManBase::release_headerurl() {
  clear_has_headerurl();
  if (headerurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headerurl_;
    headerurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 coin = 3;
inline bool PockerManBase::has_coin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PockerManBase::set_has_coin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PockerManBase::clear_has_coin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PockerManBase::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 PockerManBase::coin() const {
  return coin_;
}
inline void PockerManBase::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 drops = 4;
inline bool PockerManBase::has_drops() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PockerManBase::set_has_drops() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PockerManBase::clear_has_drops() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PockerManBase::clear_drops() {
  drops_ = 0;
  clear_has_drops();
}
inline ::google::protobuf::int32 PockerManBase::drops() const {
  return drops_;
}
inline void PockerManBase::set_drops(::google::protobuf::int32 value) {
  set_has_drops();
  drops_ = value;
}

// optional int32 status = 5;
inline bool PockerManBase::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PockerManBase::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PockerManBase::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PockerManBase::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 PockerManBase::status() const {
  return status_;
}
inline void PockerManBase::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated .rpc.Pocker pockers = 6;
inline int PockerManBase::pockers_size() const {
  return pockers_.size();
}
inline void PockerManBase::clear_pockers() {
  pockers_.Clear();
}
inline const ::rpc::Pocker& PockerManBase::pockers(int index) const {
  return pockers_.Get(index);
}
inline ::rpc::Pocker* PockerManBase::mutable_pockers(int index) {
  return pockers_.Mutable(index);
}
inline ::rpc::Pocker* PockerManBase::add_pockers() {
  return pockers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
PockerManBase::pockers() const {
  return pockers_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
PockerManBase::mutable_pockers() {
  return &pockers_;
}

// optional int32 deskIdx = 7;
inline bool PockerManBase::has_deskidx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PockerManBase::set_has_deskidx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PockerManBase::clear_has_deskidx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PockerManBase::clear_deskidx() {
  deskidx_ = 0;
  clear_has_deskidx();
}
inline ::google::protobuf::int32 PockerManBase::deskidx() const {
  return deskidx_;
}
inline void PockerManBase::set_deskidx(::google::protobuf::int32 value) {
  set_has_deskidx();
  deskidx_ = value;
}

// optional string nickName = 8;
inline bool PockerManBase::has_nickname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PockerManBase::set_has_nickname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PockerManBase::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PockerManBase::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& PockerManBase::nickname() const {
  return *nickname_;
}
inline void PockerManBase::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void PockerManBase::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void PockerManBase::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PockerManBase::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* PockerManBase::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 endTime = 9;
inline bool PockerManBase::has_endtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PockerManBase::set_has_endtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PockerManBase::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PockerManBase::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline ::google::protobuf::int32 PockerManBase::endtime() const {
  return endtime_;
}
inline void PockerManBase::set_endtime(::google::protobuf::int32 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional int32 sex = 10;
inline bool PockerManBase::has_sex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PockerManBase::set_has_sex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PockerManBase::clear_has_sex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PockerManBase::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 PockerManBase::sex() const {
  return sex_;
}
inline void PockerManBase::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// Pocker

// required int32 eType = 1;
inline bool Pocker::has_etype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pocker::set_has_etype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pocker::clear_has_etype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pocker::clear_etype() {
  etype_ = 0;
  clear_has_etype();
}
inline ::google::protobuf::int32 Pocker::etype() const {
  return etype_;
}
inline void Pocker::set_etype(::google::protobuf::int32 value) {
  set_has_etype();
  etype_ = value;
}

// required int32 num = 2;
inline bool Pocker::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pocker::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pocker::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pocker::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 Pocker::num() const {
  return num_;
}
inline void Pocker::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// PockerRoomBase

// repeated .rpc.Pocker pockers = 1;
inline int PockerRoomBase::pockers_size() const {
  return pockers_.size();
}
inline void PockerRoomBase::clear_pockers() {
  pockers_.Clear();
}
inline const ::rpc::Pocker& PockerRoomBase::pockers(int index) const {
  return pockers_.Get(index);
}
inline ::rpc::Pocker* PockerRoomBase::mutable_pockers(int index) {
  return pockers_.Mutable(index);
}
inline ::rpc::Pocker* PockerRoomBase::add_pockers() {
  return pockers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >&
PockerRoomBase::pockers() const {
  return pockers_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Pocker >*
PockerRoomBase::mutable_pockers() {
  return &pockers_;
}

// repeated int32 pots = 2;
inline int PockerRoomBase::pots_size() const {
  return pots_.size();
}
inline void PockerRoomBase::clear_pots() {
  pots_.Clear();
}
inline ::google::protobuf::int32 PockerRoomBase::pots(int index) const {
  return pots_.Get(index);
}
inline void PockerRoomBase::set_pots(int index, ::google::protobuf::int32 value) {
  pots_.Set(index, value);
}
inline void PockerRoomBase::add_pots(::google::protobuf::int32 value) {
  pots_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PockerRoomBase::pots() const {
  return pots_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PockerRoomBase::mutable_pots() {
  return &pots_;
}

// optional string dealerUid = 3;
inline bool PockerRoomBase::has_dealeruid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PockerRoomBase::set_has_dealeruid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PockerRoomBase::clear_has_dealeruid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PockerRoomBase::clear_dealeruid() {
  if (dealeruid_ != &::google::protobuf::internal::kEmptyString) {
    dealeruid_->clear();
  }
  clear_has_dealeruid();
}
inline const ::std::string& PockerRoomBase::dealeruid() const {
  return *dealeruid_;
}
inline void PockerRoomBase::set_dealeruid(const ::std::string& value) {
  set_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    dealeruid_ = new ::std::string;
  }
  dealeruid_->assign(value);
}
inline void PockerRoomBase::set_dealeruid(const char* value) {
  set_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    dealeruid_ = new ::std::string;
  }
  dealeruid_->assign(value);
}
inline void PockerRoomBase::set_dealeruid(const char* value, size_t size) {
  set_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    dealeruid_ = new ::std::string;
  }
  dealeruid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PockerRoomBase::mutable_dealeruid() {
  set_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    dealeruid_ = new ::std::string;
  }
  return dealeruid_;
}
inline ::std::string* PockerRoomBase::release_dealeruid() {
  clear_has_dealeruid();
  if (dealeruid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dealeruid_;
    dealeruid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 roomId = 4;
inline bool PockerRoomBase::has_roomid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PockerRoomBase::set_has_roomid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PockerRoomBase::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PockerRoomBase::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 PockerRoomBase::roomid() const {
  return roomid_;
}
inline void PockerRoomBase::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional int32 smallBlind = 5;
inline bool PockerRoomBase::has_smallblind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PockerRoomBase::set_has_smallblind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PockerRoomBase::clear_has_smallblind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PockerRoomBase::clear_smallblind() {
  smallblind_ = 0;
  clear_has_smallblind();
}
inline ::google::protobuf::int32 PockerRoomBase::smallblind() const {
  return smallblind_;
}
inline void PockerRoomBase::set_smallblind(::google::protobuf::int32 value) {
  set_has_smallblind();
  smallblind_ = value;
}

// optional int32 bigBlind = 6;
inline bool PockerRoomBase::has_bigblind() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PockerRoomBase::set_has_bigblind() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PockerRoomBase::clear_has_bigblind() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PockerRoomBase::clear_bigblind() {
  bigblind_ = 0;
  clear_has_bigblind();
}
inline ::google::protobuf::int32 PockerRoomBase::bigblind() const {
  return bigblind_;
}
inline void PockerRoomBase::set_bigblind(::google::protobuf::int32 value) {
  set_has_bigblind();
  bigblind_ = value;
}

// optional int32 roomNo = 7;
inline bool PockerRoomBase::has_roomno() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PockerRoomBase::set_has_roomno() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PockerRoomBase::clear_has_roomno() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PockerRoomBase::clear_roomno() {
  roomno_ = 0;
  clear_has_roomno();
}
inline ::google::protobuf::int32 PockerRoomBase::roomno() const {
  return roomno_;
}
inline void PockerRoomBase::set_roomno(::google::protobuf::int32 value) {
  set_has_roomno();
  roomno_ = value;
}

// -------------------------------------------------------------------

// PockerRoomInfo

// repeated .rpc.PockerManBase players = 1;
inline int PockerRoomInfo::players_size() const {
  return players_.size();
}
inline void PockerRoomInfo::clear_players() {
  players_.Clear();
}
inline const ::rpc::PockerManBase& PockerRoomInfo::players(int index) const {
  return players_.Get(index);
}
inline ::rpc::PockerManBase* PockerRoomInfo::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::rpc::PockerManBase* PockerRoomInfo::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase >&
PockerRoomInfo::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::PockerManBase >*
PockerRoomInfo::mutable_players() {
  return &players_;
}

// optional .rpc.PockerRoomBase roombase = 2;
inline bool PockerRoomInfo::has_roombase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PockerRoomInfo::set_has_roombase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PockerRoomInfo::clear_has_roombase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PockerRoomInfo::clear_roombase() {
  if (roombase_ != NULL) roombase_->::rpc::PockerRoomBase::Clear();
  clear_has_roombase();
}
inline const ::rpc::PockerRoomBase& PockerRoomInfo::roombase() const {
  return roombase_ != NULL ? *roombase_ : *default_instance_->roombase_;
}
inline ::rpc::PockerRoomBase* PockerRoomInfo::mutable_roombase() {
  set_has_roombase();
  if (roombase_ == NULL) roombase_ = new ::rpc::PockerRoomBase;
  return roombase_;
}
inline ::rpc::PockerRoomBase* PockerRoomInfo::release_roombase() {
  clear_has_roombase();
  ::rpc::PockerRoomBase* temp = roombase_;
  roombase_ = NULL;
  return temp;
}

// optional int32 code = 3;
inline bool PockerRoomInfo::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PockerRoomInfo::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PockerRoomInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PockerRoomInfo::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 PockerRoomInfo::code() const {
  return code_;
}
inline void PockerRoomInfo::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// LeavePockerRoom

// optional string uid = 1;
inline bool LeavePockerRoom::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeavePockerRoom::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeavePockerRoom::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeavePockerRoom::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& LeavePockerRoom::uid() const {
  return *uid_;
}
inline void LeavePockerRoom::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void LeavePockerRoom::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void LeavePockerRoom::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeavePockerRoom::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* LeavePockerRoom::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
